var tipuesearch = {"pages":[{"title":" M_msg ","text":"M_msg — DEPRECATED (at least for now) – see M_framework — — Name M_msg Description This is a collection of modules useful for creating messages, logfiles and\nperforming unit tests, M_msg is a small module that can convert a list of variables of any of\n   the most common default types to a string. It performs low-level operations that are often used by other larger\n   modules so it is in its own module to prevent circular dependencies. M_verify contains procedures useful for generating unit tests M_journal allows for creating log and journal files Building the Module A conventional GNU/Linux or Unix install: git clone https://github.com/urbanjost/M_msg.git cd M_msg/src # change Makefile if not using one of the listed compilers # for gfortran make clean make F90 = gfortran gfortran # for ifort make clean make F90 = ifort ifort # for nvfortran make clean make F90 = nvfortran nvfortran This will compile the Fortran module and basic test\nprograms Optionally Supports FPM Alternatively, download the github repository and\nbuild it with fpm ( as described at Fortran Package\nManager ) git clone https://github.com/urbanjost/M_msg.git cd M_msg fpm test or just list it as a dependency in your fpm.toml project file. [dependencies] M_msg = { git = \"https://github.com/urbanjost/M_msg.git\" } (registered at the fpm(1) registry ) Documentation User man-pages in manpages.zip manpages.tgz An index to HTML versions\n   of the manpages A single page that uses javascript to combine all the HTML descriptions\n   of the man-pages is at BOOK_M_msg . Additional Directory Descriptions There are src/ is where the source for the M_msg(3f) modules resides docs/ contains HTML documentation and the manpage archives test/ contains a simple test program example/ has demos Developer Info John Doe","tags":"home","loc":"index.html"},{"title":"one – M_msg","text":"public  subroutine one() Arguments None Source Code subroutine one () end subroutine one","tags":"","loc":"proc/one.html"},{"title":"test_suite_M_demo – M_msg","text":"public  subroutine test_suite_M_demo() Uses M_verify Arguments None Source Code subroutine test_suite_M_demo use M_verify , only : unit_check_start , unit_check use M_verify , only : unit_check_good , unit_check_bad , unit_check_done use M_verify , only : unit_check_msg , unit_check_stop implicit none integer :: i , j , k integer , allocatable :: array (:) integer :: arr ( 4 ) = [ 21 , 51 , 14 , 45 ] integer :: a = 21 , b = 51 , c = 14 , d = 45 ! TEST-DRIVEN DEVELOPMENT ! optional set-up       perform initialization operations common to all tests within a module i = 1 j = 2 k = 3 array = [ 10 , 20 , 30 , 40 , 50 , 60 , 70 ] call test_one () call test_two () ! optional tear-down    perform finalization operations common to all tests within a module contains subroutine test_one () !  register an entry for specified name (\"one\") in database with status of zero (0) call unit_check_start ( 'one' ) !  if mask test fails, can !  * produce a SUCCESS: or FAIL: message and stop program !  * change database status for specified entry to -1 and stop program, else continue !  * produce a SUCCESS: or FAIL: message and keep going !  * produce a FAIL: message if test fails but no SUCCESS: message if test passes call unit_check ( 'one' , i > 0 , msg = 'I > 0' ) ! using ANY(3f) and ALL(3f) call unit_check ( 'one' , all ([ i , j , k ] > 0 ), 'testing if everyone greater than zero' ) ! display message built of scalars as well call unit_check ( 'one' , all (. not .[ i , j , k ] == 4 ), 'for set ' , i , j , k , 'testing if no one is equal to four' ) ! for tests that are hard to reduce to a logical test just call unit_check_bad(3f) if fail if ( i + j + k < 1 ) then call unit_check_bad ( 'one' ) endif call unit_check_done ( 'one' , 'checks on \"one\" ended' ) end subroutine test_one subroutine test_two ! use of all(3f), any(3f), merge(3f) can be useful ! if you know what these would produce ! write(*,*)['A','X','X','X','X','B'] == 'B'      ! this would return an array, the last element having the value T, else F ! write(*,*)all(['A','X','X','X','X','X'] == 'X') ! this would return F ! write(*,*)any(['A','X','X','X','X','X'] == 'B') ! this would return F ! write(*,*)any(['A','X','X','X','X','B'] == 'B') ! this would return T ! write(*,*).not.all(array < 100) ! write(*,*)all(array < 100) ! write(*,*)all([a,b,c,d] == [21,51,14,45]) ! compare a list. This would return T ! write(*,*)all(arr == [21,51,14,45])       ! compare an array. This would return T ! you know how valuable ANY(3f) and ALL(3f) will be call unit_check_start ( 'two' , 'check on \"two\" passed' ) call unit_check ( 'two' , 1 > 0 . and . abs ( 1 0.10000 - 1 0.10001 ) < 0.0001 , msg = 'two looks good' ) call unit_check_done ( 'two' , 'checks on \"two\" ended' ) end subroutine test_two end subroutine test_suite_M_demo","tags":"","loc":"proc/test_suite_m_demo.html"},{"title":"two – M_msg","text":"public  subroutine two() Arguments None Source Code subroutine two () end subroutine two","tags":"","loc":"proc/two.html"},{"title":"test_accdig – M_msg","text":"subroutine test_accdig() call unit_check(‘accdig’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_accdig () call unit_check_start ( 'accdig' , msg = '' ) !!call unit_check('accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'accdig' , msg = '' ) end subroutine test_accdig","tags":"","loc":"proc/test_accdig.html"},{"title":"test_almost – M_msg","text":"subroutine test_almost() Arguments None Variables Type Visibility Attributes Name Initial logical, public, parameter :: expected (*) = [.true., .true., .false., .false., .false., .false., .false., .false.] integer, public :: i real, public :: r real, public :: x real, public :: y Source Code subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_check_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_check ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i )) enddo call unit_check_done ( 'almost' , msg = '' ) end subroutine test_almost","tags":"","loc":"proc/test_almost.html"},{"title":"test_dp_accdig – M_msg","text":"subroutine test_dp_accdig() call unit_check(‘dp_accdig’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_dp_accdig () call unit_check_start ( 'dp_accdig' , msg = '' ) !!call unit_check('dp_accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'dp_accdig' , msg = '' ) end subroutine test_dp_accdig","tags":"","loc":"proc/test_dp_accdig.html"},{"title":"test_in_margin – M_msg","text":"subroutine test_in_margin() call unit_check(‘in_margin’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_in_margin () call unit_check_start ( 'in_margin' , msg = '' ) !!call unit_check('in_margin', 0.eq.0, 'checking', 100) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_check ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_check ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_check_done ( 'in_margin' , msg = '' ) end subroutine test_in_margin","tags":"","loc":"proc/test_in_margin.html"},{"title":"test_round – M_msg","text":"subroutine test_round() call unit_check(‘round’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_round () call unit_check_start ( 'round' , msg = '' ) !!call unit_check('round', 0.eq.0, 'checking', 100) call unit_check_done ( 'round' , msg = '' ) end subroutine test_round","tags":"","loc":"proc/test_round.html"},{"title":"test_significant – M_msg","text":"subroutine test_significant() call unit_check(‘significant’, 0.eq.0, ‘checking’, 100) Arguments None Source Code subroutine test_significant () call unit_check_start ( 'significant' , msg = '' ) !!call unit_check('significant', 0.eq.0, 'checking', 100) call unit_check_done ( 'significant' , msg = '' ) end subroutine test_significant","tags":"","loc":"proc/test_significant.html"},{"title":"journal – M_msg","text":"public interface journal Module Procedures private  subroutine flush_trail() Arguments None private  subroutine write_message_only(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message private  subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep) NAME where_write_message_all ( 3 f ) - [ M_journal ] converts any standard scalar type to a string and calls journal ( 3 f ) ( LICENSE : PD ) SYNOPSIS subroutine where_write_message_all(where,g0,g1,g2g3,g4,g5,g6,g7,g8,g9,sep) character(len=*),intent(in)   :: where\n class(*),intent(in)           :: g0\n class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9\n character,intent(in),optional :: sep DESCRIPTION where_write_message_all(3f) builds and writes a space-separated string from up to nine scalar values. OPTIONS where string designating where to write message , as with journal ( 3 f ) g0 value to print . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . g [ 1 - 9 ] optional additional values to print the value of after g0 . sep separator to add between values . Default is a space RETURNS where_write_message_all  description to print EXAMPLES Sample program: program demo_wm_all use M_journal , only : where_write_message_all implicit none end program program demo_wm_all AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: where class(*), intent(in) :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 character(len=1), intent(in), optional :: sep private  subroutine set_stdout_lun(iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit","tags":"","loc":"interface/journal.html"},{"title":"test_flush_trail – M_msg","text":"subroutine test_flush_trail() call unit_check(‘flush_trail’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_flush_trail () implicit none call unit_check_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_check('flush_trail', 0.eq.0, 'checking',100) call unit_check_done ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail","tags":"","loc":"proc/test_flush_trail.html"},{"title":"test_set_stdout_lun – M_msg","text":"subroutine test_set_stdout_lun() call unit_check(‘set_stdout_lun’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_set_stdout_lun () implicit none call unit_check_start ( 'set_stdout_lun' , msg = '' ) !!call unit_check('set_stdout_lun', 0.eq.0, 'checking',100) call unit_check_done ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun","tags":"","loc":"proc/test_set_stdout_lun.html"},{"title":"test_where_write_message_all – M_msg","text":"subroutine test_where_write_message_all() call unit_check(‘where_write_message_all’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_where_write_message_all () implicit none call unit_check_start ( 'where_write_message_all' , msg = '' ) !!call unit_check('where_write_message_all', 0.eq.0, 'checking',100) call unit_check_done ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all","tags":"","loc":"proc/test_where_write_message_all.html"},{"title":"test_write_message_only – M_msg","text":"subroutine test_write_message_only() call unit_check(‘write_message_only’, 0.eq.0, ‘checking’,100) Arguments None Source Code subroutine test_write_message_only () implicit none call unit_check_start ( 'write_message_only' , msg = '' ) !!call unit_check('write_message_only', 0.eq.0, 'checking',100) call unit_check_done ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only","tags":"","loc":"proc/test_write_message_only.html"},{"title":"add – M_msg","text":"subroutine add(message, question, answer, answer2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: question character(len=*), intent(in) :: answer character(len=*), intent(in) :: answer2 Variables Type Visibility Attributes Name Initial logical, public :: passed Source Code subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if (. not . passed ) then passed = question . eq . answer2 endif write ( * , '(*(g0,1x))' ) passed , 'expected ' , answer , 'got' , question tests = [ tests , passed ] allpassed = allpassed . and . passed end subroutine add","tags":"","loc":"proc/add.html"},{"title":"almost – M_msg","text":"public  function almost(x, y, digits, verbose) Uses M_journal NAME almost ( 3 f ) - [ M_verify ] return true or false if two numbers agree up to specified number of digits ( LICENSE : PD ) SYNOPSIS function almost ( x,y,digits ) class ( * ), intent ( in ) :: x , y class ( * ), intent ( in ) :: rdigits logical , intent ( in ), optional :: verbose logical :: almost DESCRIPTION Returns true or false depending on whether the two numbers given agree\nto within the specified number of digits as calculated by ACCDIG(3f). OPTIONS x , y expected and calculated values to be compared . May be of type REAL , INTEGER , or DOUBLEPRECISION . rdigits real number representing number of digits of precision to compare verbose optional value that specifies to print the results of the comparison when set to . TRUE .. RETURNS almost TRUE if the input values compare up to the specified number of values EXAMPLE sample: program demo_almost use M_verify , only : almost implicit none real :: x , y logical :: z integer :: i x = 1.2345678 y = 1.2300000 do i = 1 , 8 z = almost ( x , y , real ( i ), verbose =. true .) write ( * , * ) i , z enddo end program demo_almost output: *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 1.0\n        1   T *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 2.0\n        2   T *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 3.0\n        3   F *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 4.0\n        4   F *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 5.0\n        5   F *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 6.0\n        6   F *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 7.0\n        7   F *accdig* significant digit request too high= 8.00000000 *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 8.0\n        8   F AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digits logical, intent(in), optional :: verbose Return Value logical Source Code function almost ( x , y , digits , verbose ) use M_journal , only : journal ! ident_14=\"@(#) M_verify almost(3f) function to compare two real numbers only up to a specified number of digits by calling DP_ACCDIG(3f)\" class ( * ), intent ( in ) :: x , y class ( * ), intent ( in ) :: digits logical , intent ( in ), optional :: verbose logical :: almost logical :: verbose_local real :: acurcy real :: digits_local integer :: ind if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif digits_local = anyscalar_to_realbig ( digits ) acurcy = 0.0 select type ( x ) type is ( real ) select type ( y ) type is ( real ) call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif class default call dp_accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select class default call dp_accdig ( x , y , digits , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select if ( ind == 0 ) then almost = . true . else almost = . false . endif end function almost","tags":"","loc":"proc/almost.html"},{"title":"in_margin – M_msg","text":"public impure elemental function in_margin(expected_value, measured_value, allowed_margin) NAME in_margin(3f) - [M_verify] check if two reals are approximately equal using a relative margin SYNOPSIS elemental pure function in_margin( expected_value, measured_value, allowed_margin )\n\n  real, intent(in)    :: expected_value\n  real, intent(in)    :: measured_value\n  real, intent(in)    :: allowed_margin\n  class(*),intent(in) :: invalue DESCRIPTION Compare two values to see if they are relatively equal using the\n   specified allowed margin. That is, see if VALUE_MEASURED is in\n   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error\n   varies with the magnitude of the values, such that the allowed error\n   is margin * average magnitude of measured and expected). So the allowed error is smaller when the magnitudes are smaller. OPTIONS expected_value   First value\n   measured_value   Second value\n   allowed_margin   Allowed relative margin EXAMPLE Sample program: program demo_in_margin use :: M_verify , only : in_margin implicit none write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 40.0 , 400.0 , 4000.0 , 40000.0 ], [ 3.9 , 39.9 , 399.9 , 3999.9 , 39999.9 ] , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 40.0 , 400.0 , 4000.0 , 40000.0 ], [ 3.9 , 39.9 , 399.9 , 3999.9 , 39999.9 ] , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.01 ) end program demo_in_margin Results: F\n F\n F\n F\n F F F F F\n F F F F T\n T\n T\n T\n T Arguments Type Intent Optional Attributes Name class(*), intent(in) :: expected_value class(*), intent(in) :: measured_value class(*), intent(in) :: allowed_margin Return Value logical Source Code elemental impure function in_margin ( expected_value , measured_value , allowed_margin ) implicit none ! ident_17=\"@(#) M_verify in_margin(3f) check if two reals are approximately equal using a relative margin\" class ( * ), intent ( in ) :: expected_value , measured_value , allowed_margin logical :: in_margin doubleprecision :: expected , measured , margin expected = anyscalar_to_double ( expected_value ) measured = anyscalar_to_double ( measured_value ) margin = anyscalar_to_double ( allowed_margin ) if ( abs ( expected - measured ) > 0.50d0 * margin * ( abs ( expected ) + abs ( measured )) ) then in_margin = . false . ! values not comparable else in_margin = . true . ! values comparable endif end function in_margin","tags":"","loc":"proc/in_margin.html"},{"title":"round – M_msg","text":"public  function round(val, idigits0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val integer, intent(in) :: idigits0 Return Value real(kind=dp) Source Code function round ( val , idigits0 ) implicit none ! ident_19=\"@(#) M_verify round(3f) round val to specified number of significant digits\" integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ), intent ( in ) :: val integer , intent ( in ) :: idigits0 integer :: idigits , ipow real ( kind = dp ) :: aval , rnormal real ( kind = dp ) :: round !  this does not work very well because of round-off errors. !  Make a better one, probably have to use machine-dependent bit shifting ! make sure a reasonable number of digits has been requested idigits = max ( 1 , idigits0 ) aval = abs ( val ) !  select a power that will normalize the number !  (put it in the range 1 > abs(val) <= 0) if ( aval >= 1 ) then ipow = int ( log10 ( aval ) + 1 ) else ipow = int ( log10 ( aval )) endif rnormal = val / ( 1 0.0d0 ** ipow ) if ( rnormal == 1 ) then ipow = ipow + 1 endif !normalize, multiply by 10*idigits to an integer, and so on round = real ( anint ( val * 1 0.d0 ** ( idigits - ipow ))) * 1 0.d0 ** ( ipow - idigits ) end function round","tags":"","loc":"proc/round.html"},{"title":"round_to_power – M_msg","text":"public pure elemental function round_to_power(val, n) Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: n Return Value real Source Code pure elemental function round_to_power ( val , n ) ! ident_18=\"@(#) M_verify round_to_power(3f) round val to specified given decimal (power) position\" real , intent ( in ) :: val integer , intent ( in ) :: n real :: round_to_power round_to_power = anint ( val * 1 0.0 ** n ) / 1 0.0 ** n end function round_to_power","tags":"","loc":"proc/round_to_power.html"},{"title":"significant – M_msg","text":"public pure elemental function significant(val, digits, round) NAME significant(3f) - [M_verify] round val to specified number of significant digits SYNOPSIS pure elemental function significant(val,digits,round)\n\n  real,intent(in)                      :: val\n  integer,intent(in)                   :: digits\n  character(len=*),intent(in),optional :: round\n  real                                 :: significant DESCRIPTION Round real value to specified number of significant digits val     value to round\n digits  number of significant digits to produce\n round   Use the round edit descriptor RU  UP : the value resulting from conversion shall be the\n                smallest representable value that is greater than or\n                equal to the original value\n       RD  DOWN : the value resulting from conversion shall be the\n                largest representable value that is less than or\n                equal to the original value\n       RZ  ZERO : the value resulting from conversion shall be the value\n                closest to the original value and no greater in\n                magnitude than the original value.\n       RN  NEAREST : modeis NEAREST,thevalueresulting from conversion\n                    shall be the closer of the two nearest\n                    representable values if one is closer than the\n                    other. If the two nearest representable values\n                    are equidistant from the original value, it is\n                    processor dependent which one of them is chosen.\n       RC  COMPATIBLE : the value resulting from conversion shall be\n                      the closer of the two nearest representable\n                      values or the value away from zero if halfway\n                      between them.\n       RP  PROCESSOR_DEFINED : rounding during conversion shall be\n                               a processor-dependent default mode,\n                               which may correspond to one of the\n                               other modes. EXAMPLE Sample program program demo_significant use M_verify , only : significant implicit none integer :: i real :: r , v character ( len = * ), parameter :: g = ' ( * ( g0 .7 , 1 x )) ' write ( * , g ) significant ([ 8765.43210 , 0.1234567890 ], 5 ) write ( * , * ) ' default : ' , 1.23456789012345 write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RU ' ), ' RU ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RD ' ), ' RD ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RZ ' ), ' RZ ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RN ' ), ' RN ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RC ' ), ' RC ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], ' RP ' ), ' RP ' end program demo_significant Results: 8765.400 .1234600 def ault : 1.234568 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RU 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 1.234567 1.234568 1.234568 RD 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 1.234567 1.234568 1.234568 RZ 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RN 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RC 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RP Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real Source Code pure elemental function significant ( val , digits , round ) ! ident_20=\"@(#) M_verify significant(3f) round val to specified number of significant digits\" real , intent ( in ) :: val integer , intent ( in ) :: digits character ( len =* ), intent ( in ), optional :: round real :: significant character ( len = 80 ) :: line , fmt if ( present ( round )) then write ( fmt , '(\"(\",a,\",e0.\",i0,\")\")' ) trim ( round ), digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE else write ( fmt , '(\"(e0.\",i0,\")\")' ) digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE endif write ( line , fmt ) val ! write with specified number of significant diguts read ( line , '(e50.20)' ) significant ! read back into a value end function significant","tags":"","loc":"proc/significant.html"},{"title":"accdig – M_msg","text":"public  subroutine accdig(x, y, digi0, acurcy, ind) Uses M_journal NAME accdig ( 3 f ) - [ M_verify ] compare two real numbers only up to a specified number of digits ( LICENSE : PD ) SYNOPSIS subroutine accdig(x,y,digio,acurcy,ind)\n\n    real,intent(in)     :: X\n    real,intent(in)     :: Y\n    real,intent(in)     :: DIGI0\n    real,intent(out)    :: acurcy\n    integer,intent(out) :: ind DESCRIPTION This procedure is used to check how closely two numbers agree . call accdig ( X , Y , DIGI0 , ACURCY , IND ) The values X and Y are the numbers to compare , and DIGI0 is the threshold number of digits to consider significant in returning IND . If X and Y are considered equal within DIGI0 relative tolerance , IND = 0 , if tolerance is satisfied . = 1 , if tolerance is not satisfied . The result ACURCY gives a measure of the number of leading digits in X which are the same as the number of leading digits in Y . ACURCY =- log10 (( X - Y ) / Y ) if X != Y and Y != 0 ACURCY =- log10 ( X - Y ) if X != Y and Y = 0 ACURCY = 8 if X = Y ACURCY is never less than - 8 or greater than 8 TOLERANCE ... X and Y are considered equal within DIGI0 relative tolerance , if ACURCY is greater than DIGI0 . For example , Take some numbers and compare then to 1 . 2345678 ... ================================================ A number | ACURCY | ACURCY | 1 . 2345678 = Y | 1 . 2345678 = X ================================================ 1 . 234680 | 3 . 7900571 | 3 . 7901275 1 . 2345378 | 4 . 6144510 | 4 . 6144404 2 . 2234568 | 0 . 096367393 | 0 . 35188114 1 . 2345678 | 8 . 0000000 | 8 . 0000000 1 . 2345679 | 7 . 0732967 | 7 . 0731968 - 1 . 2345678 | - 0 . 30103000 | - 0 . 30103000 76 . 234567 | - 1 . 7835463 | 0 . 0070906729 2 . 4691356 | 0 . 0 | 0 . 3010300 0 . 0 | 0 . 0 | - 0 . 91514942 . Due to the typical limits of the log function , the number of significant digits in the result is best considered to be three . Notice that 1 . 2345678 = Y produces different values than 1 . 2345678 = X A negative result indicates the two values being compared either do not agree in the first digit or they differ with respect to sign . An example of two numbers which do not agree in their leading digit ( and actually differ in order of magnitude ) is given above by X = 76 . 234567 and Y = 1 . 2345678 ; the accuracy reported is -1.7835463. An example of two numbers which do not agree in sign in X =- 1 . 2345678 and Y = 1 . 2345678 ; here the accuracy reported is - 0 . 30103000 . EXAMPLE Example program: program demo_accdig ! fortran 90 example use M_verify , only : accdig implicit none integer :: digi integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 real :: a , b real :: vals ( 9 ) data vals / & & 1.234680 , 1.2345378 , 2.2234568 , 1.2345678 , & & 1.2345679 , - 1.2345678 , 76.234567 , 2.4691356 , & & 0.0 / write ( * , * ) ' ======================== = ' do i10 = 0 , 16 a = 1.0 b = a + 1.0 / ( 10 ** i10 ) call accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) ' ======================== = ' digi = 16 do i20 = 0 , digi a = 1.0 b = a + 1.0 / ( 10 ** i20 ) call accdig ( a , b , real ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) ' ======================== = ' do i30 = 1 , 9 call accdig ( 1.2345678 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ), 1.2345678 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig REFERENCES based on … NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. accdig V 7.00  2/14/90. **\n   David Hogben,\n   Statistical Engineering Division,\n   Center for Computing and Applied Mathematics,\n   A337 Administration Building,\n   National Institute of Standards and Technology,\n   Gaithersburg, MD 20899\n                  TELEPHONE 301-975-2845\n       ORIGINAL VERSION -  October, 1969.\n        CURRENT VERSION - February, 1990.\n        JSU     VERSION - February, 1991. DEPENDENCIES o M_journal(),log10(), abs(1) AUTHOR David Hogben, John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind Source Code SUBROUTINE accdig ( X , Y , digi0 , ACURCY , IND ) use M_journal , only : journal implicit none ! ident_15=\"@(#) M_verify accdig(3f) compare two real numbers only up to a specified number of digits\" !     INPUT ... real , intent ( in ) :: x ! First  of two real numbers to be compared. real , intent ( in ) :: y ! Second of two real numbers to be compared. real , intent ( in ) :: digi0 ! Number of digits to be satisfied in relative tolerance. !     OUTPUT ... integer , intent ( out ) :: ind ! = 0, If tolerance is     satisfied. ! = 1, If tolerance is not satisfied. real , intent ( out ) :: acurcy ! = - LOG10(ABS((X-Y)/Y))) real :: diff real :: digi integer :: ireal_significant_digits !----------------------------------------------------------------------------------------------------------------------------------- ireal_significant_digits = int ( log10 ( 2. ** digits ( 0.0 ))) ! maximum number of significant digits in a real number. digi = digi0 if ( digi <= 0 ) then call journal ( 'sc' , '*accdig* bad number of significant digits=' , digi ) digi = ireal_significant_digits elseif ( digi > ireal_significant_digits ) then call journal ( 'sc' , '*accdig* significant digit request too high=' , digi ) digi = min ( digi , real ( ireal_significant_digits )) endif !----------------------------------------------------------------------------------------------------------------------------------- diff = x - y if ( diff == 0.0 ) then acurcy = digi elseif ( y == 0.0 ) then acurcy = - log10 ( abs ( x )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y )) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( acurcy < digi ) then ind = 1 else ind = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- END SUBROUTINE accdig","tags":"","loc":"proc/accdig.html"},{"title":"assert – M_msg","text":"public  subroutine assert(filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9) NAME assert ( 3 f ) - [ M_verify ] print filename , linenumber , and message to stderr and stop program ( LICENSE : PD ) SYNOPSIS function assert ( file,linenum,expr,g1,g2g3,g4,g5,g6,g7,g8,g9 ) character ( len = * ), intent ( in ) :: file character ( len = * ), intent ( in ) :: linenum logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 DESCRIPTION assert ( 3 f ) prints strings to stderr and then stops program with exit code 1 It labels the first string as the filename , the next integer parameter as the linenumber , and then up to nine scalar values . It is primarily intended for use by the prep ( 1 ) preprocessor $ ASSERT directive OPTIONS filename a string assumed to be the current filename when compiling linenum assumed to be the line number of the source code the ASSERT ( 3 f ) procedure was called at . expr logical value g [ 1 - 9 ] optional value ( s ) to print as a message before stopping . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . EXAMPLES Sample program: program demo_assert use M_verify , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( ' myroutine ' , 101 , a > toobig , ' The value is too large ' , a , ' > ' , toobig ) end program demo_assert AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: linen logical, intent(in) :: expr class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 Source Code subroutine assert ( filename , linen , expr , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 ) implicit none ! ident_12=\"@(#) M_verify assert(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: linen logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 class ( * ), intent ( in ), optional :: g6 , g7 , g8 , g9 ! write message to standard error if (. not . expr ) then call stderr ( 'ERROR:filename:' , filename , ':line number:' , linen , ':' , str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 )) stop 1 endif end subroutine assert","tags":"","loc":"proc/assert.html"},{"title":"dp_accdig – M_msg","text":"public  subroutine dp_accdig(x, y, digi0, acurcy, ind) Uses M_journal iso_fortran_env NAME dp_accdig ( 3 f ) - [ M_verify ] compare two numbers only up to a specified number of digits ( LICENSE : PD ) SYNOPSIS subroutine dp_accdig(x,y,digio,acurcy,ind)\n\n    class(*),intent(in)  :: X\n    class(*),intent(in)  :: Y\n    class(*),intent(in)  :: DIGI0\n    real,intent(out)     :: acurcy\n    integer,intent(out)  :: ind DESCRIPTION This procedure is used to check how closely two numbers agree.\n\n   call dp_accdig(X,Y,DIGI0,ACURCY,IND)\n\nThe values X and Y are the numbers to compare, and DIGI0 is the\nthreshold number of digits to consider significant in returning IND.\n\nIf X and Y are considered equal within DIGI0 relative tolerance,\n\n    IND    = 0, if tolerance is     satisfied.\n           = 1, if tolerance is not satisfied.\n\nThe result ACURCY gives a measure of the number of leading digits in X\nwhich are the same as the number of leading digits in Y.\n\n     ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0\n     ACURCY=-log10(X-Y)       if X != Y and Y = 0\n     ACURCY=8                 if X=Y\n\n     ACURCY is never less than -8 or greater than 8 for REAL values\n\nTOLERANCE ...\n     X and Y are considered equal within DIGI0 relative tolerance,\n     if ACURCY is greater than DIGI0.\n\nFor example, Take some numbers and compare then  to 1.2345678 ...\n\n   ================================================\n   A number     |    ACURCY       |   ACURCY\n                |    1.2345678=Y  |   1.2345678=X\n   ================================================\n    1.234680    |    3.7900571    |   3.7901275\n    1.2345378   |    4.6144510    |   4.6144404\n    2.2234568   |    0.096367393  |   0.35188114\n    1.2345678   |    8.0000000    |   8.0000000\n    1.2345679   |    7.0732967    |   7.0731968\n   -1.2345678   |   -0.30103000   |  -0.30103000\n   76.234567    |   -1.7835463    |   0.0070906729\n    2.4691356   |    0.0          |   0.3010300\n    0.0         |    0.0          |  -0.91514942.\n\nDue to the typical limits of the log function, the number of\nsignificant digits in the result is best considered to be three.\n\nNotice that 1.2345678=Y produces different values than 1.2345678=X\n\nA negative result indicates the two values being compared either do\nnot agree in the first digit or they differ with respect to sign. An\nexample of two numbers which do not agree in their leading digit (and\nactually differ in order of magnitude) is given above by X=76.234567\nand Y=1.2345678; the accuracy reported is -1.7835463. An example of\ntwo numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678;\nhere the accuracy reported is -0.30103000. EXAMPLE Example program: program demo_dp_accdig ! fortran 90 example use M_verify , only : dp_accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1.234680 d0 , 1.2345378 d0 , 2.2234568 d0 , 1.2345678 d0 , & & 1.2345679 d0 , - 1.2345678 d0 , 76.234567 d0 , 2.4691356 d0 , & & 0.0 d0 / write ( * , * ) ' ======================== = ' do i10 = 0 , 16 a = 1.0 d0 b = a + 1.0 d0 / ( 10 ** i10 ) call dp_accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) ' ======================== = ' digi = 16 do i20 = 0 , digi a = 1.0 d0 b = a + 1.0 d0 / ( 10 ** i20 ) call dp_accdig ( a , b , dble ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) ' ======================== = ' do i30 = 1 , 9 call dp_accdig ( 1.2345678 d0 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call dp_accdig ( vals ( i30 ), 1.2345678 d0 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_dp_accdig NOTES REFERENCES based on … NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. **\n   David Hogben,\n   Statistical Engineering Division,\n   Center for Computing and Applied Mathematics,\n   A337 Administration Building,\n   National Institute of Standards and Technology,\n   Gaithersburg, MD 20899\n                  TELEPHONE 301-975-2845\n       ORIGINAL VERSION -  October, 1969.\n        CURRENT VERSION - February, 1990.\n        JSU     VERSION - February, 1991. DEPENDENCIES o M_journal(), log10(), abs(1) AUTHORS David Hogben, John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind Source Code SUBROUTINE dp_accdig ( x , y , digi0 , ACURCY , IND ) #ifdef __NVCOMPILER use , intrinsic :: iso_fortran_env , only : wp => real64 #else use , intrinsic :: iso_fortran_env , only : wp => real128 #endif use M_journal , only : journal implicit none ! ident_16=\"@(#) M_verify dp_accdig(3f) compare two values only up to a specified number of digits\" !  INPUT ... class ( * ), intent ( in ) :: x ! FIRST  OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: y ! SECOND OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: digi0 ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE. real ( kind = wp ) :: x_local real ( kind = wp ) :: y_local !  OUTPUT ... integer , intent ( out ) :: ind ! = 0, IF TOLERANCE IS     SATISFIED. ! = 1, IF TOLERANCE IS NOT SATISFIED. real , intent ( out ) :: acurcy ! = - LOG10(ABS((x_local-y_local)/y_local))) real ( kind = wp ) :: diff real ( kind = wp ) :: digi integer :: idble_significant_digits !----------------------------------------------------------------------------------------------------------------------------------- x_local = anyscalar_to_realbig ( x ) y_local = anyscalar_to_realbig ( y ) digi = anyscalar_to_realbig ( digi0 ) !----------------------------------------------------------------------------------------------------------------------------------- idble_significant_digits = int ( log10 ( 2.0_wp ** digits ( 0.0_wp ))) ! MAXIMUM NUMBER OF SIGNIFICANT DIGITS IN A REAL128 NUMBER. if ( digi <= 0 ) then call journal ( 'sc' , '*dp_accdig* bad number of significant digits=' , real ( digi , kind = wp )) digi = idble_significant_digits elseif ( digi > idble_significant_digits ) then call journal ( 'sc' , '*dp_accdig* significant digit request too high=' , real ( digi , kind = wp )) digi = min ( digi , real ( idble_significant_digits , kind = wp )) endif diff = x_local - y_local if ( diff == 0.0_wp ) then acurcy = digi elseif ( y_local == 0.0_wp ) then acurcy = - log10 ( abs ( x_local )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y_local )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif end subroutine dp_accdig","tags":"","loc":"proc/dp_accdig.html"},{"title":"fstop – M_msg","text":"public  subroutine fstop(ierr, stdout, stderr) NAME fstop ( 3 f ) - [ M_verify ] call stop with both a number and a message ( LICENSE : PD ) SYNOPSIS subroutine fstop(ierr,stdout,stderr)\n\n integer,intent(in)                   :: ierr\n character(len=*),intent(in),optional :: stdout\n character(len=*),intent(in),optional :: stderr DESCRIPTION FSTOP ( 3 f ) call STOP ( 3 f ) . What a call to STOP does is very system dependent , so using an abstraction layer is useful , as it allows just the fstop () routine to be changed ; and STOP does not allow a variable to be used on the numeric access status ( this has changed at f2015 ) . OPTIONS ierr    - value in range 0 to 32\nstdout  - description to be printed to standard output\nstderr  - description to be printed to standard error EXAMPLES Sample program: program demo_fstop use M_verify , only : fstop implicit none integer :: int ! * ! write ( * , * ) ' Enter stop value ' ! * ! read ( * , * ) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = ' error : program will now stop ' ) case ( 25 ) ; call fstop ( int , stdout = ' stdout message ' , stderr = ' stderr message ' ) case ( 30 ) ; call fstop ( int , stdout = ' error : program will now stop ' ) case default call fstop ( int ) endselect end program demo_fstop Results: SEE ALSO Look for common extensions, such as abort(3f), backtrace(3f) AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: stdout character(len=*), intent(in), optional :: stderr Source Code subroutine fstop ( ierr , stdout , stderr ) ! ident_3=\"@(#) M_verify fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message\" integer , intent ( in ) :: ierr character ( len =* ), optional , intent ( in ) :: stdout character ( len =* ), optional , intent ( in ) :: stderr character ( len = 132 ) :: message ! The standard states: !   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the !   processor supports that concept. If the integer stop-code is used as the process exit status, the processor !   might be able to interpret only values within a limited range, or only a limited portion of the integer value !   (for example, only the least-significant 8 bits). !   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed, !   it is recommended that the value zero be supplied as the process exit status, if the processor supports that !   concept. !   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement. ! ! Conforming variants I have encountered include !    o printing a message such as 'STOP nnn' when the integer value is called !    o having a limit on the length of the message string passed !    o prefixing the message with the string 'STOP ' !    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument !      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...) !    o whether messages appear on stdout or stderr. !    o no value being returned to the system at all. ! !  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported. !  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated? ! !  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value. !  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system, !  but I sometimes want to return variables. ! !  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message !  to appear when using integer values ! !  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky !  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran !  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a !  value to the system and Fortran does not, but I do not recommend it. ! !  Note that the C function \"exit(int signal)\" not only works more consistently but that the global values EXIT_SUCCESS and !  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant. ! !  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure. !----------------------------------------------------------------------------------------------------------------------------------- !STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab' !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( stderr )) then ! write message to stderr, assuming string length is allowed if ( stderr /= '' ) then write ( error_unit , '(a)' ) trim ( stderr ) endif !f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED) !f2015!      case(0); allstop 0 !f2015!      case(1); allstop 1 !f2015!      case(2); allstop 2 !f2015!      case(3); allstop 3 !f2015!      case(4); allstop 4 !f2015!      case(5); allstop 5 !f2015!      case(6); allstop 6 !f2015!      case(7); allstop 7 !f2015!      case(8); allstop 8 !f2015!      case(9); allstop 8 !f2015!      case(10); allstop 10 !f2015!      case(11); allstop 11 !f2015!      case(12); allstop 12 !f2015!      case(13); allstop 13 !f2015!      case(14); allstop 14 !f2015!      case(15); allstop 15 !f2015!      case(16); allstop 16 !f2015!      case(17); allstop 17 !f2015!      case(18); allstop 18 !f2015!      case(19); allstop 19 !f2015!      case(20); allstop 20 !f2015!      case(21); allstop 21 !f2015!      case(22); allstop 22 !f2015!      case(23); allstop 23 !f2015!      case(24); allstop 24 !f2015!      case(25); allstop 25 !f2015!      case(26); allstop 26 !f2015!      case(27); allstop 27 !f2015!      case(28); allstop 28 !f2015!      case(29); allstop 29 !f2015!      case(30); allstop 30 !f2015!      case(31); allstop 31 !f2015!      case(32); allstop 32 !f2015!   case default !f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system' !f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error !f2015!      allstop 1 !f2015!   end select endif if ( present ( stdout )) then ! write message to stdout, assuming string length is allowed if ( stdout /= '' ) then write ( * , '(a)' ) trim ( stdout ) endif endif select case ( ierr ) ! have executable return an exit status to the system (IF SUPPORTED) case ( 0 ); stop 0 case ( 1 ); stop 1 case ( 2 ); stop 2 case ( 3 ); stop 3 case ( 4 ); stop 4 case ( 5 ); stop 5 case ( 6 ); stop 6 case ( 7 ); stop 7 case ( 8 ); stop 8 case ( 9 ); stop 8 case ( 10 ); stop 10 case ( 11 ); stop 11 case ( 12 ); stop 12 case ( 13 ); stop 13 case ( 14 ); stop 14 case ( 15 ); stop 15 case ( 16 ); stop 16 case ( 17 ); stop 17 case ( 18 ); stop 18 case ( 19 ); stop 19 case ( 20 ); stop 20 case ( 21 ); stop 21 case ( 22 ); stop 22 case ( 23 ); stop 23 case ( 24 ); stop 24 case ( 25 ); stop 25 case ( 26 ); stop 26 case ( 27 ); stop 27 case ( 28 ); stop 28 case ( 29 ); stop 29 case ( 30 ); stop 30 case ( 31 ); stop 31 case ( 32 ); stop 32 case default write ( message , '(a,i0,a)' ) '*fstop*: stop value of ' , ierr , ' returning 1 to system' write ( error_unit , '(a)' ) trim ( message ) ! write message to standard error stop 1 end select end subroutine fstop","tags":"","loc":"proc/fstop.html"},{"title":"pdec – M_msg","text":"public  subroutine pdec(string) NAME pdec ( 3 f ) - [ M_verify ] write out string with ASCII decimal equivalent vertically under it ( LICENSE : PD ) SYNOPSIS Usage : subroutine pdec ( string ) character ( len =*), intent ( in ) :: string DESCRIPTION Given a string to print , PDEC () writes out the ASCII Decimal equivalent of the string directly underneath it . This can help you to locate unprintable characters or non - standard white - space such as a backspace character or tab character in input strings that your program could not interpret . On output , non - printable characters are replaced with a space , and trailing spaces are ignored . You read the numbers vertically . 1. ignore trailing spaces 2. print the character if it has an ADE of 32 on up 3. print a space if it has an ADE of less than 32 4. underneath each character print the ADE value vertically 5. strings are assumed under 32767 characters in length . Format integer constants > 32767 are not supported on HP - UX when newer compilers are available use unlimited EXAMPLES Sample program:\n\n   program demo_pdec\n   use M_verify, only : pdec\n   call pdec(' ABCDEFG abcdefg    ')\n   end program demo_pdec\n\nwould produce (notice trailing space is trimmed): > ABCDEFG abcdefg >0000000000001111\n  >3666667739990000\n  >2567890127890123 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Source Code subroutine pdec ( string ) ! ident_10=\"@(#) M_verify pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string\" character ( len =* ), intent ( in ) :: string ! the string to print integer :: ilen ! number of characters in string to print integer :: i ! counter used to step thru string !----------------------------------------------------------------------------------------------------------------------------------- ilen = len_trim ( string (: len ( string ))) ! get trimmed length of input string write ( * , 101 )( char ( max ( 32 , ichar ( string ( i : i )))), i = 1 , ilen ) ! replace lower unprintable characters with spaces ! print ADE value of character underneath it write ( * , 202 ) ( ichar ( string ( i : i )) / 100 , i = 1 , ilen ) write ( * , 202 )( mod ( ichar ( string ( i : i )), 100 ) / 10 , i = 1 , ilen ) write ( * , 202 )( mod (( ichar ( string ( i : i ))), 10 ), i = 1 , ilen ) 101 format ( 32767 a1 :) ! format for printing string characters 202 format ( 32767 i1 :) ! format for printing ADE values end subroutine pdec","tags":"","loc":"proc/pdec.html"},{"title":"stderr – M_msg","text":"public  subroutine stderr(msg, gen0, gen1, gen2, gen3, gen4, gen5, gen6, gen7, gen8, gen9) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: msg class(*), intent(in), optional :: gen0 class(*), intent(in), optional :: gen1 class(*), intent(in), optional :: gen2 class(*), intent(in), optional :: gen3 class(*), intent(in), optional :: gen4 class(*), intent(in), optional :: gen5 class(*), intent(in), optional :: gen6 class(*), intent(in), optional :: gen7 class(*), intent(in), optional :: gen8 class(*), intent(in), optional :: gen9 Source Code subroutine stderr ( msg , gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 ) implicit none ! ident_2=\"@(#) M_verify stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: msg class ( * ), intent ( in ), optional :: gen0 , gen1 , gen2 , gen3 , gen4 class ( * ), intent ( in ), optional :: gen5 , gen6 , gen7 , gen8 , gen9 integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( msg , gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr","tags":"","loc":"proc/stderr.html"},{"title":"unit_check – M_msg","text":"public  subroutine unit_check(name, logical_expression, msg, msg1, msg2, msg3, msg4, msg5, msg6, msg7, msg8, msg9) NAME unit_check ( 3 f ) - [ M_verify ] if logical expression is false , call command \"goodbad NAME bad\" and stop program by default ( LICENSE : PD ) SYNOPSIS subroutine unit_check(name,expression,msg,msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9)\n\n character(len=*),intent(in) :: name\n logical,intent(in) :: expression\n class(*),intent(in),optional :: msg,msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9 DESCRIPTION unit_check(3f) tests the expression and if it is false, calls the\nshell command\n\n     goodbad NAME bad\n\nand stops the program. OPTIONS NAME             the unit test name passed on to the goodbad(1)\n                  command\n EXPRESSION       the logical expression to evaluate\n MSG,MSG1...MSG9  optional message to display when performing test,\n                  composed of any scalar intrinsics of type INTEGER,\n                  REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or\n                  CHARACTER, with a space placed between each value. EXAMPLES Sample program: program demo_unit_check use M_verify , only : unit_check use M_verify , only : unit_check_start use M_verify , only : unit_check_done use M_verify , only : almost !! use M_verify , only : unit_check_keep_going ! default is unit_check_keep_going =. false . !! use M_verify , only : debug ! default is . false . !! use M_verify , only : unit_check_command ! default is unit_check_command = '' ; was ' goodbad ' implicit none integer :: i integer :: x integer , allocatable :: arr (:) real , allocatable :: arr1 (:) real , allocatable :: arr2 (:) !! unit_check_command = '' x = 10 arr1 =[ 1.0 , 10.0 , 100.0 ] arr2 =[ 1.0001 , 10.001 , 100.01 ] call unit_check_start ( ' myroutine ' ) call unit_check ( ' myroutine ' , x > 3 , ' test if big enough ' ) call unit_check ( ' myroutine ' , x < 100 , ' test if small enough ' ) do i = 1 , size ( arr1 ) call unit_check ( ' myroutine ' , almost ( arr1 ( i ), arr2 ( i ), 3.9 , verbose =. true .) ) enddo arr =[ 10 , 20 , 30 ] call unit_check ( ' myroutine ' , . not . any ( arr < 0 ) , ' test if any negative values in array ARR ' ) call unit_check ( ' myroutine ' , all ( arr < 100 ) , ' test if all values less than 100 in array ARR ' ) call unit_check_done ( ' myroutine ' , msg = ' checks on \"myroutine\" all passed ' ) end program demo_unit_check Sample output (varies with what goodbad(1) command is used): unit_check : myroutine SUCCESS : test if big enough unit_check : myroutine SUCCESS : test if small enough unit_check : myroutine SUCCESS : test if any negative values in array ARR unit_check : myroutine SUCCESS : test if all values less than 100 in array ARR * almost * for values 1.00000000 1.00010002 agreement of 3.99997139 digits out of requested 3.90000010 * almost * for values 10.0000000 10.0010004 agreement of 3.99986792 digits out of requested 3.90000010 * almost * for values 100.000000 100.010002 agreement of 3.99995065 digits out of requested 3.90000010 unit_check_good : myroutine PASSED : checks on \"myroutine\" all passed AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: msg1 class(*), intent(in), optional :: msg2 class(*), intent(in), optional :: msg3 class(*), intent(in), optional :: msg4 class(*), intent(in), optional :: msg5 class(*), intent(in), optional :: msg6 class(*), intent(in), optional :: msg7 class(*), intent(in), optional :: msg8 class(*), intent(in), optional :: msg9 Source Code subroutine unit_check ( name , logical_expression , msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 ) ! ident_4=\"@(#) M_verify unit_check(3f) if .not.expression call 'goodbad NAME bad' & stop program\" character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: logical_expression class ( * ), intent ( in ), optional :: msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 character ( len = :), allocatable :: msg_local !----------------------------------------------------------------------------------------------------------------------------------- msg_local = str ( msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 ) !----------------------------------------------------------------------------------------------------------------------------------- if (. not . logical_expression ) then call stderr ( trim ( unit_check_prefix ) // 'check:       ' // atleast ( name , 20 ) // ' FAILURE : ' // trim ( msg_local )) if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' bad' ) endif if (. not . unit_check_keep_going ) then call stderr ( trim ( unit_check_prefix ) // 'check:         STOPPING PROGRAM ON FAILED TEST OF ' // trim ( name )) call fstop ( 1 ) endif IFAILED_G = IFAILED_G + 1 IFAILED_ALL_G = IFAILED_ALL_G + 1 else if (. not . no_news_is_good_news ) then call stderr ( trim ( unit_check_prefix ) // 'check:       ' // atleast ( name , 20 ) // ' SUCCESS : ' // trim ( msg_local )) endif IPASSED_G = IPASSED_G + 1 IPASSED_ALL_G = IPASSED_ALL_G + 1 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check","tags":"","loc":"proc/unit_check.html"},{"title":"unit_check_bad – M_msg","text":"public  subroutine unit_check_bad(name, opts, msg) NAME unit_check_bad ( 3 f ) - [ M_verify ] call command \"goodbad NAME bad\" and stop program ( LICENSE : PD ) SYNOPSIS subroutine unit_check_bad(name,opts,msg)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION unit_check_bad ( 3 f ) calls the shell command goodbad NAME bad [ opts ] and stops the program . It is just a shortcut for calling call unit_check ( name ,. false .) call unit_check_done ( name , opts , msg ) EXAMPLES Sample program: program demo_unit_check_bad use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( ' myroutine ' ) call unit_check ( ' myroutine ' , x > 3 , ' test if big enough ' ) call unit_check ( ' myroutine ' , x < 100 , ' test if small enough ' ) if ( x /= 0 ) then call unit_check_bad ( ' myroutine ' , msg = ' checks on \"myroutine\" failed ' ) ! program execution stopped endif end program demo_unit_check_bad AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg Source Code subroutine unit_check_bad ( name , opts , msg ) ! ident_8=\"@(#) M_verify unit_check_bad(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_check ( name ,. false .) call unit_check_done ( name , opts_local , msg_local ) end subroutine unit_check_bad","tags":"","loc":"proc/unit_check_bad.html"},{"title":"unit_check_done – M_msg","text":"public  subroutine unit_check_done(name, opts, msg) Uses iso_fortran_env NAME unit_check_done ( 3 f ) - [ M_verify ] call command \"goodbad NAME good\" or \"goodbad NAME bad\" depending on whether failures were found ( LICENSE : PD ) SYNOPSIS subroutine unit_check_done(name,opts,msg)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION If there have been no failures the shell command goodbad NAME good [ opts ] is executed , else the command goodbad NAME bad [ opts ] is executed and by default stops the program if their have been any failures . EXAMPLES Sample program: program demo_unit_check_done use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_done , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( ' myroutine ' ) call unit_check ( ' myroutine ' , x > 3 , ' test if big enough ' ) call unit_check ( ' myroutine ' , x < 100 , ' test if small enough ' ) if ( x /= 0 ) then call unit_check_done ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) ! program execution stopped endif end program demo_unit_check_done AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg Source Code subroutine unit_check_done ( name , opts , msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_7=\"@(#) M_verify unit_check_done(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local character ( len = 4096 ) :: out character ( len = 9 ) :: pf integer ( kind = int64 ) :: milliseconds integer :: clicks_now if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif !----------------------------------------------------------------------------------------------------------------------------------- if ( unit_check_command /= '' ) then ! if system command name is not blank call system command if ( ifailed_g == 0 ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' bad ' // trim ( opts )) if (. not . unit_check_keep_going ) call fstop ( 1 ) ! stop program depending on mode else call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' good ' // trim ( opts )) endif endif !----------------------------------------------------------------------------------------------------------------------------------- PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_G == 0 ) then PF = 'UNTESTED:' endif if ( duration /= 0.0d0 ) then call system_clock ( clicks_now ) milliseconds = ( julian () - duration ) * 1000 milliseconds = clicks_now - clicks write ( out , '(a,\"check_done:  \",a,    & & 1x,a,                            & & \" GOOD:\",i9,                     & & \" BAD:\",i9,                      & & \" DURATION:\",i14.14              & & )' ) & & trim ( unit_check_prefix ), & & atleast ( name , 20 ), & & PF , & & IPASSED_G , & & IFAILED_G , & & milliseconds else write ( out , '(a,\"check_done:  \",a,1x,a,\" GOOD:\",i0,1x,\" BAD:\",i0)' ) & & trim ( unit_check_prefix ), atleast ( name , 20 ), PF , IPASSED_G , IFAILED_G endif if ( present ( msg )) then call stderr ( trim ( out ) // ': ' // trim ( msg )) else call stderr ( out ) endif !----------------------------------------------------------------------------------------------------------------------------------- IPASSED_G = 0 IFAILED_G = 0 IUNTESTED = 0 duration = 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_done","tags":"","loc":"proc/unit_check_done.html"},{"title":"unit_check_good – M_msg","text":"public  subroutine unit_check_good(name, opts, msg) NAME unit_check_good ( 3 f ) - [ M_verify ] call command \"goodbad NAME good\" ( LICENSE : PD ) SYNOPSIS subroutine unit_check_good(name,opts,msg)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION A shortcut for\n\n   call unit_check(name,.true.)\n   call unit_check_done(name,opts,msg) EXAMPLES Sample program: program demo_unit_check_good use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( ' myroutine ' ) call unit_check ( ' myroutine ' , x > 3 , ' test if big enough ' ) call unit_check ( ' myroutine ' , x < 100 , ' test if small enough ' ) call unit_check_good ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) end program demo_unit_check_good AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg Source Code subroutine unit_check_good ( name , opts , msg ) ! ident_9=\"@(#) M_verify unit_check_good(3f) call 'goodbad NAME good'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_check ( name ,. true ., msg = msg_local ) call unit_check_done ( name , opts_local ) !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_good","tags":"","loc":"proc/unit_check_good.html"},{"title":"unit_check_msg – M_msg","text":"public  subroutine unit_check_msg(name, g1, g2, g3, g4, g5, g6, g7, g8, g9) NAME unit_check_msg ( 3 f ) - [ M_verify ] converts up to nine standard scalar values to a message for unit testing ( LICENSE : PD ) SYNOPSIS function unit_check_msg ( name,g1,g2g3,g4,g5,g6,g7,g8,g9 ) character ( len = * ), intent ( in ) :: name class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 DESCRIPTION unit_check_msg(3f) builds a string from up to nine scalar values and\nprints it to the error long. OPTIONS name name of unit being tested g [ 1 - 9 ] optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . EXAMPLES Sample program: program demo_unit_check_msg use M_verify , only : unit_check_start , unit_check_msg , unit_check_done implicit none call unit_check_start ( ' myroutine ' ) call unit_check_msg ( ' myroutine ',' HUGE ( 3 f ) integers ' , huge ( 0 ), ' and real ' , huge ( 0.0 ), ' and double ' , huge ( 0.0 d0 )) call unit_check_msg ( ' myroutine ',' real : ' , huge ( 0.0 ), 0.0 , 12345.6789 , tiny ( 0.0 ) ) call unit_check_msg ( ' myroutine ',' doubleprecision : ' , huge ( 0.0 d0 ), 0.0 d0 , 12345.6789 d0 , tiny ( 0.0 d0 ) ) call unit_check_msg ( ' myroutine ',' complex : ' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) call unit_check_done ( ' myroutine ' ) end program demo_unit_check_msg AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 Source Code subroutine unit_check_msg ( name , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 ) implicit none ! ident_1=\"@(#) M_verify unit_check_msg(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: name class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 class ( * ), intent ( in ), optional :: g6 , g7 , g8 , g9 ! write message to standard error call stderr ( trim ( unit_check_prefix ) // 'check_msg:   ' // atleast ( name , 20 ) // ' INFO    : ' // str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 )) end subroutine unit_check_msg","tags":"","loc":"proc/unit_check_msg.html"},{"title":"unit_check_start – M_msg","text":"public  subroutine unit_check_start(name, options, msg) NAME unit_check_start ( 3 f ) - [ M_verify ] call command \"goodbad NAME start\" and optionally set options ( LICENSE : PD ) SYNOPSIS subroutine unit_check_start(name,options,msg)\n\n character(len=*),intent(in)          :: name\n character(len=*),intent(in),optional :: options\n character(len=*),intent(in),optional :: msg DESCRIPTION unit_check_start ( 3 f ) is an initialization command that by default calls the shell command goodbad NAME start [ options ] The command can be changed by setting the environment variable UNIT_CHECK_COMMAND or the global module variable UNIT_CHECK_COMMAND . The environment variable overrides the global module variable . By default if a unit_check ( 3 f ) logical expression is false or the unit_check_bad ( 3 f ) procedure is called the program will be stopped . This has the same effect as setting the environment variable M_verify_STOP to \"FALSE\" or the global module variable UNIT_CHECK_KEEP_GOING to . FALSE . . Set the value to . true . and the program will continue even when tests fail . OPTIONS NAME name of the shell command to execute . If blank , no command is executed . OPTIONS pass additional options to the shell command MSG print message EXAMPLES Sample program: program demo_unit_check_start use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_done implicit none integer :: ival call unit_check_start ( 'myroutine' ) ! the goodbad ( 1 ) command called here takes many options ! used to build an SQLite3 entry call unit_check_start ( 'myroutine_long' , ' & & -section        3                    & & -library        libGPF               & & -filename       `pwd`/M_verify.FF     & & -documentation  y                    & & -prep           y                    & & -ccall          n                    & & -archive        GPF.a                & & ' ) ival = 10 call unit_check ( 'myroutine' , ival > 3 , msg = 'test if big enough' ) call unit_check ( 'myroutine' , ival < 100 , msg = 'test if small enough' ) call unit_check_done ( 'myroutine' , msg = 'completed checks of \"myroutine\"' ) end program demo_unit_check_start AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: options character(len=*), intent(in), optional :: msg Source Code subroutine unit_check_start ( name , options , msg ) ! ident_5=\"@(#) M_verify unit_check_start(3f) call 'goodbad NAME start'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: options character ( len =* ), intent ( in ), optional :: msg character ( len = 4096 ) :: var logical , save :: called = . false . !----------------------------------------------------------------------------------------------------------------------------------- call get_environment_variable ( 'UNIT_CHECK_COMMAND' , var ) if ( var /= '' ) unit_check_command = var !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( options )) then if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' start ' // trim ( options )) endif else if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' start' ) endif endif !----------------------------------------------------------------------------------------------------------------------------------- call system_clock ( clicks ) duration = julian () if (. not . called ) then call system_clock ( clicks_all ) duration_all = julian () called = . true . endif if ( present ( msg )) then if ( msg /= '' ) then call stderr ( trim ( unit_check_prefix ) // 'check_start: ' // atleast ( name , 20 ) // ' START   : ' // trim ( msg )) endif endif call get_environment_variable ( 'M_verify_STOP' , var ) select case ( var ) case ( 'FALSE' , 'false' , '1' , 'no' , 'NO' ) unit_check_keep_going = . false . end select !----------------------------------------------------------------------------------------------------------------------------------- IPASSED_G = 0 IFAILED_G = 0 IUNTESTED = 0 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_start","tags":"","loc":"proc/unit_check_start.html"},{"title":"unit_check_stop – M_msg","text":"public  subroutine unit_check_stop(msg) Uses iso_fortran_env NAME unit_check_stop ( 3 f ) - [ M_verify ] call command \"goodbad NAME good\" or goodbad NAME bad \" depending on whether failures were found ( LICENSE : PD ) SYNOPSIS subroutine unit_check_stop(name,opts,msg)\n\n character(len=*),intent(in) :: name\n character(len=*),intent(in),optional :: opts\n character(len=*),intent(in),optional :: msg DESCRIPTION give a tally of all calls to unit_check(3f) EXAMPLES Sample program: program demo_unit_check_stop use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_stop , unit_check_bad use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level implicit none integer :: x unit_check_command = '' unit_check_keep_going =. true . unit_check_level = 0 x = 10 call unit_check_start ( ' myroutine ' ) call unit_check ( ' myroutine ' , x > 3 , ' test if big enough ' ) call unit_check ( ' myroutine ' , x < 100 , ' test if small enough ' ) if ( x /= 0 ) then call unit_check_bad ( ' myroutine ' , msg = ' x /= 0 ' ) endif call unit_check_done ( ' myroutine ' , msg = ' checks on \"myroutine\" ' ) call unit_check_stop () end program demo_unit_check_stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg Source Code subroutine unit_check_stop ( msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_6=\"@(#) M_verify unit_check_stop(3f) stop program with report on calls to unit_check(3f)\" character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = 4096 ) :: out character ( len = :), allocatable :: PF integer ( kind = int64 ) :: milliseconds integer :: clicks_now if ( present ( msg )) then msg_local = msg else msg_local = '' endif call system_clock ( clicks_now ) milliseconds = ( julian () - duration_all ) * 1000 milliseconds = clicks_now - clicks_all PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_all_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_all_G == 0 ) then PF = 'UNTESTED:' endif write ( out , '(a,                               & & \"check_stop:  TALLY                \",a,& & \" GOOD:\",i9,                           & & \" BAD:\",i9,                            & & \" DURATION:\",i14.14                    & & )' ) & & trim ( unit_check_prefix ), & & PF , & & IPASSED_ALL_G , & & IFAILED_ALL_G , & & milliseconds if ( present ( msg )) then call stderr ( trim ( out ) // ': ' // trim ( msg )) else call stderr ( out ) endif if ( IFAILED_ALL_G == 0 ) then stop EXIT_SUCCESS else stop EXIT_FAILURE endif end subroutine unit_check_stop","tags":"","loc":"proc/unit_check_stop.html"},{"title":"fmt – M_msg","text":"public recursive function fmt(generic, format) result(line) Uses iso_fortran_env NAME fmt ( 3 f ) - [ M_msg ] convert any intrinsic to a string using specified format ( LICENSE : PD ) SYNOPSIS function fmt(value,format) result ( string ) class ( * ), intent ( in ), optional :: value character ( len = * ), intent ( in ), optional :: format character ( len =:), allocatable :: string DESCRIPTION FMT(3f) converts any standard intrinsic value to a string using the specified\nformat. OPTIONS value value to print the value of . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . format format to use to print value . It is up to the user to use an appropriate format . The format does not require being surrounded by parenthesis . If not present a default is selected similar to what would be produced with free format . RETURNS string   A string value EXAMPLES Sample program: program demo_fmt use :: M_msg , only : fmt implicit none character ( len =:), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) ' result is ' , output output = fmt ( 10.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) ' result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) ' result is ' , output end program demo_fmt Results: result is [ 10 ] result is [ 3.3333 ] result is The final answer is [ T ] AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Source Code recursive function fmt ( generic , format ) result ( line ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 ! ident_4=\"@(#) M_msg fmt(3f) convert any intrinsic to a string using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local integer :: ios character ( len = 255 ) :: msg character ( len = 1 ), parameter :: null = char ( 0 ) integer :: ilen if ( present ( format )) then fmt_local = format else fmt_local = '' endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable ios = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null #endif type is ( logical ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( character ( len =* )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( complex ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null end select if ( ios /= 0 ) then line = '<ERROR>' // trim ( msg ) else ilen = index ( line , null , back = . true .) if ( ilen == 0 ) ilen = len ( line ) line = line (: ilen - 1 ) endif end function fmt","tags":"","loc":"proc/fmt.html"},{"title":"stderr – M_msg","text":"public  subroutine stderr(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) NAME stderr ( 3 f ) - [ M_msg ] write message to stderr ( LICENSE : PD ) SYNOPSIS subroutine stderr ( msg , [ generic ] ) class ( * ), intent ( in ), optional :: msg class ( * ), intent ( in ), optional :: generic0 , generic1 , generic2 , generic3 , generic4 class ( * ), intent ( in ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 DESCRIPTION STDERR(3f) writes a message to standard error using a standard f2003 method.\nUp to ten generic options are available. OPTIONS msg - description to print generic [ 0 - 9 ] - optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . EXAMPLES Sample program: program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_msg , only : stderr implicit none call stderr ( ' A simple message ' ) call stderr ( ' error : RVALUE = ' , 3.0 / 4.0 ) call stderr ( ' error : IVALUE = ' , 123456789 ) call stderr ( ' error : LVALUE = ' ,. true .) SEVERAL : block integer :: least = 10 , most = 999 , ival = - 10 call stderr ( ' error : value ' , ival , ' should be between ' , least , ' and ' , most ) endblock SEVERAL call stderr ( ' real32 : ' , huge ( 0.0 _real32 ), 0.0 _real32 , 12345.6789 _real32 , tiny ( 0.0 _real32 )) call stderr ( ' real64 : ' , huge ( 0.0 _real64 ), 0.0 _real64 , 12345.6789 _real64 , tiny ( 0.0 _real64 )) ! # ifdef __NVCOMPILER ! # else call stderr ( ' real128 : ' , huge ( 0.0 _real128 ), 0.0 _real128 , 12345.6789 _real128 , tiny ( 0.0 _real128 )) ! # endif call stderr ( ' complex : ' , cmplx ( huge ( 0.0 _real ), tiny ( 0.0 _real ))) call stderr ( ' error : program will now stop ' ) stop 1 end program demo_stderr Results:\n     A simple message\n     error: RVALUE= 0.750000000\n     error: IVALUE= 123456789\n     error: LVALUE= T\n     error: value -10 should be between 10 and 999\n     real32  : 3.40282347E+38 …\n               0.00000000 …\n               12345.6787 …\n               1.17549435E-38\n     real64  : 1.7976931348623157E+308 …\n               0.0000000000000000 …\n               12345.678900000001 …\n               2.2250738585072014E-308\n     real128 : 1.18973149535723176508575932662800702E+4932 …\n               0.00000000000000000000000000000000000  …\n               12345.6789000000000000000000000000002 …\n               3.36210314311209350626267781732175260E-4932\n     complex : (3.40282347E+38,1.17549435E-38)\n     error: program will now stop\n     STOP 1 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj Source Code subroutine stderr ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_5=\"@(#) M_msg stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr","tags":"","loc":"proc/stderr~2.html"},{"title":"wrt – M_msg","text":"public  subroutine wrt(luns, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat) NAME wrt ( 3 f ) - [ M_msg ] write multiple scalar values to any number of files ( LICENSE : PD ) SYNOPSIS subroutine wrt(luns,generic(s),iostat)\n\n integer,intent(in)           :: luns(:)\n class(*),intent(in),optional :: generic0,generic1,generic2,generic3,generic4\n class(*),intent(in),optional :: generic5,generic6,generic7,generic8,generic9\n class(*),intent(in),optional :: generica,genericb,genericc,genericd,generice\n class(*),intent(in),optional :: genericf,genericg,generich,generici,genericj\n integer,intent(out),optional :: ios DESCRIPTION WRT(3f) writes a list of scalar values  to the list of unit numbers in LUNS(:). OPTIONS LUNS Unit numbers to write to . If of size zero no output is generated generic [ 1 - 20 ] optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . RETURNS IOSTAT The value of the last non - zero IOSTAT value . Returns zero if no errors occurred . EXAMPLES Sample program: program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_msg , only : wrt , fmt implicit none integer , allocatable :: luns ( : ) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , ' NULL LIST : ' , huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , iostat = iostat ) write ( * , * ) ' IOSTAT = ' , iostat ! multiple files can be used to create a log file , for example luns = [ stderr , stdout ] call wrt ( luns , ' TWO FILES : ' , huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , iostat = iostat ) write ( * , * ) ' IOSTAT = ' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], ' USING FMT : ' , & & huge ( 0 ), ' PI = ' , asin ( 1.0 d0 ) * 2.0 d0 , fmt ( ints ( 2 ), ' i0 .4 ' ), iostat = iostat ) end program demo_wrt TWO FILES: 2147483647 PI= 3.1415926535897931 TWO FILES: 2147483647 PI= 3.1415926535897931 IOSTAT=           0 USING FMT : 2147483647 PI= 3.1415926535897931 0002 USING FMT : 2147483647 PI= 3.1415926535897931 0002 USING FMT : 2147483647 PI= 3.1415926535897931 0002 IOSTAT=           0 AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name integer, intent(in) :: luns (:) class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj integer, intent(out), optional :: iostat Source Code subroutine wrt ( luns , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , iostat ) implicit none ! ident_6=\"@(#) M_msg write(3f) writes a message to any number of open files with any scalar values\" integer , intent ( in ) :: luns (:) class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer , intent ( out ), optional :: iostat integer :: i character ( len = 256 ) :: msg do i = 1 , size ( luns ) write ( luns ( i ), '(a)' , iostat = iostat , iomsg = msg ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if ( iostat /= 0 ) then call stderr ( '<ERROR>*write*:' , msg ) endif enddo end subroutine wrt","tags":"","loc":"proc/wrt.html"},{"title":"set – M_msg","text":"public interface set Module Procedures private  subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(out), optional :: generic1 class(*), intent(out), optional :: generic2 class(*), intent(out), optional :: generic3 class(*), intent(out), optional :: generic4 class(*), intent(out), optional :: generic5 class(*), intent(out), optional :: generic6 class(*), intent(out), optional :: generic7 class(*), intent(out), optional :: generic8 class(*), intent(out), optional :: generic9 class(*), intent(out), optional :: generica class(*), intent(out), optional :: genericb class(*), intent(out), optional :: genericc class(*), intent(out), optional :: genericd class(*), intent(out), optional :: generice class(*), intent(out), optional :: genericf class(*), intent(out), optional :: genericg class(*), intent(out), optional :: generich class(*), intent(out), optional :: generici class(*), intent(out), optional :: genericj class(*), intent(out), optional :: generick private  subroutine set_single(generic0, generic1) NAME set ( 3 f ) - [ M_set ] set scalars from an array ( LICENSE : PD ) SYNOPSIS Syntax : function set ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk ) class (*), intent ( in ) :: g0 class (*), intent ( out ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga class (*), intent ( out ), optional :: gb , gc , gd , ge , gf , gg , gh , gi , gj , gk DESCRIPTION set(3f) sets up to twenty scalars to elements from an array.\nSort of like an equivalence. OPTIONS g0 (:) array to read values from . Can be of type INTEGER or REAL g [ 1 - 9 a - k ] optional values to set to an array element . Can be of type INTEGER or REAL EXAMPLES Sample program: program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_msg , only : set implicit none real ( kind = real32 ) :: a ; namelist / all / a real ( kind = real64 ) :: b ; namelist / all / b real ( kind = real128 ) :: c ; namelist / all / c integer ( kind = int8 ) :: i ; namelist / all / i integer ( kind = int16 ) :: j ; namelist / all / j integer ( kind = int32 ) :: k ; namelist / all / k integer ( kind = int64 ) :: l ; namelist / all / l integer :: iarr ( 7 )=[ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] call set ( iarr , a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set Results: &ALL\n A       =   1.000000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                     7\n /\n &ALL\n A       =   10.00000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                   100\n / AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 class(*), intent(out) :: generic1","tags":"","loc":"interface/set.html"},{"title":"str – M_msg","text":"public interface str Module Procedures private pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, sep) NAME str ( 3 f ) - [ M_msg ] converts up to twenty standard scalar type values to a string ( LICENSE : PD ) SYNOPSIS Syntax : pure function str ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep ) class (*), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class (*), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character ( len =*), intent ( in ), optional :: sep character , len =(:), allocatable :: str DESCRIPTION str(3f) builds a space-separated string from up to twenty scalar values. OPTIONS g [ 0 - 9 a - j ] optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . Optionally , all the generic values can be single - dimensioned arrays . Currently , mixing scalar arguments and array arguments is not supported . sep separator string used between values . Defaults to a space . RETURNS str     description to print EXAMPLES Sample program: program demo_msg use M_msg , only : str implicit none character ( len =:), allocatable :: pr character ( len =:), allocatable :: frmt integer :: biggest pr = str ( ' HUGE ( 3 f ) integers ' , huge ( 0 ), & & ' and real ' , huge ( 0.0 ), ' and double ' , huge ( 0.0 d0 )) write ( * , ' ( a ) ' ) pr pr = str ( ' real : ' , huge ( 0.0 ), 0.0 , 12345.6789 , tiny ( 0.0 ) ) write ( * , ' ( a ) ' ) pr pr = str ( ' doubleprecision : ' , huge ( 0.0 d0 ), 0.0 d0 , 12345.6789 d0 , tiny ( 0.0 d0 ) ) write ( * , ' ( a ) ' ) pr pr = str ( ' complex : ' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , ' ( a ) ' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = str ( ' ( * ( i ' , int ( log10 ( real ( biggest ))), ' :, 1 x )) ' , sep = '' ) write ( * , * ) ' format = ' , frmt ! although it will often work , using str ( 3 f ) ! in an I / O statement is not recommended ! because if an error occurs str ( 3 f ) will try ! to write while part of an I / O statement ! which not all compilers can handle and is currently non - standard write ( * , * ) str ( ' program will now stop ' ) end program demo_msg Output HUGE(3f) integers 2147483647 and real 3.40282347E+38 and double 1.7976931348623157E+308\nreal            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38\ndoubleprecision : 1.7976931348623157E+308 0.0000000000000000 12345.678900000001 2.2250738585072014E-308\ncomplex         : (3.40282347E+38,1.17549435E-38)\n format=(*(i9:,1x))\n program will now stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic0 class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 class(*), intent(in), optional :: generica class(*), intent(in), optional :: genericb class(*), intent(in), optional :: genericc class(*), intent(in), optional :: genericd class(*), intent(in), optional :: generice class(*), intent(in), optional :: genericf class(*), intent(in), optional :: genericg class(*), intent(in), optional :: generich class(*), intent(in), optional :: generici class(*), intent(in), optional :: genericj character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable private pure function msg_one(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(in), optional :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) class(*), intent(in), optional :: generica (:) class(*), intent(in), optional :: genericb (:) class(*), intent(in), optional :: genericc (:) class(*), intent(in), optional :: genericd (:) class(*), intent(in), optional :: generice (:) class(*), intent(in), optional :: genericf (:) class(*), intent(in), optional :: genericg (:) class(*), intent(in), optional :: generich (:) class(*), intent(in), optional :: generici (:) class(*), intent(in), optional :: genericj (:) character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"help_command – M_msg","text":"public  subroutine help_command(help_text, topic_name, position) NAME help_command ( 3 f ) - [ M_help ] uses a specially formatted text array to provide a HELP interface ( LICENSE : PD ) SYNOPSIS Syntax : function help_command ( text_array,topic,position ) DESCRIPTION This routine , when given a CHARACTER array displays the text interactively . The special topics \"manual\" , \"topics\" , and \"search\" are reserved . \"manual\" causes the entire array to be displayed . \"topics\" displays all lines not beginning with a space or three or more equal signs , and \"search\" must be followed by a string to search for in the manual . A line beginning with a non - blank character in column one is a topic A topic with the preceding line beginning with \"===\" is a special topic that will be displayed up to the next line beginning with \"===\" The special topic \"manual\" displays the entire help text The help text is paged based on the values in the position () array . The first value is the current line count on the current page , and the second value is how many lines should be displayed as a page before a paging prompt is produced . POSITION ( 2 ) is typically set to 23. POSITION ( 1 ) can be set to zero , especially if the calling page is not tracking paging itself . Entering a \"q\" at the prompt exits the help text . To see other options enter an \"h\" at the prompt . h # ---------------------------------------------------- # PAGING | f | SPACE b forward or backward one page | | u d redraw up or down one - half page | | r refresh page | | e y | j k refresh page moving up or down one line | # ---------------------------------------------------- # JUMPING | g go to top of manual | | NNN go to line number NNN . Use a sign ( +- ) | | for a relative move . | | . toggle line numbering | # ---------------------------------------------------- # SEARCHING | / STRING advance to next line containing string | | ? STRING search for string above current line | | n N find next occurrence up or down in file | | \\ STRING show all lines with specified string . | | t displays topic lines . | # ---------------------------------------------------- # | w FILENAME write entire user guide to local file | | h display this help | | q quit | # ---------------------------------------------------- # Anything else is ignored . Line count is 25 out of 54 . Page size is 23 ( see \"lines\" ) continue .. A normal topic is displayed until another topic line ( line beginning with a non - blank ) is encountered The help text must begin with a line starting with \"===\" If a line is preceded by an \"===\" line it is considered a section instead of a topic , and all lines between that line and the next line beginning with \"===\" are displayed . OPTIONS help_text  The block of text to treat as the input document\n\ntopic      What topic or section to search for (case sensitive). A blank\n           is equivalent to \"SUMMARY\". There are several reserved names.\n           \"manual\" means the entire help text, and \"topics\" shows only\n           lines not beginning with a blank, and \"search\" does a\n           case-insensitive search for a string.\n\nposition   A small array with two values. The second value is the size\n           of the page to be used between pauses. The first one indicates\n           how many lines on the current page have been displayed. EXAMPLE Sample program: program demo_help_command\nuse M_help, only : help_command\ncharacter(len=:),allocatable :: help_text(:)\ninteger                      :: position(2)\nposition=[0,23]\nhelp_text=[character(len=80) :: &\n'==============================================',&\n'   A sample help text file.                   ',&\n'   Note the first line MUST start with \"===\"  ',&\n'==============================================',&\n'SUMMARY                                       ',&\n'  This is usually a crib sheet                ',&\n'==============================================',&\n'SECTION1                                      ',&\n'topic1                                        ',&\n'   A description of topic 1                   ',&\n'                                              ',&\n'   and any general text you want              ',&\n'                                              ',&\n'topic2  A description of topic 2              ',&\n'topic3                                        ',&\n'   A description of topic 3                   ',&\n'   more  description of topic 3               ',&\n'   and more description of topic 3 a          ',&\n'   and more description of topic 3 b          ',&\n'   and more description of topic 3 c          ',&\n'   and more description of topic 3 d          ',&\n'   and more description of topic 3 e          ',&\n'   and more description of topic 3 f          ',&\n'   and more description of topic 3 g          ',&\n'   and more description of topic 3 h          ',&\n'   and more description of topic 3 i          ',&\n'   and more description of topic 3 j          ',&\n'   and more description of topic 3 k          ',&\n'   and more description of topic 3 l          ',&\n'   and more description of topic 3 m          ',&\n'   and more description of topic 3 n          ',&\n'   and more description of topic 3 o          ',&\n'   and more description of topic 3 p          ',&\n'   and more description of topic 3 q          ',&\n'   and more description of topic 3 r          ',&\n'   and more description of topic 3 s          ',&\n'   and more description of topic 3 t          ',&\n'   and more description of topic 3 u          ',&\n'   and more description of topic 3 v          ',&\n'   and more description of topic 3 w          ',&\n'   and more description of topic 3 x          ',&\n'   and more description of topic 3 y          ',&\n'   and more description of topic 3 z          ',&\n'==============================================',&\n'SECTION2                                      ',&\n'topic4  A description of topic 4              ',&\n'   this is the last part of SECTION1          ',&\n'topic5                                        ',&\n'  This is all about the fifth topic and is    ',&\n'  just displayed as-is. The text cannot start ',&\n'  in column one or it will be seen as the     ',&\n'  beginning of a topic.                       ',&\n'==============================================',&\n'                                              ' ]\n\nwrite(*,*)'>>>>>'\ncall help_command(help_text,'',position)\nwrite(*,*)'>>>>>topic1'\ncall help_command(help_text,'topic1',position)\nwrite(*,*)'>>>>>topics'\ncall help_command(help_text,'topics',position)\nwrite(*,*)'>>>>>manual'\ncall help_command(help_text,'manual',position)\nend program demo_help_command help_text=[character(len=len(help_text)) :: repeat(“=”,80),help_text] Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: help_text (:) character(len=*), intent(in) :: topic_name integer :: position (2) Source Code subroutine help_command ( help_text , topic_name , position ) ! ident_1=\"@(#) M_help help_command(3f) interactively display help text\" character ( len =* ), intent ( in ) :: help_text (:) character ( len =* ), intent ( in ) :: topic_name integer :: position ( 2 ) integer :: end_of_first_word integer :: start_of_topic integer :: ios character ( len = :), allocatable :: topic , old_topic , string logical :: block_topic integer :: i , j , k , jj , ii logical :: numbered character ( len = len ( help_text )) :: last_response integer :: toomany integer , parameter :: max_toomany = 2000 integer :: howbig integer :: old_position howbig = size ( help_text ) toomany = 1 last_response = ' ' numbered = . false . topic = trim ( topic_name ) old_topic = '' old_position = 0 if ( index ( topic , 'search ' ) == 1 ) then topic = 'search' endif INFINITE : do if ( topic == ' ' ) then ! if no topic call journal ( 'Type \"help\" followed by a case-sensitive topic name ...' ) topic = 'SUMMARY' endif select case ( topic ) case ( 'manual' ) ! show all the help text i = 0 do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 3 ) == '===' ) then if ( numbered ) then call journal ( 'sc' , i , ' ' ) else call journal ( ' ' ) endif else if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , help_text ( i )) endif endif if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE if ( i >= howbig ) then do j = 1 , max_toomany call journal ( 'sc' , '[end-of-file] (line' , i , ')' ) position ( 1 ) = position ( 2 ) + 1 if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE if ( i < howbig ) exit enddo if ( i >= howbig ) exit endif enddo exit INFINITE case ( 'topics' ) ! go through all the text showing lines not starting with a a space or equal i = 1 ! display topic starting at start_of_topic do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 1 ) == '   ' ) cycle if ( help_text ( i )( 1 : 3 ) == '===' ) cycle jj = merge ( 0 , 3 , help_text ( i - 1 )( 1 : 3 ) == '===' ) if ( numbered ) then call journal ( 'sc' , i , '>' , repeat ( ' ' , jj ) // help_text ( i )) else call journal ( 'sc' , '>' , repeat ( ' ' , jj ) // help_text ( i )) endif if ( want_to_stop ()) then if ( old_topic /= '' ) then topic = old_topic old_topic = '' i = old_position call pageback ( 1 ) i = max ( 1 , i ) position ( 1 ) = position ( 2 ) + 1 cycle INFINITE endif exit INFINITE endif enddo if ( old_topic /= '' ) then topic = old_topic old_topic = '' i = old_position call pageback ( 1 ) i = max ( 1 , i ) position ( 1 ) = position ( 2 ) + 1 cycle INFINITE endif exit INFINITE case ( 'search' ) ! go through all the text showing lines matching string position ( 1 ) = 0 string = topic_name // '        ' string = trim ( lower ( adjustl ( string ( 8 :)))) i = 0 do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 1 ) /= ' ' . and . help_text ( i )( 1 : 3 ) /= '===' ) then old_topic = help_text ( i ) // ' ' ii = index ( old_topic , ' ' ) old_topic = old_topic (: ii ) endif if ( index ( lower ( help_text ( i )), string ) /= 0 ) then if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , old_topic , '>' , help_text ( i )) endif if ( want_to_stop ()) exit INFINITE if ( i >= howbig ) then do j = 1 , max_toomany call journal ( 'sc' , '[end-of-file] (line' , i , ')' ) position ( 1 ) = position ( 2 ) + 1 if ( want_to_stop ()) exit INFINITE if ( i < howbig ) exit enddo if ( i >= howbig ) exit endif endif enddo exit INFINITE case default ! find the line that starts with the topic start_of_topic = 0 ! find the line to start with by finding a line that starts with the given topic ( ASSUMING FIRST LINE is ===) FINDIT : do j = 1 , len ( help_text ) do i = 2 , howbig ! get first word of lines not starting with a blank if ( help_text ( i )( 1 : 1 ) /= ' ' ) then ! only topic lines start in column one so skip these end_of_first_word = index ( help_text ( i ), ' ' ) - 1 if ( end_of_first_word == 0 ) end_of_first_word = len ( help_text ) ! if line is filled and does not have a blank end_of_first_word = end_of_first_word - j + 1 if ( end_of_first_word <= 0 ) cycle !x!write(*,*)'['//topic(:end_of_first_word)//']['//help_text(i)(:end_of_first_word)//']' if ( topic == help_text ( i )(: end_of_first_word )) then ! find a line that matches topic exit FINDIT endif endif enddo enddo FINDIT start_of_topic = i if ( i == 0 ) then call journal ( '<ERROR> internal error. First line of text must start with \"===\"' ) !!help_text=[character(len=len(help_text)) :: repeat(\"=\",80),help_text] start_of_topic = start_of_topic + 1 endif if ( help_text ( i - 1 )( 1 : 3 ) == '===' ) then ! if the line above the start started with \"===\" it is a block comment block_topic = . true . else block_topic = . false . endif if ( start_of_topic > howbig . or . start_of_topic == 0 ) then call journal ( 'sc' , 'SORRY, No help on ' , topic ) else position ( 1 ) = 0 if ( numbered ) then call journal ( 'sc' , i , help_text ( start_of_topic )) ! show the start line else call journal ( 'sc' , help_text ( start_of_topic )) ! show the start line endif i = start_of_topic + 1 ! display topic starting at start_of_topic do if ( help_text ( i )( 1 : 1 ) /= ' ' . and . . not . block_topic ) then ! stop at next topic if not a block of help exit elseif ( block_topic . and . help_text ( i )( 1 : 3 ) == '===' ) then exit endif if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , help_text ( i )) endif if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE toomany = toomany + 1 if ( toomany >= max_toomany ) exit INFINITE ! to prevent infinite loops in batch mode i = max ( start_of_topic - 1 , i ) i = i + 1 if ( i > howbig ) exit enddo endif exit INFINITE end select if ( want_to_stop ()) exit INFINITE enddo INFINITE contains function want_to_stop () character ( len = len ( help_text )) :: response character ( len = 1 ) :: letter logical :: want_to_stop integer :: j integer :: jj doubleprecision :: val integer :: ierr position ( 1 ) = position ( 1 ) + 1 want_to_stop = . false . PROMPT : do if ( position ( 1 ) > position ( 2 )) then call journal ( 'sc' , 'continue ..' ) read ( stdin , '(a)' , iostat = ios ) response ! read letter to pause from standard input response = adjustl ( response ) letter = response ( 1 : 1 ) select case ( letter ) case ( ' ' , 'f' ) ! next page position ( 1 ) = 0 ! start new page case ( 'b' ) ! back one page call pageback ( 2 ) position ( 1 ) = 0 case ( '0' : '9' ) ! assumed to be a number call a2d ( response , val , ierr ) i = nint ( val ) - 1 i = max ( i , 1 ) i = min ( i , howbig - 1 ) position ( 1 ) = 0 case ( '-' , '+' ) ! assumed to be a number call pageback ( 1 ) call a2d ( response , val , ierr ) i = i + nint ( val ) i = max ( i , 1 ) i = min ( i , howbig - 1 ) position ( 1 ) = 0 case ( 't' ) ! topics old_topic = topic old_position = i topic = 'topics' position ( 1 ) = 0 exit PROMPT !do j=2,howbig !   if(help_text(j)(1:1) == '   ')cycle !   if(help_text(j)(1:3) == '===')cycle !   jj=merge(0,3,help_text(j-1)(1:3) == '===') !   if(numbered)then !      call journal('sc',j,'>',repeat(' ',jj)//help_text(j)) !   else !      call journal('sc','>',repeat(' ',jj)//help_text(j)) !   endif !enddo !call pageback(1) !i=max(1,i) !position(1)=position(2)+1 !cycle PROMPT case ( 'u' ) ! back one-half page call pageback ( 1 ) i = max ( 1 , i - position ( 2 ) / 2 - 1 ) position ( 1 ) = 0 case ( 'e' , 'k' ) ! back one line page call pageback ( 1 ) i = max ( 1 , i - 1 ) position ( 1 ) = 0 case ( 'y' , 'j' ) ! down one line page call pageback ( 1 ) i = max ( 1 , i + 1 ) position ( 1 ) = 0 case ( 'w' ) WRITEFILE : block character ( len = 1000 ) :: errmsg integer :: temp_lun response = adjustl ( response ( 2 :)) if ( response == '' ) response = 'userguide.txt' open ( newunit = temp_lun , file = response , status = 'new' , iostat = ios , iomsg = errmsg ) ! open help file if ( ios == 0 ) then write ( temp_lun , '(a)' , iostat = ios )( trim ( help_text ( k )), k = 1 , howbig ) call journal ( 'sc' , '<INFO> user guide is on file' , response ) close ( unit = temp_lun , iostat = ios ) else call journal ( errmsg ) endif endblock WRITEFILE i = max ( 1 , i - 1 ) case ( 'd' ) ! down one-half page i = min ( howbig - 1 , i - position ( 2 ) / 2 - 1 ) position ( 1 ) = 0 case ( 'r' ) ! repaint page call pageback ( 1 ) position ( 1 ) = 0 case ( '/' , 'n' ) ! find string below j = i ! hold if ( letter == 'n' ) response = last_response if ( response ( 2 :) == '' ) response = last_response i = i + 1 do if ( index ( lower ( help_text ( i )), trim ( response ( 2 :))) /= 0 ) then i = max ( 1 , i - 1 ) exit else i = i + 1 endif if ( i > howbig ) exit enddo if ( i > howbig ) i = j position ( 1 ) = 0 last_response = response case ( '\\') ! find string response=lower(adjustl(response(2:))) if(response == ' ')response=last_response jj=len_trim(response) do j=1,howbig if(index(lower(help_text(j)),response(:jj)) /= 0)then call journal(' sc ',j,help_text(j)) endif enddo i=i-1 call pageback(1) last_response=' / '//response case(' ? ',' N ',' p ')                                            ! find string above j=i ! hold if(letter == ' N '.or.letter == ' ')response=last_response if(response(2:) == '')response=last_response i=i-1 do if(index(lower(help_text(i)),trim(response(2:))) /= 0)then exit else i=i-1 endif if(i <= 1) then i=j exit endif enddo call pageback(1) position(1) = 0 last_response=response case(' g ')                                            ! repaint page i=1 position(1) = 0 case(' . ')                                            ! help position(1) = 0 numbered=.not.numbered case(' h ')                                            ! help call journal(' sc ',' # ---------------------------------------------------- # PAGING ') call journal(' sc ',' | f | SPACE b forward or backward one page | ') call journal(' sc ',' | u d redraw up or down one - half page | ') call journal(' sc ',' | r refresh page | ') call journal(' sc ',' | e y | j k refresh page moving up or down one line | ') call journal(' sc ',' # ---------------------------------------------------- # JUMPING ') call journal(' sc ',' | g go to top of manual | ') call journal(' sc ',' | NNN go to line number NNN . Use a sign ( +- ) | ') call journal(' sc ',' | for a relative move . | ') call journal(' sc ',' | . toggle line numbering | ') call journal(' sc ',' # ---------------------------------------------------- # SEARCHING ') call journal(' sc ',' | / STRING advance to next line containing string | ') call journal(' sc ',' | ? STRING search for string above current line | ') call journal(' sc ',' | n N find next occurrence up or down in file | ') call journal(' sc ',' | \\ STRING show all lines with specified string . | ') call journal(' sc ',' | t displays topic lines . | ') call journal(' sc ',' # ---------------------------------------------------- # ') call journal(' sc ',' | w FILENAME write entire user guide to local file | ') call journal(' sc ',' | h display this help | ') call journal(' sc ',' | q quit | ') call journal(' sc ',' # ---------------------------------------------------- # ') call journal(' sc ',' Anything else is ignored . ') call journal(' sc ',' Line count is ',i,' out of ',howbig,' . Page size is ',position(2),' ( see \"lines\" ) ') cycle case(' q ') position(1) = -1 want_to_stop=.true. case default call pageback(2) call journal(' sc ',' unknown option -- enter \"h\" for assistance or \"q\" to quit ' ) end select endif exit enddo PROMPT end function want_to_stop subroutine pageback ( loops ) integer , intent ( in ) :: loops integer :: j do j = 1 , loops i = max ( 1 , i - position ( 2 ) - 1 ) enddo end subroutine pageback end subroutine help_command","tags":"","loc":"proc/help_command.html"},{"title":"M_demo – M_msg","text":"regular routines\nregular routines\nspecial name for use with test_suite(1bash).\n regular routines\nunit test Subroutines public  subroutine one () Arguments None public  subroutine test_suite_M_demo () Arguments None public  subroutine two () Arguments None","tags":"","loc":"module/m_demo.html"},{"title":"M_journal – M_msg","text":"NAME M_journal(3fm) - [M_journal::INTRO] write program messages to stdout and/or\n a log file\n (LICENSE:PD) SYNOPSIS use, M_journal , only : journal DESCRIPTION For interactive programs in particular it is useful if all messages go thru the JOURNAL ( 3 f ) routine . This makes it easy to write messages to a log file as well as standard output ; to toggle time prefixes on and off ; to turn on and off debug - mode messages ; control output paging and create replayable input journals . The primary use of JOURNAL ( 3 f ) is to create journal files for interactive programs that can be replayed and / or be used to verify program executions . Typically , you would echo what the user typed to the trail file as - is , and write output you write to stdout as comments to the trail file so that the trail file can easily be read back in ( by ignoring comments ). So usually things that are read from user input are using output with WHERE = 'T' and output that usually goes to stdout is written with WHERE = ' SC ' in the JOURNAL ( 3 f ) call . > : > : > character ( len = 256 ) userline , output > call journal ( 'O' , ' my_trail_file ' ) ! open trail file > : > : > do > read ( * , ' ( a ) ' , iostat = ios ) userline ! read user input > if ( ios /= 0 ) exit > ! echo user input to trail file > call journal ( 'T' , userline ) > ! assume user input causes values i1 , i2 , and i3 to be calculated > write ( output , ' ( i0 , 1 x , i0 , 1 x ) ' ) i1 , i2 , i3 ! build an output line > ! write output to stdout and as comment to trail file > call journal ( output ) > ! or you can specify the WHERE parameter and up to ten scalar values > call journal ( ' SC ',' i1 = ' , i1 , ' i2 = ' , i2 , ' i3 = ' , i3 ) > enddo In this example an output line was built with an internal write ; but calls to journal ( 3 f ) with numeric values with and without advancing I / O turned on are often used for simpler output : I = 10 R = 20.3 ! write to stdout and trail file without advancing I / O call journal ( ' + SC ',' I = ' , i ) call journal ( ' SC ',' AND R = ' , r ) writes to the trail file are ignored unless a trail file was opened with CALL JOURNAL ( 'O' , filename ) So that routines that do their output via JOURNAL ( 3 f ) can be used with and without programs generating trail files . That is , destinations 'T' and 'C' are ignored unless a trail file has been requested . With no parameters , the trail file is flushed . EXAMPLES The man ( 1 ) page for journal ( 3 f ) describes all the options for the WHERE field . In addition to being used to generate a journal , the routine can be used for producing optional debug messages and timing information . Sample program for debug messages : program demo_journal !! showing creating debug messages use M_journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , ' * demo * DEBUG MESSAGE 001 IGNORED ' ) !! turn on debug messages call journal ( '>' , ' debug on ' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , ' * demo * DEBUG MESSAGE 002 ON STDOUT ' ) !! open trail file call journal ( 'O' , ' mytrail . txt ' ) !! debug messages now go to the trail file call journal ( 'D' , ' * demo * DEBUG MESSAGE 003 TO TRAIL ' ) !! close trail file so messages go to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , ' * demo * DEBUG MESSAGE 004 TO STDOUT ' ) call journal ( '<' , ' debug off ' ) !! back to no output from the next message call journal ( 'D' , ' * demo * DEBUG MESSAGE 005 IGNORED ' ) end program demo_journal Sample program for trail messages with optional timing information: program testit use M_journal , only : journal implicit none call journal ( ' a single string A - should be on S ' ) ! add time prefix to output call journal ( '%' , ' % Y -% M -% DT % h : % m : % s . % x % u : % b ' ) call journal ( ' a single string B - should be on S with prefix ' ) call journal ( '%' , ' CPU_TIME : % c : CALLS : % C : % b ' ) ! change time prefix call journal ( ' a single string B - 1 - should be on S with prefix ' ) call journal ( ' a single string B - 2 - should be on S with prefix ' ) call journal ( ' a single string B - 3 - should be on S with prefix ' ) ! Other useful time formats : ! % E -- Unix Epoch time ! % e -- integer value of Unix Epoch time ! % C -- number of times this format is used ! % c -- CPU_time ( 3 f ) output ! % S -- seconds since last use of this format ! % k -- CPU time in seconds from system_clock call journal ( '%' , '' ) ! turn off time prefix ! call journal ( ' a single string C - should be on S ' ) ! call journal ( 'O' , ' aaa . out ' ) ! turn on trail file call journal ( ' a single string D - should be on SC ' ) call journal ( ' a single string E - should be on SC ' ) call journal ( ' a single string F - should be on SC ' ) call journal ( 'O' , '' ) ! turn off trail file ! call journal ( ' a single string G - should be on S ' ) call journal ( ' a single string H - should be on S ' ) call journal ( ' a single string I - should be on S ' ) ! build one line of output with intrinsic scalar values added call journal ( ' + sc ',' APPEND : ' ) call journal ( ' + sc ',' integer ' , 1234 ) call journal ( ' + sc ',' and real ' , 1234.5678 ) call journal ( ' + sc ',' and double ' , 1234567890.123456 d0 ) call journal ( ' + sc ',' and logical ' , . true .) call journal ( ' sc ',' ' ) ! end program testit AUTHOR John S. Urban LICENSE Public Domain NAME journal ( 3 f ) - [ M_journal ] provides public message routine , no paging or graphic mode change ( LICENSE : PD ) SYNOPSIS subroutine journal([where,],[VALUE(s)])\n\n character(len=*),intent(in) :: where\n character(len=*)|real|integer|doubleprecision|complex,optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9 WRITE MESSAGES\n    basic messages call journal ( where ,[ VALUE ( S ) ] ) call journal ( message ) # a shortcut for \"call journal('sc',message)\" : OPEN OR CLOSE TRAIL FILE\n    trail file call journal('O',trailfile_name) # open trail file\n   call journal('O','')             # close trail file SET OUTPUT TIME PREFIX\n    set the function display format for timestamps. See the NOW(3f)\n    procedure for allowable timestamp macros call journal('%',time_stamp_prefix_specification) MODES Turn on/off writing DEBUG messages to trail file\n\n   call journal('>','debug on') # turn on debug mode\n   call journal('<','debug off') # turn off debug mode ASSIGN STDOUT TO AN ALTERNATE FILE\n    change stdout to iunit and open filename; or close unit and go back to stdout if filename=’‘ call journal(iunit,filename)\n\nchange stdout to iunit to use a file already open\n\n   call journal(iunit) DESCRIPTION If a user procedure is used for outputting messages instead of calling WRITE ( 3 f ) it is easy to provide control of when messages are printed ( ie . a \"verbose\" mode , or \"quite\" mode ) , creating files to replay program execution , duplicating output , ... OPTIONS WHERE  indicates where messages are written. A combination of the\n          following characters can be used… Usually one of these to write to the standard output files ... S write to stdout or iounit set with journal ( unit ) or journal ( unit , filename ) . E write to stderr And one of these to write to trail file ( ignore if no trail file defined ) ... C write to trail file as a comment ( if file is open ) Writing output \"as a comment\" means it is preceded by a pound ( # ) character . T write to trail file ( if file is open ) Usually used by itself D write to trail file as a comment with \"DEBUG:\" prefix in front of message ( if file is open ) if debug mode is on . Write to stdout if no trail file and debug mode is on . Modifier for S | E | C | T | D specifiers + subsequent files are written to with advance = 'no' . Position is important . '+sc' does an advance = 'no' on both files , 's+c' only does the advance = 'no' for the trail file . Mode changing options used by themselves : > turn off debug messages < turn on debug messages O open trail file using value of \"message\" parameter or close trail file if no filename or a blank filename . A Auxiliary programs that also want to write to the current log file ( a2b , z2a , ... ) call this routine to see if there is a trail file being generated and then add to it so that a program like ush ( 1 f ) can call the auxiliary programs and still just generate one log file , but if the auxiliary program is used as a stand - alone program no trail is generated . VALUES(S)   message to write to stdout, stderr, and the trail file.\n               a numeric or character value to optionally be appended\n               to the message. Up to nine values are allowed. The WHERE\n               field is required if values are added.\n   FILENAME    when WHERE=”O” to turn the trail file on or off, the “message”\n               field becomes the trail filename to open. If blank, writing\n               to the trail file is turned off.\n   TFORMAT     when WHERE=”%” the message is treated as a time format\n               specification as described under now(3f). EXAMPLE Sample program: program demo_journal\nuse M_journal, only : journal\n!! BASIC USAGE\ncall journal('write to standard output as-is, and trail file as a comment if open')\n! since we have not opened a trail file yet, only stdout will display output\ncall journal('c','ignored, as trail file is not open')\n! now open trail file \"trail\"\ncall journal('o','trail')\ncall journal('sc','same thing except now trail file is open')\n! only write to trail file if open\ncall journal('c','not ignored, as trail file is open. Written with # suffix')\ncall journal('t','not ignored, as trail file is open. Written as-is')\n! turn off trail file\ncall journal('o','')\nend program demo_journal Adding intrinsic scalar values to the message: program test_journal use M_journal , only : journal implicit none call journal ( 'S' , ' This is a test with no optional value ' ) call journal ( 'S' , ' This is a test with a logical value ' ,. true .) call journal ( 'S' , ' This is a test with a double value ' , 1234567890.123456789 d0 ) call journal ( 'S' , ' This is a test with a real value ' , 1234567890.123456789 ) call journal ( 'S' , ' This is a test with an integer value ' , 1234567890 ) call journal ( ' STDC ',' This is a test using STDC ' , 1234567890 ) call journal ( ' stdc ',' This is a test using stdc ' , 1234567890 ) call journal ( 'o' , ' journal . txt ' ) ! open trail file call journal ( 'S' , 1 , 12.34 , 56789.111111111 d0 ,. false ., ' a bunch of values ' ) ! the combinations that make sense call journal ( ' st ',' stdout and trail ' ) call journal ( 's' , ' stdout only ' ) call journal ( 't' , ' trail only ' ) call journal ( ' sc ',' stdout and trail_comment ' ) call journal ( 'c' , ' trail_comment only ' ) call journal ( 'd' , ' debug only ' ) call journal ( 'e' , ' stderr only ' ) call journal ( 'o' , ' ' ) ! closing trail file end program test_journal program testit ! this is a utility program that calls the module routines . It is typically built using ccall ( 1 ). use M_journal , only : journal character ( len =:), allocatable :: time_stamp_prefix call journal ( 's' , ' -------------------------------------------------------------------------------- ' ) call journal ( 's' , ' SIMPLE WRITES ' ) call one () call two () call journal ( ' sc ',' called ONE () and TWO () but did not generate a log file ' ) call journal ( 's' , ' -------------------------------------------------------------------------------- ' ) call journal ( 's' , ' SIMPLE WRITES WITH LOG FILE ' ) call journal ( 'o' , ' journal . txt ' ) ! open trail file call one () call two () call journal ( ' sc ',' called ONE () and TWO () and generated log file journal . txt ' ) call journal ( ' ',' journal . txt ' ) ! close trail file call journal ( 's' , ' -------------------------------------------------------------------------------- ' ) call journal ( 's' , ' SIMPLE WRITES WITH TIMING INFORMATION ' ) time_stamp_prefix = ' CPU_TIME = % c : CALLS = % C : SINCE = % S : % b ' ! change time prefix call journal ( '%' , time_stamp_prefix ) ! set a time prefix in front of messages call journal ( 'o' , ' timed . txt ' ) ! open trail file call one () call two () call journal ( ' sc ',' called ONE () and TWO () and generate log file timed . txt ' ) call journal ( ' ',' timed . txt ' ) ! close trail file call journal ( '%' , '' ) ! turn off time prefix call journal ( 'o' , ' timed . txt ' ) ! open trail file call journal ( 's' , ' -------------------------------------------------------------------------------- ' ) contains subroutine two () call journal ( ' Entered subroutine two ' ) call journal ( ' Exited subroutine two ' ) end subroutine two subroutine one () call journal ( ' Entered subroutine one ' ) sum = - HUGE ( 1.0 ) do i = 1 , 10000000 sum = sum + sqrt ( real ( i )) enddo write ( * , * ) ' SUM = ' , sum call journal ( ' Exited subroutine one ' ) end subroutine one end program testit AUTHOR John S. Urban LICENSE Public Domain Uses M_msg iso_fortran_env Interfaces public        interface journal private  subroutine flush_trail() Arguments None private  subroutine write_message_only(message) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message private  subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep) NAME where_write_message_all ( 3 f ) - [ M_journal ] converts any standard scalar type to a string and calls journal ( 3 f ) ( LICENSE : PD ) SYNOPSIS subroutine where_write_message_all(where,g0,g1,g2g3,g4,g5,g6,g7,g8,g9,sep) character(len=*),intent(in)   :: where\n class(*),intent(in)           :: g0\n class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9\n character,intent(in),optional :: sep DESCRIPTION where_write_message_all(3f) builds and writes a space-separated string from up to nine scalar values. OPTIONS where string designating where to write message , as with journal ( 3 f ) g0 value to print . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . g [ 1 - 9 ] optional additional values to print the value of after g0 . sep separator to add between values . Default is a space RETURNS where_write_message_all  description to print EXAMPLES Sample program: program demo_wm_all use M_journal , only : where_write_message_all implicit none end program program demo_wm_all AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: where class(*), intent(in) :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 character(len=1), intent(in), optional :: sep private  subroutine set_stdout_lun(iounit) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iounit","tags":"","loc":"module/m_journal.html"},{"title":"M_verify – M_msg","text":"NAME M_verify(3fm) - [M_verify::INTRO] a collection of Fortran routines for\n                supporting code development by providing error\n                processing, debugging procedures and unit testing.\n                (LICENSE:PD) SYNOPSIS Module procedures use M_verify, only : unit_check, unit_check_start, unit_check_done, unit_check_stop\nuse M_verify, only : unit_check_good, unit_check_bad\nuse M_verify, only : unit_check_msg\nuse M_verify, only : debug\nuse M_verify, only : fstop\nuse M_verify, only : assert Module values use M_verify, only : unit_check_limit, unit_check_keep_going\nuse M_verify, only : unit_check_command QUOTE Do not let your victories go to your head , nor let your failures go to your heart . DESCRIPTION The M_verify ( 3 fm ) Fortran module provides procedures and variables useful for providing error processing , debugging capabilities , and unit testing . o allows for a user - defined command to be called to collect results or mail failure alerts , ... o supports easily composing a message from up to nine scalar intrinsic values and different message levels o allows stopping on first failure or continuing o provides for a non - zero exit code if any tests fail SET MODES unit_check_keep_going logical variable that can be used to turn off program termination on errors . unit_check_level An integer that can be used to specify different debug levels unit_check_command name of command to execute . Defaults to the name \"\" . UNIT TESTS unit_check_start ( 3 f ) start tests of a procedure and optionally call command NAME start ... unit_check ( 3 f ) if expression is false optionally call command NAME bad and stop program ( by default ) unit_check_done ( 3 f ) call command NAME good if no failures ; else call command NAME bad unit_check_stop(3f)     stop program with exit value of 0 if no failures\n                           else with an exit value of 1 unit_check_good ( 3 f ) call command command NAME good unit_check_bad ( 3 f ) call command command NAME bad and stop program by default unit_check_msg ( 3 f ) write message BASIC DEBUGGING fstop ( 3 f ) calls 'STOP VALUE' passing in a value ( 1 - 32 ), with optional message pdec ( 3 f ) write ASCII Decimal Equivalent ( ADE ) numbers vertically beneath string debug logical variable that can be tested by routines as a flag to process debug statements . For unit testing , the existence of a command called \"goodbad\" is initially assumed . This is generally a script that makes entries for each unit in an SQLite data file which is then used to create CSV and HTML reports on the status of each unit . A sample goodbad ( 1 ) command written in the bash ( 1 ) shell and using the sqlite3 ( 1 ) command should be included in this distribution as an example . The flexibility introduced by calling an external script or program is that The goodbad ( 1 ) command can be changed as desired to write CSV files or simple logs or to notify developers with e - mail as desired . RELATED FUNCTIONS The routines in M_verify ( 3 f ) are often combined with the M_hashkeys ( 3 fm ) routines and various math and statistical routines to quickly create unit tests . Comparisons of real values can be done with a tolerance with M_Compare_Float_Numbers ( 3 fm ), for example . The intrinsics ANY ( 3 f ) and ALL ( 3 f ) are particularly useful in calls to unit_check ( 3 f ) . EXAMPLES Sample program !! program demo_unit_tests module M_demo private public one !! regular routines public two !! regular routines public test_suite_M_demo !! special name for use with test_suite ( 1 bash ). contains !! regular routines subroutine one () end subroutine one subroutine two () end subroutine two !! unit test subroutine test_suite_M_demo use M_verify , only : unit_check_start , unit_check use M_verify , only : unit_check_good , unit_check_bad , unit_check_done use M_verify , only : unit_check_msg , unit_check_stop implicit none integer :: i , j , k integer , allocatable :: array (:) integer :: arr ( 4 )=[ 21 , 51 , 14 , 45 ] integer :: a = 21 , b = 51 , c = 14 , d = 45 ! TEST - DRIVEN DEVELOPMENT ! optional set - up perform initialization operations common to all tests within a module i = 1 j = 2 k = 3 array =[ 10 , 20 , 30 , 40 , 50 , 60 , 70 ] call test_one () call test_two () ! optional tear - down perform finalization operations common to all tests within a module contains subroutine test_one () ! register an entry for specified name ( \"one\" ) in database with status of zero ( 0 ) call unit_check_start ( ' one ' ) ! if mask test fails , can ! * produce a SUCCESS : or FAIL : message and stop program ! * change database status for specified entry to - 1 and stop program , else continue ! * produce a SUCCESS : or FAIL : message and keep going ! * produce a FAIL : message if test fails but no SUCCESS : message if test passes call unit_check ( ' one ' , i > 0 , msg = ' I > 0 ' ) ! using ANY ( 3 f ) and ALL ( 3 f ) call unit_check ( ' one ' , all ([ i , j , k ] > 0 ), ' testing if everyone greater than zero ' ) ! display message built of scalars as well call unit_check ( ' one ' , all (. not .[ i , j , k ] == 4 ), ' for set ' , i , j , k , ' testing if no one is equal to four ' ) ! for tests that are hard to reduce to a logical test just call unit_check_bad ( 3 f ) if fail if ( i + j + k < 1 ) then call unit_check_bad ( ' one ' ) endif call unit_check_done ( ' one ',' checks on \"one\" ended ' ) end subroutine test_one subroutine test_two ! use of all ( 3 f ), any ( 3 f ), merge ( 3 f ) can be useful ! if you know what these would produce ! write ( * , * )[ 'A' , 'X' , 'X' , 'X' , 'X' , 'B' ] == 'B' ! this would return an array , the last element having the value T , else F ! write ( * , * ) all ([ 'A' , 'X' , 'X' , 'X' , 'X' , 'X' ] == 'X' ) ! this would return F ! write ( * , * ) any ([ 'A' , 'X' , 'X' , 'X' , 'X' , 'X' ] == 'B' ) ! this would return F ! write ( * , * ) any ([ 'A' , 'X' , 'X' , 'X' , 'X' , 'B' ] == 'B' ) ! this would return T ! write ( * , * ). not . all ( array < 100 ) ! write ( * , * ) all ( array < 100 ) ! write ( * , * ) all ([ a , b , c , d ] == [ 21 , 51 , 14 , 45 ]) ! compare a list . This would return T ! write ( * , * ) all ( arr == [ 21 , 51 , 14 , 45 ]) ! compare an array . This would return T ! you know how valuable ANY ( 3 f ) and ALL ( 3 f ) will be call unit_check_start ( ' two ',' check on \"two\" passed ' ) call unit_check ( ' two ' , 1 > 0 . and . abs ( 10.10000 - 10.10001 ) < 0.0001 , msg = ' two looks good ' ) call unit_check_done ( ' two ',' checks on \"two\" ended ' ) end subroutine test_two end subroutine test_suite_M_demo end module M_demo program demo_M_verify use M_demo , only : test_suite_M_demo use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level unit_check_command = '' unit_check_keep_going =. true . unit_check_level = 0 call test_suite_M_demo end program demo_M_verify Expected output: unit_check:       one                  SUCCESS:I > 0\n unit_check:       one                  SUCCESS:testing if everyone greater than zero\n unit_check:       one                  SUCCESS:for set 1 2 3 testing if no one is equal to four\n unit_check_done:  one                  PASSED   GOOD:3  BAD:0\n\n unit_check:       two                  SUCCESS:two looks good\n unit_check_done:  two                  PASSED   GOOD:1  BAD:0 AUTHOR John S. Urban LICENSE Public Domain Uses M_msg iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: EXIT_FAILURE = 1 integer, public, parameter :: EXIT_SUCCESS = 0 logical, public, save :: debug = .false. integer, public, save :: io_debug = ERROR_UNIT logical, public, save :: no_news_is_good_news = .false. integer, public, parameter :: realtime = kind(0.0d0) character(len=4096), public :: unit_check_command = '' logical, public, save :: unit_check_keep_going = .false. integer, public, save :: unit_check_level = 0 integer, public, save :: unit_check_lun = ERROR_UNIT character(len=20), public, save :: unit_check_prefix = '' Functions public  function almost (x, y, digits, verbose) sample: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digits logical, intent(in), optional :: verbose Return Value logical public impure elemental function in_margin (expected_value, measured_value, allowed_margin) in_margin(3f) - [M_verify] check if two reals are approximately equal using a relative margin Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: expected_value class(*), intent(in) :: measured_value class(*), intent(in) :: allowed_margin Return Value logical public  function round (val, idigits0) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: val integer, intent(in) :: idigits0 Return Value real(kind=dp) public pure elemental function round_to_power (val, n) Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: n Return Value real public pure elemental function significant (val, digits, round) significant(3f) - [M_verify] round val to specified number of significant digits Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: val integer, intent(in) :: digits character(len=*), intent(in), optional :: round Return Value real Subroutines public  subroutine accdig (x, y, digi0, acurcy, ind) Example program: Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: x real, intent(in) :: y real, intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind public  subroutine assert (filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename integer, intent(in) :: linen logical, intent(in) :: expr class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 public  subroutine dp_accdig (x, y, digi0, acurcy, ind) Example program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: x class(*), intent(in) :: y class(*), intent(in) :: digi0 real, intent(out) :: acurcy integer, intent(out) :: ind public  subroutine fstop (ierr, stdout, stderr) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ierr character(len=*), intent(in), optional :: stdout character(len=*), intent(in), optional :: stderr public  subroutine pdec (string) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string public  subroutine stderr (msg, gen0, gen1, gen2, gen3, gen4, gen5, gen6, gen7, gen8, gen9) Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: msg class(*), intent(in), optional :: gen0 class(*), intent(in), optional :: gen1 class(*), intent(in), optional :: gen2 class(*), intent(in), optional :: gen3 class(*), intent(in), optional :: gen4 class(*), intent(in), optional :: gen5 class(*), intent(in), optional :: gen6 class(*), intent(in), optional :: gen7 class(*), intent(in), optional :: gen8 class(*), intent(in), optional :: gen9 public  subroutine unit_check (name, logical_expression, msg, msg1, msg2, msg3, msg4, msg5, msg6, msg7, msg8, msg9) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name logical, intent(in) :: logical_expression class(*), intent(in), optional :: msg class(*), intent(in), optional :: msg1 class(*), intent(in), optional :: msg2 class(*), intent(in), optional :: msg3 class(*), intent(in), optional :: msg4 class(*), intent(in), optional :: msg5 class(*), intent(in), optional :: msg6 class(*), intent(in), optional :: msg7 class(*), intent(in), optional :: msg8 class(*), intent(in), optional :: msg9 public  subroutine unit_check_bad (name, opts, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg public  subroutine unit_check_done (name, opts, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg public  subroutine unit_check_good (name, opts, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: opts character(len=*), intent(in), optional :: msg public  subroutine unit_check_msg (name, g1, g2, g3, g4, g5, g6, g7, g8, g9) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 public  subroutine unit_check_start (name, options, msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: options character(len=*), intent(in), optional :: msg public  subroutine unit_check_stop (msg) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: msg","tags":"","loc":"module/m_verify.html"},{"title":"M_msg – M_msg","text":"public :: a,i,f,g Uses iso_fortran_env Interfaces public        interface set private  subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(out), optional :: generic1 class(*), intent(out), optional :: generic2 class(*), intent(out), optional :: generic3 class(*), intent(out), optional :: generic4 class(*), intent(out), optional :: generic5 class(*), intent(out), optional :: generic6 class(*), intent(out), optional :: generic7 class(*), intent(out), optional :: generic8 class(*), intent(out), optional :: generic9 class(*), intent(out), optional :: generica class(*), intent(out), optional :: genericb class(*), intent(out), optional :: genericc class(*), intent(out), optional :: genericd class(*), intent(out), optional :: generice class(*), intent(out), optional :: genericf class(*), intent(out), optional :: genericg class(*), intent(out), optional :: generich class(*), intent(out), optional :: generici class(*), intent(out), optional :: genericj class(*), intent(out), optional :: generick private  subroutine set_single(generic0, generic1) NAME set ( 3 f ) - [ M_set ] set scalars from an array ( LICENSE : PD ) SYNOPSIS Syntax : function set ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk ) class (*), intent ( in ) :: g0 class (*), intent ( out ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga class (*), intent ( out ), optional :: gb , gc , gd , ge , gf , gg , gh , gi , gj , gk DESCRIPTION set(3f) sets up to twenty scalars to elements from an array.\nSort of like an equivalence. OPTIONS g0 (:) array to read values from . Can be of type INTEGER or REAL g [ 1 - 9 a - k ] optional values to set to an array element . Can be of type INTEGER or REAL EXAMPLES Sample program: program demo_set use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use M_msg , only : set implicit none real ( kind = real32 ) :: a ; namelist / all / a real ( kind = real64 ) :: b ; namelist / all / b real ( kind = real128 ) :: c ; namelist / all / c integer ( kind = int8 ) :: i ; namelist / all / i integer ( kind = int16 ) :: j ; namelist / all / j integer ( kind = int32 ) :: k ; namelist / all / k integer ( kind = int64 ) :: l ; namelist / all / l integer :: iarr ( 7 )=[ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] call set ( iarr , a , b , c , i , j , k , l ) write ( * , nml = all ) call set ( 10 , a ) call set ( 100 , l ) write ( * , nml = all ) end program demo_set Results: &ALL\n A       =   1.000000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                     7\n /\n &ALL\n A       =   10.00000    ,\n B       =   2.00000000000000     ,\n C       =   3.00000000000000000000000000000000      ,\n I       =    4,\n J       =      5,\n K       =           6,\n L       =                   100\n / AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 class(*), intent(out) :: generic1 public        interface str private pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, sep) NAME str ( 3 f ) - [ M_msg ] converts up to twenty standard scalar type values to a string ( LICENSE : PD ) SYNOPSIS Syntax : pure function str ( g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep ) class (*), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class (*), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj character ( len =*), intent ( in ), optional :: sep character , len =(:), allocatable :: str DESCRIPTION str(3f) builds a space-separated string from up to twenty scalar values. OPTIONS g [ 0 - 9 a - j ] optional value to print the value of after the message . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER . Optionally , all the generic values can be single - dimensioned arrays . Currently , mixing scalar arguments and array arguments is not supported . sep separator string used between values . Defaults to a space . RETURNS str     description to print EXAMPLES Sample program: program demo_msg use M_msg , only : str implicit none character ( len =:), allocatable :: pr character ( len =:), allocatable :: frmt integer :: biggest pr = str ( ' HUGE ( 3 f ) integers ' , huge ( 0 ), & & ' and real ' , huge ( 0.0 ), ' and double ' , huge ( 0.0 d0 )) write ( * , ' ( a ) ' ) pr pr = str ( ' real : ' , huge ( 0.0 ), 0.0 , 12345.6789 , tiny ( 0.0 ) ) write ( * , ' ( a ) ' ) pr pr = str ( ' doubleprecision : ' , huge ( 0.0 d0 ), 0.0 d0 , 12345.6789 d0 , tiny ( 0.0 d0 ) ) write ( * , ' ( a ) ' ) pr pr = str ( ' complex : ' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , ' ( a ) ' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = str ( ' ( * ( i ' , int ( log10 ( real ( biggest ))), ' :, 1 x )) ' , sep = '' ) write ( * , * ) ' format = ' , frmt ! although it will often work , using str ( 3 f ) ! in an I / O statement is not recommended ! because if an error occurs str ( 3 f ) will try ! to write while part of an I / O statement ! which not all compilers can handle and is currently non - standard write ( * , * ) str ( ' program will now stop ' ) end program demo_msg Output HUGE(3f) integers 2147483647 and real 3.40282347E+38 and double 1.7976931348623157E+308\nreal            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38\ndoubleprecision : 1.7976931348623157E+308 0.0000000000000000 12345.678900000001 2.2250738585072014E-308\ncomplex         : (3.40282347E+38,1.17549435E-38)\n format=(*(i9:,1x))\n program will now stop AUTHOR John S. Urban LICENSE Public Domain Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: generic0 class(*), intent(in), optional :: generic1 class(*), intent(in), optional :: generic2 class(*), intent(in), optional :: generic3 class(*), intent(in), optional :: generic4 class(*), intent(in), optional :: generic5 class(*), intent(in), optional :: generic6 class(*), intent(in), optional :: generic7 class(*), intent(in), optional :: generic8 class(*), intent(in), optional :: generic9 class(*), intent(in), optional :: generica class(*), intent(in), optional :: genericb class(*), intent(in), optional :: genericc class(*), intent(in), optional :: genericd class(*), intent(in), optional :: generice class(*), intent(in), optional :: genericf class(*), intent(in), optional :: genericg class(*), intent(in), optional :: generich class(*), intent(in), optional :: generici class(*), intent(in), optional :: genericj character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable private pure function msg_one(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, sep) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic0 (:) class(*), intent(in), optional :: generic1 (:) class(*), intent(in), optional :: generic2 (:) class(*), intent(in), optional :: generic3 (:) class(*), intent(in), optional :: generic4 (:) class(*), intent(in), optional :: generic5 (:) class(*), intent(in), optional :: generic6 (:) class(*), intent(in), optional :: generic7 (:) class(*), intent(in), optional :: generic8 (:) class(*), intent(in), optional :: generic9 (:) class(*), intent(in), optional :: generica (:) class(*), intent(in), optional :: genericb (:) class(*), intent(in), optional :: genericc (:) class(*), intent(in), optional :: genericd (:) class(*), intent(in), optional :: generice (:) class(*), intent(in), optional :: genericf (:) class(*), intent(in), optional :: genericg (:) class(*), intent(in), optional :: generich (:) class(*), intent(in), optional :: generici (:) class(*), intent(in), optional :: genericj (:) character(len=*), intent(in), optional :: sep Return Value character(len=:), allocatable Functions public recursive function fmt (generic, format) result(line) Sample program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Subroutines public  subroutine stderr (g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj) Sample program: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj public  subroutine wrt (luns, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat) Sample program: Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: luns (:) class(*), intent(in), optional :: g0 class(*), intent(in), optional :: g1 class(*), intent(in), optional :: g2 class(*), intent(in), optional :: g3 class(*), intent(in), optional :: g4 class(*), intent(in), optional :: g5 class(*), intent(in), optional :: g6 class(*), intent(in), optional :: g7 class(*), intent(in), optional :: g8 class(*), intent(in), optional :: g9 class(*), intent(in), optional :: ga class(*), intent(in), optional :: gb class(*), intent(in), optional :: gc class(*), intent(in), optional :: gd class(*), intent(in), optional :: ge class(*), intent(in), optional :: gf class(*), intent(in), optional :: gg class(*), intent(in), optional :: gh class(*), intent(in), optional :: gi class(*), intent(in), optional :: gj integer, intent(out), optional :: iostat","tags":"","loc":"module/m_msg.html"},{"title":"M_help – M_msg","text":"Uses M_journal iso_fortran_env Subroutines public  subroutine help_command (help_text, topic_name, position) Sample program: Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: help_text (:) character(len=*), intent(in) :: topic_name integer :: position (2)","tags":"","loc":"module/m_help.html"},{"title":"demo_accdig – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial real :: a real :: acurcy real :: acurcy1 real :: acurcy2 real :: b integer :: digi integer :: i10 integer :: i20 integer :: i30 integer :: ind integer :: ind1 integer :: ind2 real :: vals (9) Source Code program demo_accdig ! fortran 90 example use M_verify , only : accdig implicit none integer :: digi integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 real :: a , b real :: vals ( 9 ) data vals / & & 1.234680 , 1.2345378 , 2.2234568 , 1.2345678 , & & 1.2345679 , - 1.2345678 , 7 6.234567 , 2.4691356 , & & 0.0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0 b = a + 1.0 / ( 10 ** i10 ) call accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0 b = a + 1.0 / ( 10 ** i20 ) call accdig ( a , b , real ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call accdig ( 1.2345678 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ), 1.2345678 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig","tags":"","loc":"program/demo_accdig.html"},{"title":"demo_help_command – M_msg","text":"Uses M_io M_help Variables Type Attributes Name Initial character(len=:), allocatable :: help_text (:) integer :: position (2) character(len=128) :: string Source Code program demo_help_command use M_io , only : swallow use M_help , only : help_command character ( len = :), allocatable :: help_text (:) integer :: position ( 2 ) character ( len = 128 ) :: string position = [ 0 , 23 ] call swallow ( 'app/sample.hlp' , help_text ) do write ( * , '(*(g0))' , advance = 'no' ) 'enter topic>' read ( * , '(a)' ) string call help_command ( help_text , string , position ) enddo end program demo_help_command","tags":"","loc":"program/demo_help_command.html"},{"title":"demo_unit_check_done – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_check_done use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_done , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\"' ) ! program execution stopped endif end program demo_unit_check_done","tags":"","loc":"program/demo_unit_check_done.html"},{"title":"demo_msg – M_msg","text":"Uses M_msg Variables Type Attributes Name Initial integer :: biggest character(len=:), allocatable :: frmt character(len=:), allocatable :: pr Source Code program demo_msg use M_msg , only : str implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = str ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = str ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = str ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = str ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = str ( '(*(i' , int ( log10 ( real ( biggest ))), ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using str(3f) ! in an I/O statement is not recommended ! because if an error occurs str(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) str ( 'program will now stop' ) end program demo_msg","tags":"","loc":"program/demo_msg.html"},{"title":"demo_M_verify – M_msg","text":"Uses M_demo M_verify Source Code program demo_M_verify use M_demo , only : test_suite_M_demo use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_demo end program demo_M_verify","tags":"","loc":"program/demo_m_verify.html"},{"title":"runtest – M_msg","text":"Uses M_msg M_verify M_journal Subroutines subroutine test_accdig () call unit_check(‘accdig’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_almost () Arguments None subroutine test_dp_accdig () call unit_check(‘dp_accdig’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_in_margin () call unit_check(‘in_margin’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_round () call unit_check(‘round’, 0.eq.0, ‘checking’, 100) Arguments None subroutine test_significant () call unit_check(‘significant’, 0.eq.0, ‘checking’, 100) Arguments None Source Code program runtest use M_msg use M_verify use M_journal unit_check_command = '' call test_accdig () ! compare two real numbers only up to a specified number of digits call test_almost () ! function compares two numbers only up to a specified number of digits call test_dp_accdig () ! compare two double numbers only up to a specified number of digits call test_in_margin () ! check if two reals are approximately equal using a relative margin call test_round () ! round val to specified number of significant digits call test_significant () ! round val to specified number of significant digits call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_in_margin () call unit_check_start ( 'in_margin' , msg = '' ) !!call unit_check('in_margin', 0.eq.0, 'checking', 100) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_check ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_check ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_check_done ( 'in_margin' , msg = '' ) end subroutine test_in_margin !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_significant () call unit_check_start ( 'significant' , msg = '' ) !!call unit_check('significant', 0.eq.0, 'checking', 100) call unit_check_done ( 'significant' , msg = '' ) end subroutine test_significant !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_round () call unit_check_start ( 'round' , msg = '' ) !!call unit_check('round', 0.eq.0, 'checking', 100) call unit_check_done ( 'round' , msg = '' ) end subroutine test_round !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_accdig () call unit_check_start ( 'accdig' , msg = '' ) !!call unit_check('accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'accdig' , msg = '' ) end subroutine test_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_check_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_check ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i )) enddo call unit_check_done ( 'almost' , msg = '' ) end subroutine test_almost !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dp_accdig () call unit_check_start ( 'dp_accdig' , msg = '' ) !!call unit_check('dp_accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'dp_accdig' , msg = '' ) end subroutine test_dp_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","loc":"program/runtest.html"},{"title":"demo_fmt – M_msg","text":"Uses M_msg Variables Type Attributes Name Initial character(len=:), allocatable :: output Source Code program demo_fmt use :: M_msg , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","loc":"program/demo_fmt.html"},{"title":"demo_unit_check – M_msg","text":"Uses M_verify use M_verify, only: unit_check_keep_going         ! default is unit_check_keep_going=.false.\nuse M_verify, only: debug              ! default is .false.\nuse M_verify, only: unit_check_command ! default is unit_check_command=’‘; was ‘goodbad’ Variables Type Attributes Name Initial integer, allocatable :: arr (:) real, allocatable :: arr1 (:) real, allocatable :: arr2 (:) unit_check_command=’‘ integer :: i integer :: x Source Code program demo_unit_check use M_verify , only : unit_check use M_verify , only : unit_check_start use M_verify , only : unit_check_done use M_verify , only : almost !!use M_verify, only: unit_check_keep_going         ! default is unit_check_keep_going=.false. !!use M_verify, only: debug              ! default is .false. !!use M_verify, only: unit_check_command ! default is unit_check_command=''; was 'goodbad' implicit none integer :: i integer :: x integer , allocatable :: arr (:) real , allocatable :: arr1 (:) real , allocatable :: arr2 (:) !!unit_check_command='' x = 10 arr1 = [ 1.0 , 1 0.0 , 10 0.0 ] arr2 = [ 1.0001 , 1 0.001 , 10 0.01 ] call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) do i = 1 , size ( arr1 ) call unit_check ( 'myroutine' , almost ( arr1 ( i ), arr2 ( i ), 3.9 , verbose = . true .) ) enddo arr = [ 10 , 20 , 30 ] call unit_check ( 'myroutine' , . not . any ( arr < 0 ) , 'test if any negative values in array ARR' ) call unit_check ( 'myroutine' , all ( arr < 100 ) , 'test if all values less than 100 in array ARR' ) call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\" all passed' ) end program demo_unit_check","tags":"","loc":"program/demo_unit_check.html"},{"title":"demo_journal – M_msg","text":"Uses M_journal showing creating debug messages\nproduces no output because trail is not on\nturn on debug messages\nproduces output on stdout because debug mode\nis on but no named trail file\nopen trail file\ndebug messages now go to the trail file\nclose trail file so messages go to stdout again\ndebug on stdout now\nback to no output from the next message Source Code program demo_journal !! showing creating debug messages use M_journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , '*demo* DEBUG MESSAGE 001 IGNORED' ) !! turn on debug messages call journal ( '>' , 'debug on' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 002 ON STDOUT' ) !! open trail file call journal ( 'O' , 'mytrail.txt' ) !! debug messages now go to the trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! close trail file so messages go to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , '*demo* DEBUG MESSAGE 004 TO STDOUT' ) call journal ( '<' , 'debug off' ) !! back to no output from the next message call journal ( 'D' , '*demo* DEBUG MESSAGE 005 IGNORED' ) end program demo_journal","tags":"","loc":"program/demo_journal.html"},{"title":"demo_unit_check_start – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: ival Source Code program demo_unit_check_start use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_done implicit none integer :: ival call unit_check_start ( 'myroutine' ) ! the goodbad(1) command called here takes many options ! used to build an SQLite3 entry call unit_check_start ( 'myroutine_long' , ' & & -section        3                    & & -library        libGPF               & & -filename       `pwd`/M_verify.FF     & & -documentation  y                    & & -prep           y                    & & -ccall          n                    & & -archive        GPF.a                & & ' ) ival = 10 call unit_check ( 'myroutine' , ival > 3 , msg = 'test if big enough' ) call unit_check ( 'myroutine' , ival < 100 , msg = 'test if small enough' ) call unit_check_done ( 'myroutine' , msg = 'completed checks of \"myroutine\"' ) end program demo_unit_check_start","tags":"","loc":"program/demo_unit_check_start.html"},{"title":"demo_unit_check_msg – M_msg","text":"Uses M_verify Source Code program demo_unit_check_msg use M_verify , only : unit_check_start , unit_check_msg , unit_check_done implicit none call unit_check_start ( 'myroutine' ) call unit_check_msg ( 'myroutine' , 'HUGE(3f) integers' , huge ( 0 ), 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) call unit_check_msg ( 'myroutine' , 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) call unit_check_msg ( 'myroutine' , 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) call unit_check_msg ( 'myroutine' , 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) call unit_check_done ( 'myroutine' ) end program demo_unit_check_msg","tags":"","loc":"program/demo_unit_check_msg.html"},{"title":"runtest – M_msg","text":"Uses M_msg M_verify M_journal setup\nteardown Subroutines subroutine test_flush_trail () call unit_check(‘flush_trail’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_set_stdout_lun () call unit_check(‘set_stdout_lun’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_where_write_message_all () call unit_check(‘where_write_message_all’, 0.eq.0, ‘checking’,100) Arguments None subroutine test_write_message_only () call unit_check(‘write_message_only’, 0.eq.0, ‘checking’,100) Arguments None Source Code program runtest use M_msg use M_verify use M_journal implicit none !! setup call test_flush_trail () call test_set_stdout_lun () call test_where_write_message_all () call test_write_message_only () call unit_check_stop () !! teardown !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_flush_trail () implicit none call unit_check_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_check('flush_trail', 0.eq.0, 'checking',100) call unit_check_done ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_set_stdout_lun () implicit none call unit_check_start ( 'set_stdout_lun' , msg = '' ) !!call unit_check('set_stdout_lun', 0.eq.0, 'checking',100) call unit_check_done ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_where_write_message_all () implicit none call unit_check_start ( 'where_write_message_all' , msg = '' ) !!call unit_check('where_write_message_all', 0.eq.0, 'checking',100) call unit_check_done ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_write_message_only () implicit none call unit_check_start ( 'write_message_only' , msg = '' ) !!call unit_check('write_message_only', 0.eq.0, 'checking',100) call unit_check_done ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","loc":"program/runtest~2.html"},{"title":"main – M_msg","text":"Uses M_msg Variables Type Attributes Name Initial logical :: allpassed = .true. logical, allocatable :: tests (:) Subroutines subroutine add (message, question, answer, answer2) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message character(len=*), intent(in) :: question character(len=*), intent(in) :: answer character(len=*), intent(in) :: answer2 Source Code program main use M_msg , only : str implicit none logical :: allpassed = . true . logical , allocatable :: tests (:) tests = [ logical :: ] call add ( 'INTEGER' , str ( 10 ), '10' , '10' ) call add ( 'LOGICAL' , str (. false .), 'F' , 'F' ) call add ( 'LOGICAL' , str (. true .), 'T' , 'T' ) call add ( 'REAL' , str ( 10 0.0 ), '100.000000' , '100.0000' ) call add ( 'COMPLEX' , str (( 1 1.0 , 2 2.0 )), '(11.0000000,22.0000000)' , '(11.00000,22.00000)' ) call add ( 'COMPOUND' , str ( 10 , 10 0.0 , \"string\" ,( 1 1.0 , 2 2.0 ),. false .), & & '10 100.000000 string (11.0000000,22.0000000) F' ,& & '10 100.0000 string (11.00000,22.00000) F' ) write ( * , '(*(g0,1x))' ) tests if ( allpassed ) then write ( * , '(*(g0,1x))' ) \"*M_msg::str* Passed\" , size ( tests ), \"tests\" stop 0 else write ( * , '(*(g0,1x))' ) \"*M_msg::str* Failed\" , count (. not . tests ), \"Passed\" , count ( tests ) stop 1 endif contains subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if (. not . passed ) then passed = question . eq . answer2 endif write ( * , '(*(g0,1x))' ) passed , 'expected ' , answer , 'got' , question tests = [ tests , passed ] allpassed = allpassed . and . passed end subroutine add end program main","tags":"","loc":"program/main.html"},{"title":"demo_unit_check_bad – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_check_bad use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_bad ( 'myroutine' , msg = 'checks on \"myroutine\" failed' ) ! program execution stopped endif end program demo_unit_check_bad","tags":"","loc":"program/demo_unit_check_bad.html"},{"title":"demo_fstop – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: int !write( , )’Enter stop value’\n!read( , ) int Source Code program demo_fstop use M_verify , only : fstop implicit none integer :: int !*!write(*,*)'Enter stop value' !*!read(*,*) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = 'error: program will now stop' ) case ( 25 ) ; call fstop ( int , stdout = 'stdout message' , stderr = 'stderr message' ) case ( 30 ) ; call fstop ( int , stdout = 'error: program will now stop' ) case default call fstop ( int ) endselect end program demo_fstop","tags":"","loc":"program/demo_fstop.html"},{"title":"demo_almost – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: i real :: x real :: y logical :: z Source Code program demo_almost use M_verify , only : almost implicit none real :: x , y logical :: z integer :: i x = 1.2345678 y = 1.2300000 do i = 1 , 8 z = almost ( x , y , real ( i ), verbose = . true .) write ( * , * ) i , z enddo end program demo_almost","tags":"","loc":"program/demo_almost.html"},{"title":"demo_in_margin – M_msg","text":"Uses M_verify Source Code program demo_in_margin use :: M_verify , only : in_margin implicit none write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.01 ) end program demo_in_margin","tags":"","loc":"program/demo_in_margin.html"},{"title":"demo_pdec – M_msg","text":"Uses M_verify Source Code program demo_pdec use M_verify , only : pdec call pdec ( ' ABCDEFG abcdefg    ' ) end program demo_pdec","tags":"","loc":"program/demo_pdec.html"},{"title":"demo_significant – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0.7,1x))' integer :: i real :: r real :: v Source Code program demo_significant use M_verify , only : significant implicit none integer :: i real :: r , v character ( len =* ), parameter :: g = '(*(g0.7,1x))' write ( * , g ) significant ([ 876 5.43210 , 0.1234567890 ], 5 ) write ( * , * ) 'default:' , 1.23456789012345 write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ), 'RU' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ), 'RD' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ), 'RZ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ), 'RN' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ), 'RC' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ), 'RP' end program demo_significant","tags":"","loc":"program/demo_significant.html"},{"title":"demo_wrt – M_msg","text":"Uses M_msg iso_fortran_env Variables Type Attributes Name Initial integer, parameter :: ints (3) = [1, 2, 3] integer :: iostat = 0 integer, allocatable :: luns (:) Source Code program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_msg , only : wrt , fmt implicit none integer , allocatable :: luns (:) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , 'NULL LIST:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! multiple files can be used to create a log file, for example luns = [ stderr , stdout ] call wrt ( luns , 'TWO FILES:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], 'USING FMT :' , & & huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , fmt ( ints ( 2 ), 'i0.4' ), iostat = iostat ) end program demo_wrt","tags":"","loc":"program/demo_wrt.html"},{"title":"demo_stderr – M_msg","text":"Uses M_verify iso_fortran_env Source Code program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_verify , only : stderr implicit none call stderr ( 'A simple message' ) call stderr ( 'error: RVALUE=' , 3.0 / 4.0 ) call stderr ( 'error: IVALUE=' , 123456789 ) call stderr ( 'error: LVALUE=' ,. true .) SEVERAL : block integer :: least = 10 , most = 999 , ival =- 10 call stderr ( 'error: value' , ival , 'should be between' , least , 'and' , most ) endblock SEVERAL call stderr ( 'real32  :' , huge ( 0.0_real32 ), 0.0_real32 , 1234 5.6789_real32 , tiny ( 0.0_real32 )) call stderr ( 'real64  :' , huge ( 0.0_real64 ), 0.0_real64 , 1234 5.6789_real64 , tiny ( 0.0_real64 )) call stderr ( 'real128 :' , huge ( 0.0_real128 ), 0.0_real128 , 1234 5.6789_real128 , tiny ( 0.0_real128 )) call stderr ( 'complex :' , cmplx ( huge ( 0.0_real ), tiny ( 0.0_real ))) call stderr ( 'error: program will now stop' ) stop 1 end program demo_stderr","tags":"","loc":"program/demo_stderr.html"},{"title":"demo_assert – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial real :: a real :: toobig = 1024 Source Code program demo_assert use M_verify , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( 'myroutine' , 101 , a > toobig , 'The value is too large' , a , ' > ' , toobig ) end program demo_assert","tags":"","loc":"program/demo_assert.html"},{"title":"demo_unit_check_good – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_check_good use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) call unit_check_good ( 'myroutine' , msg = 'checks on \"myroutine\" ' ) end program demo_unit_check_good","tags":"","loc":"program/demo_unit_check_good.html"},{"title":"demo_help_command – M_msg","text":"Uses M_help Variables Type Attributes Name Initial character(len=:), allocatable :: help_text (:) integer :: position (2) Source Code program demo_help_command use M_help , only : help_command character ( len = :), allocatable :: help_text (:) integer :: position ( 2 ) position = [ 0 , 23 ] help_text = [ character ( len = 80 ) :: & '==============================================' ,& '   A sample help text file.                   ' ,& '   Note the first line MUST start with \"===\"  ' ,& '==============================================' ,& 'SUMMARY                                       ' ,& '  This is usually a crib sheet                ' ,& '==============================================' ,& 'SECTION1                                      ' ,& 'topic1                                        ' ,& '   A description of topic 1                   ' ,& '                                              ' ,& '   and any general text you want              ' ,& '                                              ' ,& 'topic2  A description of topic 2              ' ,& 'topic3                                        ' ,& '   A description of topic 3                   ' ,& '   more  description of topic 3               ' ,& '   and more description of topic 3 a          ' ,& '   and more description of topic 3 b          ' ,& '   and more description of topic 3 c          ' ,& '   and more description of topic 3 d          ' ,& '   and more description of topic 3 e          ' ,& '   and more description of topic 3 f          ' ,& '   and more description of topic 3 g          ' ,& '   and more description of topic 3 h          ' ,& '   and more description of topic 3 i          ' ,& '   and more description of topic 3 j          ' ,& '   and more description of topic 3 k          ' ,& '   and more description of topic 3 l          ' ,& '   and more description of topic 3 m          ' ,& '   and more description of topic 3 n          ' ,& '   and more description of topic 3 o          ' ,& '   and more description of topic 3 p          ' ,& '   and more description of topic 3 q          ' ,& '   and more description of topic 3 r          ' ,& '   and more description of topic 3 s          ' ,& '   and more description of topic 3 t          ' ,& '   and more description of topic 3 u          ' ,& '   and more description of topic 3 v          ' ,& '   and more description of topic 3 w          ' ,& '   and more description of topic 3 x          ' ,& '   and more description of topic 3 y          ' ,& '   and more description of topic 3 z          ' ,& '==============================================' ,& 'SECTION2                                      ' ,& 'topic4  A description of topic 4              ' ,& '   this is the last part of SECTION1          ' ,& 'topic5                                        ' ,& '  This is all about the fifth topic and is    ' ,& '  just displayed as-is. The text cannot start ' ,& '  in column one or it will be seen as the     ' ,& '  beginning of a topic.                       ' ,& '==============================================' ,& '                                              ' ] write ( * , * ) '>>>>>' call help_command ( help_text , '' , position ) write ( * , * ) '>>>>>topic1' call help_command ( help_text , 'topic1' , position ) write ( * , * ) '>>>>>topics' call help_command ( help_text , 'topics' , position ) write ( * , * ) '>>>>>manual' call help_command ( help_text , 'manual' , position ) end program demo_help_command","tags":"","loc":"program/demo_help_command~2.html"},{"title":"demo_journal – M_msg","text":"Uses M_journal BASIC USAGE Source Code program demo_journal use M_journal , only : journal !! BASIC USAGE call journal ( 'write to standard output as-is, and trail file as a comment if open' ) ! since we have not opened a trail file yet, only stdout will display output call journal ( 'c' , 'ignored, as trail file is not open' ) ! now open trail file \"trail\" call journal ( 'o' , 'trail' ) call journal ( 'sc' , 'same thing except now trail file is open' ) ! only write to trail file if open call journal ( 'c' , 'not ignored, as trail file is open. Written with # suffix' ) call journal ( 't' , 'not ignored, as trail file is open. Written as-is' ) ! turn off trail file call journal ( 'o' , '' ) end program demo_journal","tags":"","loc":"program/demo_journal~2.html"},{"title":"demo_dp_accdig – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial doubleprecision :: a real :: acurcy real :: acurcy1 real :: acurcy2 doubleprecision :: b integer :: digi integer :: i10 integer :: i20 integer :: i30 integer :: ind integer :: ind1 integer :: ind2 doubleprecision :: vals (9) Source Code program demo_dp_accdig ! fortran 90 example use M_verify , only : dp_accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1.234680d0 , 1.2345378d0 , 2.2234568d0 , 1.2345678d0 , & & 1.2345679d0 , - 1.2345678d0 , 7 6.234567d0 , 2.4691356d0 , & & 0.0d0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0d0 b = a + 1.0d0 / ( 10 ** i10 ) call dp_accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0d0 b = a + 1.0d0 / ( 10 ** i20 ) call dp_accdig ( a , b , dble ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call dp_accdig ( 1.2345678d0 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call dp_accdig ( vals ( i30 ), 1.2345678d0 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_dp_accdig","tags":"","loc":"program/demo_dp_accdig.html"},{"title":"demo_unit_check_stop – M_msg","text":"Uses M_verify Variables Type Attributes Name Initial integer :: x Source Code program demo_unit_check_stop use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_stop , unit_check_bad use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level implicit none integer :: x unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_bad ( 'myroutine' , msg = 'x /= 0' ) endif call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\"' ) call unit_check_stop () end program demo_unit_check_stop","tags":"","loc":"program/demo_unit_check_stop.html"},{"title":"demo_accdig.f90 – M_msg","text":"Source Code program demo_accdig ! fortran 90 example use M_verify , only : accdig implicit none integer :: digi integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 real :: a , b real :: vals ( 9 ) data vals / & & 1.234680 , 1.2345378 , 2.2234568 , 1.2345678 , & & 1.2345679 , - 1.2345678 , 7 6.234567 , 2.4691356 , & & 0.0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0 b = a + 1.0 / ( 10 ** i10 ) call accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0 b = a + 1.0 / ( 10 ** i20 ) call accdig ( a , b , real ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call accdig ( 1.2345678 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call accdig ( vals ( i30 ), 1.2345678 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_accdig","tags":"","loc":"sourcefile/demo_accdig.f90.html"},{"title":"hlp.f90 – M_msg","text":"Source Code program demo_help_command use M_io , only : swallow use M_help , only : help_command character ( len = :), allocatable :: help_text (:) integer :: position ( 2 ) character ( len = 128 ) :: string position = [ 0 , 23 ] call swallow ( 'app/sample.hlp' , help_text ) do write ( * , '(*(g0))' , advance = 'no' ) 'enter topic>' read ( * , '(a)' ) string call help_command ( help_text , string , position ) enddo end program demo_help_command","tags":"","loc":"sourcefile/hlp.f90.html"},{"title":"demo_unit_check_done.f90 – M_msg","text":"Source Code program demo_unit_check_done use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_done , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\"' ) ! program execution stopped endif end program demo_unit_check_done","tags":"","loc":"sourcefile/demo_unit_check_done.f90.html"},{"title":"demo_str.f90 – M_msg","text":"Source Code program demo_msg use M_msg , only : str implicit none character ( len = :), allocatable :: pr character ( len = :), allocatable :: frmt integer :: biggest pr = str ( 'HUGE(3f) integers' , huge ( 0 ),& & 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) write ( * , '(a)' ) pr pr = str ( 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) write ( * , '(a)' ) pr pr = str ( 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) write ( * , '(a)' ) pr pr = str ( 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) write ( * , '(a)' ) pr ! create a format on the fly biggest = huge ( 0 ) frmt = str ( '(*(i' , int ( log10 ( real ( biggest ))), ':,1x))' , sep = '' ) write ( * , * ) 'format=' , frmt ! although it will often work, using str(3f) ! in an I/O statement is not recommended ! because if an error occurs str(3f) will try ! to write while part of an I/O statement ! which not all compilers can handle and is currently non-standard write ( * , * ) str ( 'program will now stop' ) end program demo_msg","tags":"","loc":"sourcefile/demo_str.f90.html"},{"title":"demo_M_verify.f90 – M_msg","text":"program demo_unit_tests Source Code !!program demo_unit_tests module M_demo private public one !! regular routines public two !! regular routines public test_suite_M_demo !! special name for use with test_suite(1bash). contains !!  regular routines subroutine one () end subroutine one subroutine two () end subroutine two !! unit test subroutine test_suite_M_demo use M_verify , only : unit_check_start , unit_check use M_verify , only : unit_check_good , unit_check_bad , unit_check_done use M_verify , only : unit_check_msg , unit_check_stop implicit none integer :: i , j , k integer , allocatable :: array (:) integer :: arr ( 4 ) = [ 21 , 51 , 14 , 45 ] integer :: a = 21 , b = 51 , c = 14 , d = 45 ! TEST-DRIVEN DEVELOPMENT ! optional set-up       perform initialization operations common to all tests within a module i = 1 j = 2 k = 3 array = [ 10 , 20 , 30 , 40 , 50 , 60 , 70 ] call test_one () call test_two () ! optional tear-down    perform finalization operations common to all tests within a module contains subroutine test_one () !  register an entry for specified name (\"one\") in database with status of zero (0) call unit_check_start ( 'one' ) !  if mask test fails, can !  * produce a SUCCESS: or FAIL: message and stop program !  * change database status for specified entry to -1 and stop program, else continue !  * produce a SUCCESS: or FAIL: message and keep going !  * produce a FAIL: message if test fails but no SUCCESS: message if test passes call unit_check ( 'one' , i > 0 , msg = 'I > 0' ) ! using ANY(3f) and ALL(3f) call unit_check ( 'one' , all ([ i , j , k ] > 0 ), 'testing if everyone greater than zero' ) ! display message built of scalars as well call unit_check ( 'one' , all (. not .[ i , j , k ] == 4 ), 'for set ' , i , j , k , 'testing if no one is equal to four' ) ! for tests that are hard to reduce to a logical test just call unit_check_bad(3f) if fail if ( i + j + k < 1 ) then call unit_check_bad ( 'one' ) endif call unit_check_done ( 'one' , 'checks on \"one\" ended' ) end subroutine test_one subroutine test_two ! use of all(3f), any(3f), merge(3f) can be useful ! if you know what these would produce ! write(*,*)['A','X','X','X','X','B'] == 'B'      ! this would return an array, the last element having the value T, else F ! write(*,*)all(['A','X','X','X','X','X'] == 'X') ! this would return F ! write(*,*)any(['A','X','X','X','X','X'] == 'B') ! this would return F ! write(*,*)any(['A','X','X','X','X','B'] == 'B') ! this would return T ! write(*,*).not.all(array < 100) ! write(*,*)all(array < 100) ! write(*,*)all([a,b,c,d] == [21,51,14,45]) ! compare a list. This would return T ! write(*,*)all(arr == [21,51,14,45])       ! compare an array. This would return T ! you know how valuable ANY(3f) and ALL(3f) will be call unit_check_start ( 'two' , 'check on \"two\" passed' ) call unit_check ( 'two' , 1 > 0 . and . abs ( 1 0.10000 - 1 0.10001 ) < 0.0001 , msg = 'two looks good' ) call unit_check_done ( 'two' , 'checks on \"two\" ended' ) end subroutine test_two end subroutine test_suite_M_demo end module M_demo program demo_M_verify use M_demo , only : test_suite_M_demo use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 call test_suite_M_demo end program demo_M_verify","tags":"","loc":"sourcefile/demo_m_verify.f90.html"},{"title":"test_suite_M_verify.f90 – M_msg","text":"Source Code program runtest use M_msg use M_verify use M_journal unit_check_command = '' call test_accdig () ! compare two real numbers only up to a specified number of digits call test_almost () ! function compares two numbers only up to a specified number of digits call test_dp_accdig () ! compare two double numbers only up to a specified number of digits call test_in_margin () ! check if two reals are approximately equal using a relative margin call test_round () ! round val to specified number of significant digits call test_significant () ! round val to specified number of significant digits call unit_check_stop () contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_in_margin () call unit_check_start ( 'in_margin' , msg = '' ) !!call unit_check('in_margin', 0.eq.0, 'checking', 100) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000000001 ), 'compare' , 4.00000 , 3.99999 , 0.000000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.00000001 ) , 'compare' , 4.00000 , 3.99999 , 0.00000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.0000001 ) , 'compare' , 4.00000 , 3.99999 , 0.0000001 ) call unit_check ( 'in_margin' , . not . in_margin ( 4.00000 , 3.99999 , 0.000001 ) , 'compare' , 4.00000 , 3.99999 , 0.000001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.00001 ) , 'compare' , 4.00000 , 3.99999 , 0.00001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.0001 ) , 'compare' , 4.00000 , 3.99999 , 0.0001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.001 ) , 'compare' , 4.00000 , 3.99999 , 0.001 ) call unit_check ( 'in_margin' , in_margin ( 4.00000 , 3.99999 , 0.01 ) , 'compare' , 4.00000 , 3.99999 , 0.01 ) call unit_check ( 'in_margin' ,. not . all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.000001 )), 'should all be false' ) call unit_check ( 'in_margin' , all ( in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ],& & [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ], 0.1 )), 'should all be true' ) call unit_check_done ( 'in_margin' , msg = '' ) end subroutine test_in_margin !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_significant () call unit_check_start ( 'significant' , msg = '' ) !!call unit_check('significant', 0.eq.0, 'checking', 100) call unit_check_done ( 'significant' , msg = '' ) end subroutine test_significant !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_round () call unit_check_start ( 'round' , msg = '' ) !!call unit_check('round', 0.eq.0, 'checking', 100) call unit_check_done ( 'round' , msg = '' ) end subroutine test_round !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_accdig () call unit_check_start ( 'accdig' , msg = '' ) !!call unit_check('accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'accdig' , msg = '' ) end subroutine test_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_almost () real :: x , y , r integer :: i logical , parameter :: expected ( * ) = [. true ., . true ., . false ., . false ., . false ., . false ., . false ., . false .] call unit_check_start ( 'almost' , msg = '' ) x = 1.2345678 y = 1.2300000 do i = 1 , 8 r = real ( i ) call unit_check ( 'almost' , almost ( x , y , r , verbose = . false .). eqv . expected ( i )) enddo call unit_check_done ( 'almost' , msg = '' ) end subroutine test_almost !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_dp_accdig () call unit_check_start ( 'dp_accdig' , msg = '' ) !!call unit_check('dp_accdig', 0.eq.0, 'checking', 100) call unit_check_done ( 'dp_accdig' , msg = '' ) end subroutine test_dp_accdig !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT !   call test_accdig()         ! compare two real numbers only up to a specified number of digits !   call test_dp_accdig()      ! compare two double numbers only up to a specified number of digits !   call test_round()          ! round val to specified number of significant digits !   call test_significant()    ! round val to specified number of significant digits","tags":"","loc":"sourcefile/test_suite_m_verify.f90.html"},{"title":"demo_fmt.f90 – M_msg","text":"Source Code program demo_fmt use :: M_msg , only : fmt implicit none character ( len = :), allocatable :: output output = fmt ( 10 , \"'[',i0,']'\" ) write ( * , * ) 'result is ' , output output = fmt ( 1 0.0 / 3.0 , \"'[',g0.5,']'\" ) write ( * , * ) 'result is ' , output output = fmt (. true ., \"'The final answer is [',g0,']'\" ) write ( * , * ) 'result is ' , output end program demo_fmt","tags":"","loc":"sourcefile/demo_fmt.f90.html"},{"title":"demo_unit_check.f90 – M_msg","text":"Source Code program demo_unit_check use M_verify , only : unit_check use M_verify , only : unit_check_start use M_verify , only : unit_check_done use M_verify , only : almost !!use M_verify, only: unit_check_keep_going         ! default is unit_check_keep_going=.false. !!use M_verify, only: debug              ! default is .false. !!use M_verify, only: unit_check_command ! default is unit_check_command=''; was 'goodbad' implicit none integer :: i integer :: x integer , allocatable :: arr (:) real , allocatable :: arr1 (:) real , allocatable :: arr2 (:) !!unit_check_command='' x = 10 arr1 = [ 1.0 , 1 0.0 , 10 0.0 ] arr2 = [ 1.0001 , 1 0.001 , 10 0.01 ] call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) do i = 1 , size ( arr1 ) call unit_check ( 'myroutine' , almost ( arr1 ( i ), arr2 ( i ), 3.9 , verbose = . true .) ) enddo arr = [ 10 , 20 , 30 ] call unit_check ( 'myroutine' , . not . any ( arr < 0 ) , 'test if any negative values in array ARR' ) call unit_check ( 'myroutine' , all ( arr < 100 ) , 'test if all values less than 100 in array ARR' ) call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\" all passed' ) end program demo_unit_check","tags":"","loc":"sourcefile/demo_unit_check.f90.html"},{"title":"demo_M_journal.f90 – M_msg","text":"Source Code program demo_journal !! showing creating debug messages use M_journal , only : journal implicit none !! produces no output because trail is not on call journal ( 'D' , '*demo* DEBUG MESSAGE 001 IGNORED' ) !! turn on debug messages call journal ( '>' , 'debug on' ) !! produces output on stdout because debug mode !! is on but no named trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 002 ON STDOUT' ) !! open trail file call journal ( 'O' , 'mytrail.txt' ) !! debug messages now go to the trail file call journal ( 'D' , '*demo* DEBUG MESSAGE 003 TO TRAIL' ) !! close trail file so messages go to stdout again call journal ( 'O' , '' ) !! debug on stdout now call journal ( 'D' , '*demo* DEBUG MESSAGE 004 TO STDOUT' ) call journal ( '<' , 'debug off' ) !! back to no output from the next message call journal ( 'D' , '*demo* DEBUG MESSAGE 005 IGNORED' ) end program demo_journal","tags":"","loc":"sourcefile/demo_m_journal.f90.html"},{"title":"M_journal.f90 – M_msg","text":"Source Code !> !!##NAME !!     M_journal(3fm) - [M_journal::INTRO] write program messages to stdout and/or !!     a log file !!     (LICENSE:PD) !!##SYNOPSIS !! !!     use, M_journal , only : journal !!##DESCRIPTION !! !!    For interactive programs in particular it is useful if all messages !!    go thru the JOURNAL(3f) routine. This makes it easy to write messages !!    to a log file as well as standard output; to toggle time prefixes !!    on and off; to turn on and off debug-mode messages; control output !!    paging and create replayable input journals. !! !!    The primary use of JOURNAL(3f) is to create journal files for !!    interactive programs that can be replayed and/or be used to verify !!    program executions. Typically, you would echo what the user typed to !!    the trail file as-is, and write output you write to stdout as comments !!    to the trail file so that the trail file can easily be read back in !!    (by ignoring comments). So usually things that are read from user !!    input are using output with WHERE='T' and output that usually goes !!    to stdout is written with WHERE='SC' in the JOURNAL(3f) call. !! !!     >      : !!     >      : !!     > character(len=256) userline, output !!     > call journal('O','my_trail_file')  ! open trail file !!     >      : !!     >      : !!     > do !!     >    read(*,'(a)',iostat=ios) userline  ! read user input !!     >    if(ios /= 0)exit !!     >    ! echo user input to trail file !!     >    call journal('T',userline) !!     >    ! assume user input causes values i1, i2, and i3 to be calculated !!     >    write(output,'(i0,1x,i0,1x)')i1,i2,i3 ! build an output line !!     >    ! write output to stdout and as comment to trail file !!     >    call journal(output) !!     >    !or you can specify the WHERE parameter and up to ten scalar values !!     >    call journal('SC','i1=',i1,'i2=',i2,'i3=',i3) !!     > enddo !! !!    In this example an output line was built with an internal write; but calls !!    to journal(3f) with numeric values with and without advancing I/O turned on !!    are often used for simpler output: !! !!       I=10 !!       R=20.3 !!       ! write to stdout and trail file without advancing I/O !!       call journal('+SC','I=',i) !!       call journal('SC','AND R=',r) !! !!    writes to the trail file are ignored unless a trail file was opened with !! !!       CALL JOURNAL('O',filename) !! !! !!    So that routines that do their output via JOURNAL(3f) can be used with and !!    without programs generating trail files. That is, destinations 'T' and 'C' !!    are ignored unless a trail file has been requested. !! !!    With no parameters, the trail file is flushed. !! !!##EXAMPLES !! !! !!    The man(1) page for journal(3f) describes all the options for the WHERE field. !!    In addition to being used to generate a journal, the routine can be used for !!    producing optional debug messages and timing information. !! !!    Sample program for debug messages: !! !!      program demo_journal !!      !! showing creating debug messages !!      use M_journal, only : journal !!      implicit none !!      !! produces no output because trail is not on !!      call journal('D','*demo* DEBUG MESSAGE 001 IGNORED') !!      !! turn on debug messages !!      call journal('>','debug on') !!      !! produces output on stdout because debug mode !!      !! is on but no named trail file !!      call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT') !!      !! open trail file !!      call journal('O','mytrail.txt') !!      !! debug messages now go to the trail file !!      call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL') !!      !! close trail file so messages go to stdout again !!      call journal('O','') !!      !! debug on stdout now !!      call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT') !!      call journal('<','debug off') !!      !! back to no output from the next message !!      call journal('D','*demo* DEBUG MESSAGE 005 IGNORED') !!      end program demo_journal !! !!   Sample program for trail messages with optional timing information: !! !!      program testit !!      use M_journal,only : journal !!      implicit none !!      call journal('a single string A -should be on S') !! !!      ! add time prefix to output !!      call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b') !!      call journal('a single string B -should be on S with prefix') !!      call journal('%','CPU_TIME: %c:CALLS: %C: %b')  ! change time prefix !!      call journal('a single string B-1 -should be on S with prefix') !!      call journal('a single string B-2 -should be on S with prefix') !!      call journal('a single string B-3 -should be on S with prefix') !!      !  Other useful time formats: !!      !     %E -- Unix Epoch time !!      !     %e -- integer value of Unix Epoch time !!      !     %C -- number of times this format is used !!      !     %c -- CPU_time(3f) output !!      !     %S -- seconds since last use of this format !!      !     %k -- CPU time in seconds from system_clock !!      call journal('%','') ! turn off time prefix !!      ! !!      call journal('a single string C -should be on S') !!      ! !!      call journal('O','aaa.out') ! turn on trail file !!      call journal('a single string D -should be on SC') !!      call journal('a single string E -should be on SC') !!      call journal('a single string F -should be on SC') !!      call journal('O','') ! turn off trail file !!      ! !!      call journal('a single string G -should be on S') !!      call journal('a single string H -should be on S') !!      call journal('a single string I -should be on S') !! !!      ! build one line of output with intrinsic scalar values added !!      call journal('+sc','APPEND:') !!      call journal('+sc',' integer',         1234) !!      call journal('+sc',' and real',        1234.5678) !!      call journal('+sc',' and double',1234567890.123456d0) !!      call journal('+sc',' and logical',    .true.) !!      call journal('sc','') !!      ! !!      end program testit !! !!##AUTHOR !!     John S. Urban !!##LICENSE !!     Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_journal use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT , INPUT_UNIT , OUTPUT_UNIT ! access computing environment use :: M_msg , only : str implicit none private !> !!##NAME !!      journal(3f) - [M_journal] provides public message routine, no paging or graphic mode change !!      (LICENSE:PD) !!##SYNOPSIS !! !! !!    subroutine journal([where,],[VALUE(s)]) !! !!     character(len=*),intent(in) :: where !!     character(len=*)|real|integer|doubleprecision|complex,optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !! !!   WRITE MESSAGES !!    basic messages !! !!       call journal(where,[VALUE(S)]) !!       call journal(message) # a shortcut for \"call journal('sc',message)\": !!   OPEN OR CLOSE TRAIL FILE !!    trail file !! !!       call journal('O',trailfile_name) # open trail file !!       call journal('O','')             # close trail file !!   SET OUTPUT TIME PREFIX !!    set the function display format for timestamps. See the NOW(3f) !!    procedure for allowable timestamp macros !! !!       call journal('%',time_stamp_prefix_specification) !! !!   MODES !! !!    Turn on/off writing DEBUG messages to trail file !! !!       call journal('>','debug on') # turn on debug mode !!       call journal('<','debug off') # turn off debug mode !! !!   ASSIGN STDOUT TO AN ALTERNATE FILE !!    change stdout to iunit and open filename; or close unit and go back to stdout if filename='' !! !!       call journal(iunit,filename) !! !!    change stdout to iunit to use a file already open !! !!       call journal(iunit) !! !!##DESCRIPTION !! !!    If a user procedure is used for outputting messages instead of calling !!    WRITE(3f) it is easy to provide control of when messages are printed !!    (ie. a \"verbose\" mode, or \"quite\" mode), creating files to replay !!    program execution, duplicating output, ... !! !!##OPTIONS !!   WHERE  indicates where messages are written. A combination of the !!          following characters can be used... !! !!      Usually one of these to write to the standard output files ... !! !!      S   write to stdout or iounit set with journal(unit) or !!          journal(unit,filename). !!      E   write to stderr !! !!      And one of these to write to trail file (ignore if no trail file !!      defined) ... !! !!      C   write to trail file as a comment (if file is open) !!          Writing output \"as a comment\" means it is preceded by a pound(#) !!          character. !!      T   write to trail file (if file is open) !! !!      Usually used by itself !! !!      D   write to trail file as a comment with \"DEBUG:\" prefix in front !!          of message (if file is open) if debug mode is on. Write to stdout !!          if no trail file and debug mode is on. !! !!      Modifier for S|E|C|T|D specifiers !! !!      +   subsequent files are written to with advance='no'. Position is !!          important. '+sc' does an advance='no' on both files, 's+c' !!          only does the advance='no' for the trail file. !! !!      Mode changing options used by themselves: !! !!      >   turn off debug messages !!      <   turn on debug messages !!      O   open trail file using value of \"message\" parameter or close !!          trail file if no filename or a blank filename. !!      A   Auxiliary programs that also want to write to the current log file !!          (a2b, z2a, ...) call this routine to see if there is a trail file !!          being generated and then add to it so that a program like ush(1f) !!          can call the auxiliary programs and still just generate one log file, !!          but if the auxiliary program is used as a stand-alone program no trail !!          is generated. !! !!   VALUES(S)   message to write to stdout, stderr, and the trail file. !!               a numeric or character value to optionally be appended !!               to the message. Up to nine values are allowed. The WHERE !!               field is required if values are added. !!   FILENAME    when WHERE=\"O\" to turn the trail file on or off, the \"message\" !!               field becomes the trail filename to open. If blank, writing !!               to the trail file is turned off. !!   TFORMAT     when WHERE=\"%\" the message is treated as a time format !!               specification as described under now(3f). !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_journal !!    use M_journal, only : journal !!    !! BASIC USAGE !!    call journal('write to standard output as-is, and trail file as a comment if open') !!    ! since we have not opened a trail file yet, only stdout will display output !!    call journal('c','ignored, as trail file is not open') !!    ! now open trail file \"trail\" !!    call journal('o','trail') !!    call journal('sc','same thing except now trail file is open') !!    ! only write to trail file if open !!    call journal('c','not ignored, as trail file is open. Written with # suffix') !!    call journal('t','not ignored, as trail file is open. Written as-is') !!    ! turn off trail file !!    call journal('o','') !!    end program demo_journal !! !!   Adding intrinsic scalar values to the message: !! !!    program test_journal !!    use M_journal, only: journal !!    implicit none !!       call journal('S','This is a test with no optional value') !!       call journal('S','This is a test with a logical value',.true.) !!       call journal('S','This is a test with a double value',1234567890.123456789d0) !!       call journal('S','This is a test with a real value',1234567890.123456789) !!       call journal('S','This is a test with an integer value',1234567890) !!       call journal('STDC','This is a test using STDC',1234567890) !!       call journal('stdc','This is a test using stdc',1234567890) !!       call journal('o','journal.txt')                        ! open trail file !!       call journal('S',1,12.34,56789.111111111d0,.false.,'a bunch of values') !!       ! the combinations that make sense !!       call journal('st','stdout and trail') !!       call journal('s' ,'stdout only') !!       call journal('t' ,'trail only') !!       call journal('sc','stdout and trail_comment') !!       call journal('c' ,'trail_comment only ') !!       call journal('d' ,'debug only') !!       call journal('e' ,'stderr only') !!       call journal('o' ,' ') ! closing trail file !!    end program test_journal !! !!    program testit !!    ! this is a utility program that calls the module routines. It is typically built using ccall(1). !!    use M_journal, only : journal !!       character(len=:),allocatable :: time_stamp_prefix !!       call journal('s','--------------------------------------------------------------------------------') !!       call journal('s','SIMPLE WRITES') !!       call one() !!       call two() !!       call journal('sc','called ONE() and TWO() but did not generate a log file') !!       call journal('s','--------------------------------------------------------------------------------') !!       call journal('s','SIMPLE WRITES WITH LOG FILE') !!       call journal('o','journal.txt')                        ! open trail file !!       call one() !!       call two() !!       call journal('sc','called ONE() and TWO() and generated log file journal.txt') !!       call journal('','journal.txt')                         ! close trail file !!       call journal('s','--------------------------------------------------------------------------------') !!       call journal('s','SIMPLE WRITES WITH TIMING INFORMATION') !!       time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b'  ! change time prefix !!       call journal('%',time_stamp_prefix) ! set a time prefix in front of messages !!       call journal('o','timed.txt')                          ! open trail file !!       call one() !!       call two() !!       call journal('sc','called ONE() and TWO() and generate log file timed.txt') !!       call journal('','timed.txt')                           ! close trail file !!       call journal('%','')                                   ! turn off time prefix !!       call journal('o','timed.txt')                          ! open trail file !!       call journal('s','--------------------------------------------------------------------------------') !! !!    contains !! !!       subroutine two() !!          call journal('Entered subroutine two') !!          call journal('Exited subroutine two') !!       end subroutine two !! !!       subroutine one() !!          call journal('Entered subroutine one') !!          sum=-HUGE(1.0) !!          do i=1,10000000 !!            sum=sum+sqrt(real(i)) !!          enddo !!          write(*,*)'SUM=',sum !!          call journal('Exited subroutine one') !!       end subroutine one !! !!    end program testit !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain public journal interface journal module procedure flush_trail ! journal()                ! no options module procedure write_message_only ! journal(c)               ! must have one string module procedure where_write_message_all ! journal(where,[g1-g9])   ! must have two strings module procedure set_stdout_lun ! journal(i)               ! first is not a string end interface journal ! ident_1=\"@(#) M_journal journal(3fg) provides public message routine no paging or graphic mode change\" ! global variables !integer,parameter,private  :: stdin=INPUT_UNIT integer , save , private :: my_stdout = OUTPUT_UNIT logical , save :: debug = . false . integer , save :: last_int = 0 integer , parameter , private :: dp = kind ( 0.0d0 ) real ( kind = dp ) :: secday = 8640 0.0d0 ! 24:00:00 hours as seconds contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine where_write_message ( where , msg ) ! ident_2=\"@(#) M_journal where_write_message(3fp) basic message routine used for journal files\" character ( len =* ), intent ( in ) :: where character ( len =* ), intent ( in ) :: msg ! !  writes error messages and general information text to stdout and the trace file !     where=*C* write to trail file as a comment (if file is open) !     where=*D* write to trail file as a comment with DEBUG: prefix in front of message (if file is open and debug mode on) !     where=*E* write to stderr !     where=*S* write to stdout or iounit set with journal(unit) or journal(unit,filename) !     where=*T* write to trail file (if file is open) !     where=*+* subsequent writes for this call are written with advance='no' !     where=> turn on debug messages (change mode), which are ones with WHERE='D' !     where=< turn off debug messages  (change mode), which are ones with WHERE='D' !     where=O open trail file \"msg\" or close trail file if blank filename is given !     where=% set prefix to run thru now(3f) to generate time prefix strings, blank turns off time prefix !     where=N open new file and assign stdout to the file unless file name is blank; then revert to my_stdout being original stdout. ! !  the trail file messages are preceded by a pound character (#) by default so they can easily be interpreted as comments !  if the trace file is subsequently used as input data for a program ! logical , save :: trailopen = . false . integer , save :: itrail character , save :: comment = '#' integer :: i integer :: ios integer :: times ! number of times written to stdout character ( len = 3 ) :: adv ! whether remaining writes from this call use advancing I/O character ( len = :), allocatable , save :: prefix_template ! string to run thru now_ex(3f) to make prefix character ( len = :), allocatable :: prefix ! the prefix string to add to output logical , save :: prefix_it = . false . ! flag whether time prefix mode is on or not character ( len = 4096 ) :: mssge !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- adv = 'yes' !----------------------------------------------------------------------------------------------------------------------------------- if ( prefix_it ) then prefix = now_ex ( prefix_template ) else prefix = '' endif !----------------------------------------------------------------------------------------------------------------------------------- times = 0 do i = 1 , len_trim ( where ) select case ( where ( i : i )) case ( 'T' , 't' ) if ( trailopen ) then write ( itrail , '(a)' , advance = adv ) prefix // trim ( msg ) !!elseif(times == 0)then !!   write(my_stdout,'(a)',advance=adv)prefix//trim(msg) !!   times=times+1 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'S' , 's' ) write ( my_stdout , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( 'E' , 'e' ) write ( stderr , '(a)' , advance = adv ) prefix // trim ( msg ) times = times + 1 !----------------------------------------------------------------------------------------------------------------------------- case ( '+' ); adv = 'no' !----------------------------------------------------------------------------------------------------------------------------- case ( '>' ); debug = . true . !----------------------------------------------------------------------------------------------------------------------------- case ( '<' ); debug = . false . !----------------------------------------------------------------------------------------------------------------------------- case ( '%' ) ! setting timestamp prefix if ( msg == '' ) then ! if message is blank turn off prefix prefix_it = . false . else ! store message as string to pass to now_ex() on subsequent calls to make prefix prefix_template = msg prefix_it = . true . endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'N' ) ! new name for my_stdout if ( msg /= ' ' . and . msg /= '#N#' . and . msg /= '\"#N#\"' ) then ! if filename not special or blank open new file close ( unit = last_int , iostat = ios ) open ( unit = last_int , file = adjustl ( trim ( msg )), iostat = ios ) if ( ios == 0 ) then my_stdout = last_int else write ( * , * ) '*journal* error opening redirected output file, ioerr=' , ios write ( * , * ) '*journal* msg=' // trim ( msg ) endif elseif ( msg == ' ' ) then close ( unit = last_int , iostat = ios ) my_stdout = 6 endif !----------------------------------------------------------------------------------------------------------------------------- case ( 'C' , 'c' ) if ( trailopen ) then write ( itrail , '(3a)' , advance = adv ) prefix , comment , trim ( msg ) elseif ( times == 0 ) then !! write(my_stdout,'(2a)',advance=adv)prefix,trim(msg) !! times=times+1 endif case ( 'D' , 'd' ) if ( debug ) then if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'DEBUG: ' , trim ( msg ) elseif ( times == 0 ) then write ( my_stdout , '(3a)' , advance = adv ) prefix , 'DEBUG:' , trim ( msg ) times = times + 1 endif endif case ( 'F' , 'f' ) flush ( unit = itrail , iostat = ios , iomsg = mssge ) if ( ios /= 0 ) then write ( * , '(a)' ) trim ( mssge ) endif case ( 'A' , 'a' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )),& & form = 'formatted' , iostat = ios , position = 'append' ) trailopen = . true . endif case ( 'O' , 'o' ) if ( msg /= '' ) then open ( newunit = itrail , status = 'unknown' , access = 'sequential' , file = adjustl ( trim ( msg )), form = 'formatted' , iostat = ios ) trailopen = . true . else if ( trailopen ) then write ( itrail , '(4a)' , advance = adv ) prefix , comment , 'closing trail file:' , trim ( msg ) endif close ( unit = itrail , iostat = ios ) trailopen = . false . endif case default write ( my_stdout , '(a)' , advance = adv ) '*journal* bad WHERE value ' // trim ( where ) // ' when msg=[' // trim ( msg ) // ']' end select enddo !----------------------------------------------------------------------------------------------------------------------------------- end subroutine where_write_message !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine flush_trail () ! ident_3=\"@(#) M_journal flush_trail(3fp) flush trail file\" call where_write_message ( 'F' , 'IGNORE THIS STRING' ) end subroutine flush_trail !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine set_stdout_lun ( iounit ) ! ident_4=\"@(#) M_journal set_stdout_lun(3fp) change I/O logical unit value for standard writes\" integer , intent ( in ) :: iounit my_stdout = iounit end subroutine set_stdout_lun !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    where_write_message_all(3f) - [M_journal] converts any standard scalar type to a string and calls journal(3f) !!    (LICENSE:PD) !!##SYNOPSIS !! !!   subroutine where_write_message_all(where,g0,g1,g2g3,g4,g5,g6,g7,g8,g9,sep) !! !!     character(len=*),intent(in)   :: where !!     class(*),intent(in)           :: g0 !!     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !!     character,intent(in),optional :: sep !! !!##DESCRIPTION !!    where_write_message_all(3f) builds and writes a space-separated string from up to nine scalar values. !! !!##OPTIONS !! !!    where    string designating where to write message, as with journal(3f) !!    g0       value to print. May !!             be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!             or CHARACTER. !!    g[1-9]   optional additional values to print the value of after g0. !!    sep      separator to add between values. Default is a space !!##RETURNS !!    where_write_message_all  description to print !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_wm_all !!    use M_journal, only : where_write_message_all !!    implicit none !!    end program program demo_wm_all !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine where_write_message_all ( where , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , sep ) implicit none ! ident_5=\"@(#) M_journal where_write_message_all(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: where class ( * ), intent ( in ) :: g0 class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 character , intent ( in ), optional :: sep call where_write_message ( where , str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , sep )) end subroutine where_write_message_all !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine write_message_only ( message ) ! ident_6=\"@(#) M_journal write_message_only(3fp) calls JOURNAL('sc' message)\" character ( len =* ), intent ( in ) :: message !----------------------------------------------------------------------------------------------------------------------------------- call where_write_message ( 'sc' , trim ( message )) !----------------------------------------------------------------------------------------------------------------------------------- end subroutine write_message_only !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine d2j ( dat , julian , ierr ) !----------------------------------------------------------------------------------------------------------------------------------- ! * Author:    John S. Urban ! * Version:   1.0 2015-12-21 ! * Reference: From Wikipedia, the free encyclopedia 2015-12-19 ! * There is no year zero ! * Julian Day must be non-negative ! * Julian Day starts at noon; while Civil Calendar date starts at midnight !----------------------------------------------------------------------------------------------------------------------------------- ! ident_7=\"@(#) d2j(3f) Converts proleptic Gregorian date array to Julian Day\" integer , intent ( in ) :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) real ( kind = dp ), intent ( out ) :: julian ! Julian Day (non-negative, but may be non-integer) integer , intent ( out ) :: ierr ! Error return, 0 for successful execution,-1=invalid year,-2=invalid month,-3=invalid day, ! -4=invalid date (29th Feb, non leap-year) integer :: year , month , day , utc , hour , minute real ( kind = dp ) :: second integer :: A , Y , M , JDN !----------------------------------------------------------------------------------------------------------------------------------- year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !----------------------------------------------------------------------------------------------------------------------------------- julian = - HUGE ( 99999 ) ! this is the date if an error occurs and IERR is < 0 !----------------------------------------------------------------------------------------------------------------------------------- if ( year == 0 . or . year . lt . - 4713 ) then ierr =- 1 return endif !----------------------------------------------------------------------------------------------------------------------------------- !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or Febuary, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for Febuary !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- if ( julian . lt . 0.d0 ) then ! Julian Day must be non-negative ierr = 1 else ierr = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine d2j !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine j2d ( dat , julian , ierr ) ! ident_8=\"@(#) j2d(3f) Converts Julian Day to date array\" integer , intent ( out ) :: dat ( 8 ) integer :: timezone ( 8 ), tz real ( kind = dp ), intent ( in ) :: julian ! Julian Day (non-negative) integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 real ( kind = dp ) :: second integer :: year integer :: month integer :: day integer :: hour integer :: minute integer :: jalpha , ja , jb , jc , jd , je , ijul if ( julian . lt . 0.d0 ) then ! Negative Julian Day not allowed ierr = 1 return else ierr = 0 endif call date_and_time ( values = timezone ) tz = timezone ( 4 ) ijul = idint ( julian ) ! Integral Julian Day second = sngl (( julian - dble ( ijul )) * secday ) ! Seconds from beginning of Jul. Day second = second + ( tz * 60 ) if ( second . ge .( secday / 2.0d0 )) then ! In next calendar day ijul = ijul + 1 second = second - ( secday / 2.0d0 ) ! Adjust from noon to midnight else ! In same calendar day second = second + ( secday / 2.0d0 ) ! Adjust from noon to midnight endif if ( second . ge . secday ) then ! Final check to prevent time 24:00:00 ijul = ijul + 1 second = second - secday endif minute = int ( second / 6 0.0 ) ! Integral minutes from beginning of day second = second - float ( minute * 60 ) ! Seconds from beginning of minute hour = minute / 60 ! Integral hours from beginning of day minute = minute - hour * 60 ! Integral minutes from beginning of hour !--------------------------------------------- jalpha = idint (( dble ( ijul - 1867216 ) - 0.25d0 ) / 3652 4.25d0 ) ! Correction for Gregorian Calendar ja = ijul + 1 + jalpha - idint ( 0.25d0 * dble ( jalpha )) !--------------------------------------------- jb = ja + 1524 jc = idint ( 668 0.d0 + ( dble ( jb - 2439870 ) - 12 2.1d0 ) / 36 5.25d0 ) jd = 365 * jc + idint ( 0.25d0 * dble ( jc )) je = idint ( dble ( jb - jd ) / 3 0.6001d0 ) day = jb - jd - idint ( 3 0.6001d0 * dble ( je )) month = je - 1 if ( month . gt . 12 ) then month = month - 12 endif year = jc - 4715 if ( month . gt . 2 ) then year = year - 1 endif if ( year . le . 0 ) then year = year - 1 endif dat ( 1 ) = year dat ( 2 ) = month dat ( 3 ) = day dat ( 4 ) = tz dat ( 5 ) = hour dat ( 6 ) = minute dat ( 7 ) = int ( second ) dat ( 8 ) = int (( second - int ( second )) * 100 0.0 ) ierr = 0 end subroutine j2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine d2u ( dat , unixtime , ierr ) ! ident_9=\"@(#) d2u(3f) Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970)\" integer , intent ( in ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME real ( kind = dp ), intent ( out ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! return 0 on successful, otherwise 1 real ( kind = dp ) :: julian real ( kind = dp ), save :: julian_at_epoch logical , save :: first = . true . !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Compute zero of Unix Time in Julian days and save call d2j ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ], julian_at_epoch , ierr ) if ( ierr . ne . 0 ) return ! Error first = . false . endif !----------------------------------------------------------------------------------------------------------------------------------- call d2j ( dat , julian , ierr ) if ( ierr . ne . 0 ) return ! Error unixtime = ( julian - julian_at_epoch ) * secday end subroutine d2u !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine u2d ( dat , unixtime , ierr ) ! REF:JRH:1991-05-23 ! REF:JSU:2015-12-12 !----------------------------------------------------------------------------------------------------------------------------------- ! ident_10=\"@(#) u2d(3f) Converts Unix Time to date array\" integer , intent ( out ) :: dat ( 8 ) ! date and time array real ( kind = dp ), intent ( in ) :: unixtime ! Unix time (seconds) integer , intent ( out ) :: ierr ! 0 for successful execution, otherwise 1 real ( kind = dp ) :: julian ! Unix time converted to a Julian date real ( kind = dp ), save :: Unix_Origin_as_Julian ! start of Unix Time as Julian date logical , save :: first = . TRUE . integer :: v ( 8 ) ! date and time array used to get time zone !----------------------------------------------------------------------------------------------------------------------------------- if ( first ) then ! Initialize calculated constants on first call call d2j ([ 1970 , 1 , 1 , 0 , 0 , 0 , 0 , 0 ], Unix_Origin_as_Julian , ierr ) ! Compute start of Unix Time in Julian days if ( ierr . ne . 0 ) return ! Error first = . FALSE . endif !----------------------------------------------------------------------------------------------------------------------------------- call date_and_time ( values = v ) ! need to get time zone julian = ( unixtime / secday ) + Unix_Origin_as_Julian ! convert seconds from Unix Epoch to Julian days call j2d ( dat , julian , ierr ) ! calculate date array from Julian date dat ( 4 ) = v ( 4 ) end subroutine u2d !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION d2o ( dat ) RESULT ( ordinal ) ! ident_11=\"@(#) d2o(3f) Converts date-time array to Ordinal day\" INTEGER , INTENT ( IN ) :: dat ( 8 ) ! date time array similar to that returned by DATE_AND_TIME INTEGER :: ordinal ! the returned number of days REAL ( KIND = dp ) :: unixtime ! Unix time (seconds) REAL ( KIND = dp ) :: unix_first_day INTEGER :: ierr ! return 0 on successful, otherwise 1 from d2u(3f) CALL d2u ( dat , unixtime , ierr ) ! convert date to Unix Epoch Time IF ( ierr . NE . 0 ) THEN write ( * , * ) '*d2o* bad date array' ordinal =- 1 ! initialize to bad value ELSE CALL d2u ([ dat ( 1 ), 1 , 1 , dat ( 4 ), 0 , 0 , 0 , 0 ], unix_first_day , ierr ) ordinal = int (( unixtime - unix_first_day ) / secday ) + 1 ENDIF END FUNCTION d2o !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION v2mo ( imonth ) RESULT ( month_name ) ! ident_12=\"@(#) v2mo(3f) returns the month name of a Common month\" CHARACTER ( LEN = :), ALLOCATABLE :: month_name ! string containing month name or abbreviation. INTEGER , INTENT ( IN ) :: imonth ! the number of the month(1-12) CHARACTER ( LEN =* ), PARAMETER :: names ( 12 ) = [ character ( len = 9 ) :: & & 'January  ' , 'February ' , 'March    ' , 'April    ' , 'May      ' , 'June     ' , & & 'July     ' , 'August   ' , 'September' , 'October  ' , 'November ' , 'December ' ] SELECT CASE ( imonth ) CASE ( 1 : 12 ); month_name = TRIM ( names ( imonth )) CASE DEFAULT ; month_name = 'UNKNOWN' END SELECT END FUNCTION v2mo !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION now ( format ) ! ident_13=\"@(#) JSU 2015-10-24\" CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: format CHARACTER ( LEN = :), ALLOCATABLE :: now INTEGER :: values ( 8 ) !----------------------------------------------------------------------------------------------------------------------------------- CALL DATE_AND_TIME ( VALUES = values ) IF ( PRESENT ( format )) THEN IF ( format . NE . ' ' ) THEN now = fmtdate ( values , format ) ELSE now = fmtdate ( values , '%Y-%M-%D %h:%m:%s %z' ) ENDIF ELSE NOW = fmtdate ( values , '%Y-%M-%D %h:%m:%s %z Julian date is %J Epoch time is %E ' ) ENDIF END FUNCTION now !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== FUNCTION fmtdate ( values , format ) RESULT ( timestring ) ! Read the FORMAT string and replace the \"%\" strings per the following rules: !----------------------------------------------------------------------------------------------------------------------------------- ! ident_14=\"@(#) fmtdate(3f) given date array return date as string using format\" CHARACTER ( LEN =* ), INTENT ( IN ) :: format ! input format string INTEGER , DIMENSION ( 8 ), INTENT ( IN ) :: values ! numeric time values as DATE_AND_TIME(3f) intrinsic returns CHARACTER ( LEN = :), ALLOCATABLE :: timestring !- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - INTEGER :: i10 LOGICAL :: keyword ! flag that previous character was a % character CHARACTER ( LEN = 9 ) :: day ! day of week CHARACTER ( LEN = 1 ) :: chara ! character being looked at in format string CHARACTER ( LEN = 4096 ) :: text ! character array INTEGER :: iout INTEGER :: weekday INTEGER :: ierr INTEGER , SAVE :: called = 0 LOGICAL , SAVE :: since = . FALSE . REAL ( KIND = dp ) :: julian REAL ( KIND = dp ) :: cputime INTEGER :: ii REAL ( KIND = dp ) :: unixtime REAL ( KIND = dp ), save :: unixtime_last INTEGER :: systemclock , countrate INTEGER :: iso_year , iso_week , iso_weekday CHARACTER ( LEN = 10 ) :: iso_name CHARACTER ( LEN = 2 ) :: dayend text = ' ' !  write string, when encounter a percent character do a substitution keyword = . FALSE . iout = 1 DO i10 = 1 , LEN ( format ) chara = format ( i10 : i10 ) IF ( chara . eq . '%' . and .. not . keyword ) THEN keyword = . TRUE . CYCLE ENDIF IF ( keyword ) THEN keyword = . FALSE . SELECT CASE ( chara ) !===================================================================================== CASE ( '%' ); WRITE ( text ( iout :), '(A1)' ) chara ! literal percent character !===================================================================================== CASE ( 'b' ); WRITE ( text ( iout :), '(A1)' ) ' ' ! space character !===================================================================================== CASE ( 'c' ); CALL cpu_time ( cputime ) ! CPU_TIME() WRITE ( text ( iout :), '(G0)' ) cputime !===================================================================================== CASE ( 'C' ); called = called + 1 ! number of times this routine called WRITE ( text ( iout :), '(I0)' ) called !===================================================================================== CASE ( 'd' ); ! the day of the month 1st..31st dayend = '  ' select case ( values ( 3 )) case ( 1 , 21 , 31 ); dayend = 'st' case ( 2 , 22 ); dayend = 'nd' case ( 3 , 23 ); dayend = 'rd' case ( 4 : 20 , 24 : 30 ); dayend = 'th' case default end select WRITE ( text ( iout :), '(I2,a)' ) values ( 3 ), dayend !===================================================================================== CASE ( 'D' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 3 ) ! the day of the month 1..31 !===================================================================================== CASE ( 'e' ); CALL d2u ( values , unixtime , ierr ) ! integer Unix Epoch time in seconds WRITE ( text ( iout :), '(G0)' ) int ( unixtime ) !===================================================================================== CASE ( 'E' ); CALL d2u ( values , unixtime , ierr ) ! Unix Epoch time in seconds WRITE ( text ( iout :), '(G0)' ) unixtime !===================================================================================== CASE ( 'h' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 5 ) ! the hour of the day, in the range of 0 to 23 !===================================================================================== CASE ( 'H' ); ii = mod ( values ( 5 ), 12 ) ! hour of day in range 1..12 if ( ii . eq . 0 ) then ii = 12 endif WRITE ( text ( iout :), '(I2.2)' ) ii !===================================================================================== CASE ( 'i' ); CALL woy ( values , iso_year , iso_week , iso_weekday , iso_name ) ! ISO week of year WRITE ( text ( iout :), '(I0)' ) iso_week !===================================================================================== CASE ( 'I' ); CALL woy ( values , iso_year , iso_week , iso_weekday , iso_name ) ! iso-8601 Week-numbering year date WRITE ( text ( iout :), '(a)' ) iso_name !===================================================================================== CASE ( 'j' ); CALL d2j ( values , julian , ierr ) ! integer Julian date (truncated to integer) WRITE ( text ( iout :), '(I0)' ) int ( julian ) !===================================================================================== CASE ( 'J' ); CALL d2j ( values , julian , ierr ) ! Julian date to milliseconds WRITE ( text ( iout :), '(I0,\".\",i3.3)' ) int ( julian ), int (( julian - int ( julian )) * 100 0.0 ) !===================================================================================== CASE ( 'k' ); call system_clock ( count = systemclock , count_rate = countrate ) ! systemclock/countrate WRITE ( text ( iout :), '(G0)' ) real ( systemclock ) / countrate !===================================================================================== CASE ( 'l' ); WRITE ( text ( iout :), '(A3)' ) v2mo ( values ( 2 )) ! three characters of the name of the month of the year !===================================================================================== CASE ( 'L' ); WRITE ( text ( iout :), '(A)' ) v2mo ( values ( 2 )) ! name of the month of the year !===================================================================================== CASE ( 'm' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 6 ) ! the minutes of the hour, in the range 0 to 59 !===================================================================================== CASE ( 'M' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 2 ) ! month of year (1..12) !===================================================================================== CASE ( 'N' ); if ( values ( 5 ). ge . 12 ) then ! AM||PM WRITE ( text ( iout :), '(\"PM\")' ) else WRITE ( text ( iout :), '(\"AM\")' ) endif !===================================================================================== CASE ( 'O' ); WRITE ( text ( iout :), '(I3.3)' ) d2o ( values ) ! Ordinal day of year !===================================================================================== CASE ( 's' ); WRITE ( text ( iout :), '(I2.2)' ) values ( 7 ) ! the seconds of the minute, in the range 0 to 60 !===================================================================================== CASE ( 'S' ); IF (. NOT . since ) THEN ! seconds since last called since = . TRUE . CALL d2u ( values , unixtime_last , ierr ) ENDIF CALL d2u ( values , unixtime , ierr ) WRITE ( text ( iout :), '(G0)' ) unixtime - unixtime_last unixtime_last = unixtime !===================================================================================== CASE ( 't' ); WRITE ( text ( iout :), '(A1)' ) CHAR ( 9 ) ! tab character !===================================================================================== CASE ( 'U' ); CALL dow ( values , weekday , day , ierr ) ! Return the day of the week, 1..7 Sunday=1 WRITE ( text ( iout :), '(I1)' ) weekday !===================================================================================== CASE ( 'u' ); CALL dow ( values , weekday , day , ierr ) ! Return the day of the week, 1..7 Monday=1 WRITE ( text ( iout :), '(I1)' ) mod ( weekday + 5 , 7 ) + 1 !===================================================================================== CASE ( 'W' ); CALL dow ( values , weekday , day , ierr ) ! Return the name of the day of the week WRITE ( text ( iout :), '(a)' ) day !===================================================================================== CASE ( 'w' ); CALL dow ( values , weekday , day , ierr ) ! Return the first three characters of the day of the week WRITE ( text ( iout :), '(A3)' ) day ( 1 : 3 ) !===================================================================================== CASE ( 'x' ); WRITE ( text ( iout :), '(I3.3)' ) values ( 8 ) ! the milliseconds of the second, in the range 0 to 999 !===================================================================================== CASE ( 'Y' ); WRITE ( text ( iout :), '(I4.4)' ) values ( 1 ) ! the year, including the century (for example, 1990) !===================================================================================== CASE ( 'Z' ); WRITE ( text ( iout :), '(SP,I5.4)' ) values ( 4 ) ! time difference with respect to UTC in minutes !===================================================================================== CASE ( 'z' ); WRITE ( text ( iout :), '(I3.2,\":\",I2.2)' ) int ( values ( 4 ) / 60 ), abs ( mod ( values ( 4 ), 60 )) ! time from UTC as +-hh:mm !===================================================================================== CASE DEFAULT WRITE ( text ( iout :), '(A1)' ) chara !===================================================================================== END SELECT !===================================================================================== iout = len_trim ( text ) + 1 ELSE WRITE ( text ( iout :), '(A1)' ) chara ; iout = iout + 1 ENDIF ENDDO timestring = trim ( text ) END FUNCTION fmtdate !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine fmtdate_usage ( ii ) ! ident_15=\"@(#) JSU 2015-10-24\" character ( len = 51 ), allocatable :: usage (:) integer :: i , ii character ( len = ii ) :: blanks usage = [ & !date(1) COMMAND & ' Base time array:                                  ' ,& & ' (1) %Y -- year, yyyy                              ' ,& & ' (2) %M -- month of year, 01 to 12                 ' ,& & ' (3) %D -- day of month, 01 to 31                  ' ,& & '     %d -- day of month, with suffix (1st, 2nd,...)' ,& & ' (4) %Z -- minutes from UTC                        ' ,& & '     %z -- -+hh:mm from UTC                        ' ,& & ' (5) %h -- hours, 00 to 23                         ' ,& & '     %H -- hour (1 to 12, or twelve-hour clock)    ' ,& & '     %N -- AM (before noon) PM (>=after noon)      ' ,& & ' (6) %m -- minutes, 00 to 59                       ' ,& & ' (7) %s -- sec, 00 to 60                           ' ,& & ' (8) %x -- milliseconds 000 to 999                 ' ,& & 'Conversions                                        ' ,& & '     %E -- Unix Epoch time                         ' ,& & '     %e -- integer value of Unix Epoch time        ' ,& & '     %J -- Julian  date                            ' ,& & '     %j -- integer value of Julian date            ' ,& & '     %O -- Ordinal day (day of year)               ' ,& & '     %U -- day of week, 1..7 Sunday=1              ' ,& & '     %u -- day of week, 1..7 Monday=1              ' ,& & '     %i -- ISO week of year 1..53                  ' ,& & '     %I -- iso-8601 week-numbering date(yyyy-Www-d)' ,& & ' Names                                             ' ,& & '     %l -- abbreviated month name                  ' ,& & '     %L -- full month name                         ' ,& & '     %w -- first three characters of weekday       ' ,& & '     %W -- weekday name                            ' ,& & ' Literals                                          ' ,& & '     %% -- a literal %%                            ' ,& & '     %t -- tab character                           ' ,& & '     %b -- blank character                         ' ,& & ' Program timing:                                   ' ,& & '     %c -- CPU_TIME(3f) output                     ' ,& & '     %C -- number of times this routine is used    ' ,& & '     %k -- time in seconds from SYSTEM_CLOCK(3f)   ' ,& & '                                                   ' ] blanks = ' ' WRITE ( * , '(a,a)' )( blanks (: ii ), usage ( i ), i = 1 , size ( usage )) end subroutine fmtdate_usage !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine dow ( values , weekday , day , ierr ) ! ident_16=\"@(#) dow(3f) Return the day of the week\" real ( kind = dp ) :: julian ! the julian day for which the weekday is required, integer , intent ( in ) :: values ( 8 ) ! date and time array used to get time zone integer , intent ( out ), optional :: weekday ! The day of the week, 1 = Sunday character * ( * ), intent ( out ), optional :: day ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9 integer , intent ( out ) :: ierr ! Error return,0=correct,-1=invalid Julian day,-2=neither day nor weekday specified integer :: iweekday call d2j ( values , julian , ierr ) ! need julian date to calculate day of week for first day of month ierr = 0 if ( julian < 0 ) then ierr = - 1 return endif if (. not . present ( day ). and . . not . present ( weekday )) then ierr =- 2 return endif ! julian day starts at noon so add 1/2 day ! add time zone iweekday = mod ( int (( julian + dble ( values ( 4 ) / 6 0.0d0 / 2 4.0d0 ) + 0.5d0 ) + 1.0d0 ), 7 ) iweekday = iweekday + 1 if ( present ( day )) then select case ( iweekday ) case ( 1 ) ; day = 'Sunday' case ( 2 ) ; day = 'Monday' case ( 3 ) ; day = 'Tuesday' case ( 4 ) ; day = 'Wednesday' case ( 5 ) ; day = 'Thursday' case ( 6 ) ; day = 'Friday' case ( 7 ) ; day = 'Saturday' case default ; day = 'E-R-R-O-R' end select endif if ( present ( weekday )) then weekday = iweekday endif end subroutine dow !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine woy ( dat , iso_year , iso_week , iso_weekday , iso_name ) !----------------------------------------------------------------------------------------------------------------------------------- !  The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO). !  It is used (mainly) in government and business for fiscal years, as well as in timekeeping. !  The system specifies a week year atop the Gregorian calendar by defining a notation for ordinal weeks of the year. ! !  An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks. !  That is 364 or 371 days instead of the usual 365 or 366 days. !  The extra week is referred to here as a leap week, although ISO 8601 does not use this term. !  Weeks start with Monday. !  The first week of a year is the week that contains the first Thursday of the year (and, hence, always contains 4 January). !  ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January. !----------------------------------------------------------------------------------------------------------------------------------- !CALCULATION: !  The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year) !  and its day of the week. !METHOD: !   Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday), !   subtract the weekday from the ordinal date, then add 10. Divide the result !   by 7. Ignore the remainder; the quotient equals the week number. If !   the week number thus obtained equals 0, it means that the given date !   belongs to the preceding (week-based) year. If a week number of 53 is !   obtained, one must check that the date is not actually in week 1 of the !   following year. ! These two statements are assumed true when correcting the dates around January 1st ... !   o  The number of weeks in a given year is equal to the corresponding week number of 28 December. !   o  January 4th is always in the first week. ! !ISO_NAME: !  Week date representations are in the format YYYYWww-D. !  o [YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year. !  o [Www] is the week number prefixed by the letter W, from W01 through W53. !  o [D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday. ! !  For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written !     2006-W52-7 (extended form) !  or 2006W527 (compact form). ! !REFERENCE: !  From Wikipedia, the free encyclopedia 2015-12-19 !AUTHOR: !  John S. Urban, 2015-12-19 !----------------------------------------------------------------------------------------------------------------------------------- ! ident_17=\"@(#) woy(3f) Calculate iso-8601 Week-numbering year date yyyy-Www-d\" integer , parameter :: dp = kind ( 0.0d0 ) integer , intent ( in ) :: dat ( 8 ) ! input date array integer , intent ( out ) :: iso_year , iso_week , iso_weekday character ( len = 10 ), intent ( out ) :: iso_name integer :: shared_weekday integer :: last_week_this_year integer :: dec28_lastyear ( 8 ) ! December 28th is always in last week integer :: dec28_thisyear ( 8 ) ! December 28th is always in last week character ( len = 9 ) :: day integer :: ierr iso_year = dat ( 1 ) ! initially assume the iso_year is the same as the data array year iso_week = uncorrected_week_of_year ( dat ) ! this is the week number unless around January 1st iso_weekday = shared_weekday ! this is the number of the day of the week assuming Monday=1 dec28_thisyear = [ dat ( 1 ), 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week; use this to get number of weeks last_week_this_year = uncorrected_week_of_year ( dec28_thisyear ) ! get the number of the last week of the year (52 or 53) ! correct dates around January 1st if ( iso_week < 1 ) then ! if week < 1 then week = lastWeek(year -1) dec28_lastyear = [ dat ( 1 ) - 1 , 12 , 28 , dat ( 4 ), 0 , 0 , 0 , 0 ] ! Dec 28th is always in last week, we want its week number iso_week = uncorrected_week_of_year ( dec28_lastyear ) ! got the week number for the last week of last year (52 or 53) iso_year = dat ( 1 ) - 1 ! our date belongs to last year elseif ( iso_week > last_week_this_year ) then ! if week > lastweek(year) then week = 1 iso_week = iso_week - last_week_this_year ! our date belongs to next year iso_year = dat ( 1 ) + 1 endif write ( iso_name , '(i4.4,\"-W\",i2.2,\"-\",i1)' ) iso_year , iso_week , iso_weekday ! create ISO string designation for our date contains function uncorrected_week_of_year ( datin ) implicit none integer :: uncorrected_week_of_year integer , intent ( in ) :: datin ( 8 ) integer :: ordinal call dow ( datin , shared_weekday , day , ierr ) ! formula needs day of week 1..7 where Monday=1 shared_weekday = mod ( shared_weekday + 5 , 7 ) + 1 ! change from Sunday=1 to Monday=1 ordinal = d2o ( datin ) ! formula needs ordinal day of year where Jan 1st=1 uncorrected_week_of_year = ( ordinal - shared_weekday + 10 ) / 7 end function uncorrected_week_of_year end subroutine woy !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function dj ( dat ) result ( julian ) ! ident_18=\"@(#) dj(3f) Given date array returns Julian Day\" real ( kind = dp ) :: julian integer , intent ( in ) :: dat ( 8 ) integer :: ierr call d2j ( dat , julian , ierr ) end function dj function jd ( julian ) result ( dat ) ! ident_19=\"@(#) jd(3f) Given Julian Day returns date array\" real ( kind = dp ), intent ( in ) :: julian integer :: dat ( 8 ) integer :: ierr call j2d ( dat , julian , ierr ) end function jd function du ( dat ) result ( unixtime ) ! ident_20=\"@(#) du(3f) Given date array returns Unix Epoch time\" real ( kind = dp ) :: unixtime integer , intent ( in ) :: dat ( 8 ) integer :: ierr call d2u ( dat , unixtime , ierr ) end function du function ud ( unixtime ) result ( dat ) ! ident_21=\"@(#) ud(3f) Given Unix Epoch Time returns date array\" real ( kind = dp ), intent ( in ) :: unixtime integer :: dat ( 8 ) integer :: ierr call u2d ( dat , unixtime , ierr ) end function ud !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! !   XXXX !  X    X ! X ! X ! X ! X ! X !  X    X !   XXXX ! subroutine sys_sleep ( wait_seconds ) use , intrinsic :: iso_c_binding , only : c_int ! ident_22=\"@(#) sys_sleep(3f) call sleep(3c)\" integer ( c_int ) :: wait_seconds , how_long interface function c_sleep ( seconds ) bind ( C , name = \"sleep\" ) import integer ( c_int ) :: c_sleep !  should be unsigned int (not available in Fortran).  OK until highest bit gets set. integer ( c_int ), intent ( in ), VALUE :: seconds end function c_sleep end interface if ( wait_seconds . gt . 0 ) then how_long = c_sleep ( wait_seconds ) endif end subroutine sys_sleep !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function now_ex ( format ) ! ident_23=\"@(#) M_time now_ex(3f) use of now(3f) outside of a module\" character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: now_ex now_ex = now ( format ) end function now_ex !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== end module M_journal !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_journal.f90.html"},{"title":"demo_unit_check_start.f90 – M_msg","text":"Source Code program demo_unit_check_start use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_done implicit none integer :: ival call unit_check_start ( 'myroutine' ) ! the goodbad(1) command called here takes many options ! used to build an SQLite3 entry call unit_check_start ( 'myroutine_long' , ' & & -section        3                    & & -library        libGPF               & & -filename       `pwd`/M_verify.FF     & & -documentation  y                    & & -prep           y                    & & -ccall          n                    & & -archive        GPF.a                & & ' ) ival = 10 call unit_check ( 'myroutine' , ival > 3 , msg = 'test if big enough' ) call unit_check ( 'myroutine' , ival < 100 , msg = 'test if small enough' ) call unit_check_done ( 'myroutine' , msg = 'completed checks of \"myroutine\"' ) end program demo_unit_check_start","tags":"","loc":"sourcefile/demo_unit_check_start.f90.html"},{"title":"demo_unit_check_msg.f90 – M_msg","text":"Source Code program demo_unit_check_msg use M_verify , only : unit_check_start , unit_check_msg , unit_check_done implicit none call unit_check_start ( 'myroutine' ) call unit_check_msg ( 'myroutine' , 'HUGE(3f) integers' , huge ( 0 ), 'and real' , huge ( 0.0 ), 'and double' , huge ( 0.0d0 )) call unit_check_msg ( 'myroutine' , 'real            :' , huge ( 0.0 ), 0.0 , 1234 5.6789 , tiny ( 0.0 ) ) call unit_check_msg ( 'myroutine' , 'doubleprecision :' , huge ( 0.0d0 ), 0.0d0 , 1234 5.6789d0 , tiny ( 0.0d0 ) ) call unit_check_msg ( 'myroutine' , 'complex         :' , cmplx ( huge ( 0.0 ), tiny ( 0.0 )) ) call unit_check_done ( 'myroutine' ) end program demo_unit_check_msg","tags":"","loc":"sourcefile/demo_unit_check_msg.f90.html"},{"title":"test_suite_M_journal.f90 – M_msg","text":"Source Code !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT program runtest use M_msg use M_verify use M_journal implicit none !! setup call test_flush_trail () call test_set_stdout_lun () call test_where_write_message_all () call test_write_message_only () call unit_check_stop () !! teardown !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT contains !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_flush_trail () implicit none call unit_check_start ( 'flush_trail' , msg = '' ) call journal () !!call unit_check('flush_trail', 0.eq.0, 'checking',100) call unit_check_done ( 'flush_trail' , msg = '' ) end subroutine test_flush_trail !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_set_stdout_lun () implicit none call unit_check_start ( 'set_stdout_lun' , msg = '' ) !!call unit_check('set_stdout_lun', 0.eq.0, 'checking',100) call unit_check_done ( 'set_stdout_lun' , msg = '' ) end subroutine test_set_stdout_lun !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_where_write_message_all () implicit none call unit_check_start ( 'where_write_message_all' , msg = '' ) !!call unit_check('where_write_message_all', 0.eq.0, 'checking',100) call unit_check_done ( 'where_write_message_all' , msg = '' ) end subroutine test_where_write_message_all !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT subroutine test_write_message_only () implicit none call unit_check_start ( 'write_message_only' , msg = '' ) !!call unit_check('write_message_only', 0.eq.0, 'checking',100) call unit_check_done ( 'write_message_only' , msg = '' ) end subroutine test_write_message_only !TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT end program runtest","tags":"","loc":"sourcefile/test_suite_m_journal.f90.html"},{"title":"test_suite_M_msg.f90 – M_msg","text":"Source Code program main use M_msg , only : str implicit none logical :: allpassed = . true . logical , allocatable :: tests (:) tests = [ logical :: ] call add ( 'INTEGER' , str ( 10 ), '10' , '10' ) call add ( 'LOGICAL' , str (. false .), 'F' , 'F' ) call add ( 'LOGICAL' , str (. true .), 'T' , 'T' ) call add ( 'REAL' , str ( 10 0.0 ), '100.000000' , '100.0000' ) call add ( 'COMPLEX' , str (( 1 1.0 , 2 2.0 )), '(11.0000000,22.0000000)' , '(11.00000,22.00000)' ) call add ( 'COMPOUND' , str ( 10 , 10 0.0 , \"string\" ,( 1 1.0 , 2 2.0 ),. false .), & & '10 100.000000 string (11.0000000,22.0000000) F' ,& & '10 100.0000 string (11.00000,22.00000) F' ) write ( * , '(*(g0,1x))' ) tests if ( allpassed ) then write ( * , '(*(g0,1x))' ) \"*M_msg::str* Passed\" , size ( tests ), \"tests\" stop 0 else write ( * , '(*(g0,1x))' ) \"*M_msg::str* Failed\" , count (. not . tests ), \"Passed\" , count ( tests ) stop 1 endif contains subroutine add ( message , question , answer , answer2 ) character ( len =* ), intent ( in ) :: message character ( len =* ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: answer2 logical :: passed passed = question . eq . answer if (. not . passed ) then passed = question . eq . answer2 endif write ( * , '(*(g0,1x))' ) passed , 'expected ' , answer , 'got' , question tests = [ tests , passed ] allpassed = allpassed . and . passed end subroutine add end program main","tags":"","loc":"sourcefile/test_suite_m_msg.f90.html"},{"title":"demo_unit_check_bad.f90 – M_msg","text":"Source Code program demo_unit_check_bad use M_verify , only : unit_check_start use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_bad ( 'myroutine' , msg = 'checks on \"myroutine\" failed' ) ! program execution stopped endif end program demo_unit_check_bad","tags":"","loc":"sourcefile/demo_unit_check_bad.f90.html"},{"title":"demo_fstop.f90 – M_msg","text":"Source Code program demo_fstop use M_verify , only : fstop implicit none integer :: int !*!write(*,*)'Enter stop value' !*!read(*,*) int int = 25 select case ( int ) case ( 10 ) ; call fstop ( int ) case ( 20 ) ; call fstop ( int , stderr = 'error: program will now stop' ) case ( 25 ) ; call fstop ( int , stdout = 'stdout message' , stderr = 'stderr message' ) case ( 30 ) ; call fstop ( int , stdout = 'error: program will now stop' ) case default call fstop ( int ) endselect end program demo_fstop","tags":"","loc":"sourcefile/demo_fstop.f90.html"},{"title":"M_verify.F90 – M_msg","text":"Source Code !> !!##NAME !!    M_verify(3fm) - [M_verify::INTRO] a collection of Fortran routines for !!                    supporting code development by providing error !!                    processing, debugging procedures and unit testing. !!                    (LICENSE:PD) !!##SYNOPSIS !! !! !!  Module procedures !! !!    use M_verify, only : unit_check, unit_check_start, unit_check_done, unit_check_stop !!    use M_verify, only : unit_check_good, unit_check_bad !!    use M_verify, only : unit_check_msg !!    use M_verify, only : debug !!    use M_verify, only : fstop !!    use M_verify, only : assert !! !!  Module values !! !!    use M_verify, only : unit_check_limit, unit_check_keep_going !!    use M_verify, only : unit_check_command !! !!##QUOTE !!    Do not let your victories go to your head, nor let your failures go !!    to your heart. !! !!##DESCRIPTION !!    The M_verify(3fm) Fortran module provides procedures and variables !!    useful for providing error processing, debugging capabilities, and !!    unit testing. !! !!     o allows for a user-defined command to be called to collect results or !!       mail failure alerts, ... !!     o supports easily composing a message from up to nine scalar !!       intrinsic values and different message levels !!     o allows stopping on first failure or continuing !!     o provides for a non-zero exit code if any tests fail !! !!    SET MODES !!    unit_check_keep_going  logical variable that can be used to turn off !!                           program termination on errors. !!    unit_check_level       An integer that can be used to specify !!                           different debug levels !!    unit_check_command     name of command to execute. Defaults to the name !!                           \"\". !!    UNIT TESTS !!    unit_check_start(3f)   start tests of a procedure and optionally call !! !!                              command NAME start ... !!    unit_check(3f)         if expression is false optionally call !! !!                              command NAME bad !! !!                           and stop program (by default) !! !!    unit_check_done(3f)    call !! !!                              command NAME good !! !!                           if no failures; else call !! !!                              command NAME bad !!   unit_check_stop(3f)     stop program with exit value of 0 if no failures !!                           else with an exit value of 1 !! !!    unit_check_good(3f)    call command !! !!                              command NAME good !! !!    unit_check_bad(3f)     call command !! !!                              command NAME bad !! !!                           and stop program by default !!    unit_check_msg(3f)     write message !! !!    BASIC DEBUGGING !!    fstop(3f)             calls 'STOP VALUE' passing in a value (1-32), !!                          with optional message !!    pdec(3f)              write ASCII Decimal Equivalent (ADE) numbers !!                          vertically beneath string !!    debug                 logical variable that can be tested by routines !!                          as a flag to process debug statements. !! !!    For unit testing, the existence of a command called \"goodbad\" is !!    initially assumed. This is generally a script that makes entries !!    for each unit in an SQLite data file which is then used to create !!    CSV and HTML reports on the status of each unit. A sample goodbad(1) !!    command written in the bash(1) shell and using the sqlite3(1) command !!    should be included in this distribution as an example. !! !!    The flexibility introduced by calling an external script or program !!    is that The goodbad(1) command can be changed as desired to write CSV !!    files or simple logs or to notify developers with e-mail as desired. !! !!    RELATED FUNCTIONS !! !!    The routines in M_verify(3f) are often combined with the M_hashkeys(3fm) !!    routines and various math and statistical routines to quickly create !!    unit tests. !! !!    Comparisons of real values can be done with a tolerance with !!    M_Compare_Float_Numbers(3fm), for example. !! !!    The intrinsics ANY(3f) and ALL(3f) are particularly useful in calls !!    to unit_check(3f). !! !!##EXAMPLES !! !!   Sample program !! !!     !!program demo_unit_tests !!     module M_demo !!     private !!     public one !! regular routines !!     public two !! regular routines !!     public test_suite_M_demo !! special name for use with test_suite(1bash). !!     contains !! !!     !!  regular routines !!     subroutine one() !!     end subroutine one !! !!     subroutine two() !!     end subroutine two !! !!     !! unit test !!     subroutine test_suite_M_demo !!     use M_verify, only: unit_check_start, unit_check !!     use M_verify, only: unit_check_good, unit_check_bad, unit_check_done !!     use M_verify, only: unit_check_msg, unit_check_stop !!     implicit none !!     integer :: i, j, k !!     integer,allocatable :: array(:) !!     integer :: arr(4)=[21,51,14,45] !!     integer :: a=21, b=51, c=14, d=45 !!     ! TEST-DRIVEN DEVELOPMENT !!     ! optional set-up       perform initialization operations common to all tests within a module !!        i=1 !!        j=2 !!        k=3 !!        array=[10,20,30,40,50,60,70] !!        call test_one() !!        call test_two() !!     ! optional tear-down    perform finalization operations common to all tests within a module !!     contains !! !!     subroutine test_one() !!     !  register an entry for specified name (\"one\") in database with status of zero (0) !!     call unit_check_start('one') !! !!     !  if mask test fails, can !!     !  * produce a SUCCESS: or FAIL: message and stop program !!     !  * change database status for specified entry to -1 and stop program, else continue !!     !  * produce a SUCCESS: or FAIL: message and keep going !!     !  * produce a FAIL: message if test fails but no SUCCESS: message if test passes !!     call unit_check('one',i > 0,msg='I > 0') !! !!     ! using ANY(3f) and ALL(3f) !!     call unit_check('one',all([i,j,k] > 0),      'testing if everyone greater than zero') !!     ! display message built of scalars as well !!     call unit_check('one',all(.not.[i,j,k] == 4),'for set ',i,j,k,'testing if no one is equal to four') !! !!     ! for tests that are hard to reduce to a logical test just call unit_check_bad(3f) if fail !!     if(i+j+k < 1)then !!        call unit_check_bad('one') !!     endif !! !!     call unit_check_done('one','checks on \"one\" ended') !!     end subroutine test_one !! !!     subroutine test_two !!     ! use of all(3f), any(3f), merge(3f) can be useful !!     ! if you know what these would produce !!     ! write(*,*)['A','X','X','X','X','B'] == 'B'      ! this would return an array, the last element having the value T, else F !!     ! write(*,*)all(['A','X','X','X','X','X'] == 'X') ! this would return F !!     ! write(*,*)any(['A','X','X','X','X','X'] == 'B') ! this would return F !!     ! write(*,*)any(['A','X','X','X','X','B'] == 'B') ! this would return T !!     ! write(*,*).not.all(array < 100) !!     ! write(*,*)all(array < 100) !!     ! write(*,*)all([a,b,c,d] == [21,51,14,45]) ! compare a list. This would return T !!     ! write(*,*)all(arr == [21,51,14,45])       ! compare an array. This would return T !!     ! you know how valuable ANY(3f) and ALL(3f) will be !!     call unit_check_start('two','check on \"two\" passed') !!     call unit_check('two', 1 > 0 .and. abs(10.10000-10.10001) < 0.0001,msg='two looks good') !!     call unit_check_done('two','checks on \"two\" ended') !!     end subroutine test_two !! !!     end subroutine test_suite_M_demo !! !!     end module M_demo !! !!     program demo_M_verify !!     use M_demo,  only: test_suite_M_demo !!     use M_verify, only: unit_check_command, unit_check_keep_going,unit_check_level !!     unit_check_command='' !!     unit_check_keep_going=.true. !!     unit_check_level=0 !!       call test_suite_M_demo !!     end program demo_M_verify !! !!   Expected output: !! !!     unit_check:       one                  SUCCESS:I > 0 !!     unit_check:       one                  SUCCESS:testing if everyone greater than zero !!     unit_check:       one                  SUCCESS:for set 1 2 3 testing if no one is equal to four !!     unit_check_done:  one                  PASSED   GOOD:3  BAD:0 !! !!     unit_check:       two                  SUCCESS:two looks good !!     unit_check_done:  two                  PASSED   GOOD:1  BAD:0 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_verify use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 !  1           2           4           8 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 !  4           8          10 use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT ! access computing environment use :: M_msg , only : str implicit none private integer , save , public :: io_debug = ERROR_UNIT ! mutable copy of ERROR_UNIT, but initialized to the unit used for stderr integer , save , public :: unit_check_lun = ERROR_UNIT ! mutable copy of ERROR_UNIT, but initialized to the unit used for stderr logical , save , public :: debug = . false . character ( len = 20 ), save , public :: unit_check_prefix = '' logical , save , public :: unit_check_keep_going = . false . ! logical variable that can be used to turn off program termination on errors. integer , save , public :: unit_check_level = 0 ! a level that can be used to select different debug levels character ( len = 4096 ), public :: unit_check_command = '' ! name of command to execute. Defaults to the name \"goodbad\". public no_news_is_good_news integer , parameter , public :: realtime = kind ( 0.0d0 ) ! type for julian days integer , parameter , public :: EXIT_SUCCESS = 0 integer , parameter , public :: EXIT_FAILURE = 1 real ( kind = realtime ), save :: duration = 0.0d0 real ( kind = realtime ), save :: duration_all = 0.0d0 integer , save :: clicks = 0.0d0 integer , save :: clicks_all = 0.0d0 logical , save :: STOP_G = . true . ! global value indicating whether failed unit checks should stop program or not integer , save :: IPASSED_G = 0 ! counter of successes initialized by unit_check_start(3f) integer , save :: IFAILED_G = 0 ! counter of failures  initialized by unit_check_start(3f) integer , save :: IUNTESTED = 0 ! counter of untested  initialized by unit_check_start(3f) integer , save :: IPASSED_ALL_G = 0 ! counter of successes initialized at program start integer , save :: IFAILED_ALL_G = 0 ! counter of failures  initialized at program start integer , save :: IUNTESTED_ALL = 0 ! counter of untested  initialized at program start logical , save :: no_news_is_good_news = . false . ! flag on whether to display SUCCESS: messages public stderr public assert public pdec public fstop public unit_check_start public unit_check public unit_check_good public unit_check_bad public unit_check_done public unit_check_stop public unit_check_msg ! COMPARING AND ROUNDING FLOATING POINT VALUES public accdig ! compare two real numbers only up to a specified number of digits public almost ! function compares two numbers only up to a specified number of digits public dp_accdig ! compare two double numbers only up to a specified number of digits public in_margin ! check if two reals are approximately equal using a relative margin public round ! round val to specified number of significant digits public round_to_power ! round val to specified number of digits after the decimal point public significant ! round val to specified number of significant digits !----------------------------------------------------------------------------------------------------------------------------------- contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_check_msg(3f) - [M_verify] converts up to nine standard scalar values to a message for unit testing !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function unit_check_msg(name,g1,g2g3,g4,g5,g6,g7,g8,g9) !! !!     character(len=*),intent(in)  :: name !!     class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !!##DESCRIPTION !!    unit_check_msg(3f) builds a string from up to nine scalar values and !!    prints it to the error long. !! !!##OPTIONS !!    name    name of unit being tested !!    g[1-9]  optional value to print the value of after the message. May !!            be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!            or CHARACTER. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unit_check_msg !!    use M_verify, only : unit_check_start,unit_check_msg,unit_check_done !!    implicit none !! !!    call unit_check_start('myroutine') !!    call unit_check_msg('myroutine','HUGE(3f) integers',huge(0),'and real',huge(0.0),'and double',huge(0.0d0)) !!    call unit_check_msg('myroutine','real            :',huge(0.0),0.0,12345.6789,tiny(0.0) ) !!    call unit_check_msg('myroutine','doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) ) !!    call unit_check_msg('myroutine','complex         :',cmplx(huge(0.0),tiny(0.0)) ) !!    call unit_check_done('myroutine') !! !!    end program demo_unit_check_msg !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check_msg ( name , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 ) implicit none ! ident_1=\"@(#) M_verify unit_check_msg(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: name class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 class ( * ), intent ( in ), optional :: g6 , g7 , g8 , g9 ! write message to standard error call stderr ( trim ( unit_check_prefix ) // 'check_msg:   ' // atleast ( name , 20 ) // ' INFO    : ' // str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 )) end subroutine unit_check_msg !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== subroutine stderr ( msg , gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 ) implicit none ! ident_2=\"@(#) M_verify stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: msg class ( * ), intent ( in ), optional :: gen0 , gen1 , gen2 , gen3 , gen4 class ( * ), intent ( in ), optional :: gen5 , gen6 , gen7 , gen8 , gen9 integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( msg , gen0 , gen1 , gen2 , gen3 , gen4 , gen5 , gen6 , gen7 , gen8 , gen9 ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fstop(3f) - [M_verify] call stop with both a number and a message !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine fstop(ierr,stdout,stderr) !! !!     integer,intent(in)                   :: ierr !!     character(len=*),intent(in),optional :: stdout !!     character(len=*),intent(in),optional :: stderr !!##DESCRIPTION !!    FSTOP(3f) call STOP(3f). What a call to STOP does is very system !!    dependent, so using an abstraction layer is useful, as it allows just !!    the fstop() routine to be changed; and STOP does not allow a variable !!    to be used on the numeric access status (this has changed at f2015). !! !!##OPTIONS !!    ierr    - value in range 0 to 32 !!    stdout  - description to be printed to standard output !!    stderr  - description to be printed to standard error !!##EXAMPLES !! !!   Sample program: !! !!    program demo_fstop !!    use M_verify, only: fstop !!    implicit none !!    integer :: int !!    !*!write(*,*)'Enter stop value' !!    !*!read(*,*) int !!    int=25 !!    select case(int) !!    case(10) ; call fstop(int) !!    case(20) ; call fstop(int,stderr='error: program will now stop') !!    case(25) ; call fstop(int,stdout='stdout message',stderr='stderr message') !!    case(30) ; call fstop(int,stdout='error: program will now stop') !!    case default !!               call fstop(int) !!    endselect !! !!    end program demo_fstop !! !!   Results: !! !!##SEE ALSO !!   Look for common extensions, such as abort(3f), backtrace(3f) !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine fstop ( ierr , stdout , stderr ) ! ident_3=\"@(#) M_verify fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message\" integer , intent ( in ) :: ierr character ( len =* ), optional , intent ( in ) :: stdout character ( len =* ), optional , intent ( in ) :: stderr character ( len = 132 ) :: message ! The standard states: !   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the !   processor supports that concept. If the integer stop-code is used as the process exit status, the processor !   might be able to interpret only values within a limited range, or only a limited portion of the integer value !   (for example, only the least-significant 8 bits). !   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed, !   it is recommended that the value zero be supplied as the process exit status, if the processor supports that !   concept. !   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement. ! ! Conforming variants I have encountered include !    o printing a message such as 'STOP nnn' when the integer value is called !    o having a limit on the length of the message string passed !    o prefixing the message with the string 'STOP ' !    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument !      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...) !    o whether messages appear on stdout or stderr. !    o no value being returned to the system at all. ! !  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported. !  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated? ! !  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value. !  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system, !  but I sometimes want to return variables. ! !  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message !  to appear when using integer values ! !  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky !  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran !  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a !  value to the system and Fortran does not, but I do not recommend it. ! !  Note that the C function \"exit(int signal)\" not only works more consistently but that the global values EXIT_SUCCESS and !  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant. ! !  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure. !----------------------------------------------------------------------------------------------------------------------------------- !STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab' !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( stderr )) then ! write message to stderr, assuming string length is allowed if ( stderr /= '' ) then write ( error_unit , '(a)' ) trim ( stderr ) endif !f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED) !f2015!      case(0); allstop 0 !f2015!      case(1); allstop 1 !f2015!      case(2); allstop 2 !f2015!      case(3); allstop 3 !f2015!      case(4); allstop 4 !f2015!      case(5); allstop 5 !f2015!      case(6); allstop 6 !f2015!      case(7); allstop 7 !f2015!      case(8); allstop 8 !f2015!      case(9); allstop 8 !f2015!      case(10); allstop 10 !f2015!      case(11); allstop 11 !f2015!      case(12); allstop 12 !f2015!      case(13); allstop 13 !f2015!      case(14); allstop 14 !f2015!      case(15); allstop 15 !f2015!      case(16); allstop 16 !f2015!      case(17); allstop 17 !f2015!      case(18); allstop 18 !f2015!      case(19); allstop 19 !f2015!      case(20); allstop 20 !f2015!      case(21); allstop 21 !f2015!      case(22); allstop 22 !f2015!      case(23); allstop 23 !f2015!      case(24); allstop 24 !f2015!      case(25); allstop 25 !f2015!      case(26); allstop 26 !f2015!      case(27); allstop 27 !f2015!      case(28); allstop 28 !f2015!      case(29); allstop 29 !f2015!      case(30); allstop 30 !f2015!      case(31); allstop 31 !f2015!      case(32); allstop 32 !f2015!   case default !f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system' !f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error !f2015!      allstop 1 !f2015!   end select endif if ( present ( stdout )) then ! write message to stdout, assuming string length is allowed if ( stdout /= '' ) then write ( * , '(a)' ) trim ( stdout ) endif endif select case ( ierr ) ! have executable return an exit status to the system (IF SUPPORTED) case ( 0 ); stop 0 case ( 1 ); stop 1 case ( 2 ); stop 2 case ( 3 ); stop 3 case ( 4 ); stop 4 case ( 5 ); stop 5 case ( 6 ); stop 6 case ( 7 ); stop 7 case ( 8 ); stop 8 case ( 9 ); stop 8 case ( 10 ); stop 10 case ( 11 ); stop 11 case ( 12 ); stop 12 case ( 13 ); stop 13 case ( 14 ); stop 14 case ( 15 ); stop 15 case ( 16 ); stop 16 case ( 17 ); stop 17 case ( 18 ); stop 18 case ( 19 ); stop 19 case ( 20 ); stop 20 case ( 21 ); stop 21 case ( 22 ); stop 22 case ( 23 ); stop 23 case ( 24 ); stop 24 case ( 25 ); stop 25 case ( 26 ); stop 26 case ( 27 ); stop 27 case ( 28 ); stop 28 case ( 29 ); stop 29 case ( 30 ); stop 30 case ( 31 ); stop 31 case ( 32 ); stop 32 case default write ( message , '(a,i0,a)' ) '*fstop*: stop value of ' , ierr , ' returning 1 to system' write ( error_unit , '(a)' ) trim ( message ) ! write message to standard error stop 1 end select end subroutine fstop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_check(3f) - [M_verify] if logical expression is false, call command \"goodbad NAME bad\" and stop program by default !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check(name,expression,msg,msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9) !! !!     character(len=*),intent(in) :: name !!     logical,intent(in) :: expression !!     class(*),intent(in),optional :: msg,msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9 !! !!##DESCRIPTION !!    unit_check(3f) tests the expression and if it is false, calls the !!    shell command !! !!         goodbad NAME bad !! !!    and stops the program. !!##OPTIONS !!     NAME             the unit test name passed on to the goodbad(1) !!                      command !!     EXPRESSION       the logical expression to evaluate !!     MSG,MSG1...MSG9  optional message to display when performing test, !!                      composed of any scalar intrinsics of type INTEGER, !!                      REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or !!                      CHARACTER, with a space placed between each value. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_unit_check !!    use M_verify, only: unit_check !!    use M_verify, only: unit_check_start !!    use M_verify, only: unit_check_done !!    use M_verify,  only: almost !! !!    !!use M_verify, only: unit_check_keep_going         ! default is unit_check_keep_going=.false. !!    !!use M_verify, only: debug              ! default is .false. !!    !!use M_verify, only: unit_check_command ! default is unit_check_command=''; was 'goodbad' !! !!    implicit none !!    integer :: i !!    integer :: x !!    integer,allocatable :: arr(:) !!    real,allocatable :: arr1(:) !!    real,allocatable :: arr2(:) !! !!       !!unit_check_command='' !!       x=10 !!       arr1=[1.0,10.0,100.0] !!       arr2=[1.0001,10.001,100.01] !!       call unit_check_start('myroutine') !! !!       call unit_check('myroutine', x > 3 ,'test if big enough') !!       call unit_check('myroutine', x < 100 ,'test if small enough') !! !!       do i=1,size(arr1) !!          call unit_check('myroutine', almost(arr1(i),arr2(i),3.9,verbose=.true.) ) !!       enddo !! !!       arr=[10,20,30] !!       call unit_check('myroutine', .not.any(arr < 0) ,'test if any negative values in array ARR') !!       call unit_check('myroutine', all(arr < 100) ,'test if all values less than 100 in array ARR') !! !!       call unit_check_done('myroutine',msg='checks on \"myroutine\" all passed') !! !!    end program demo_unit_check !! !!   Sample output (varies with what goodbad(1) command is used): !! !!    unit_check:      myroutine        SUCCESS:test if big enough !!    unit_check:      myroutine        SUCCESS:test if small enough !!    unit_check:      myroutine        SUCCESS:test if any negative values in array ARR !!    unit_check:      myroutine        SUCCESS:test if all values less than 100 in array ARR !!     *almost* for values 1.00000000 1.00010002 agreement of 3.99997139 digits out of requested 3.90000010 !!     *almost* for values 10.0000000 10.0010004 agreement of 3.99986792 digits out of requested 3.90000010 !!     *almost* for values 100.000000 100.010002 agreement of 3.99995065 digits out of requested 3.90000010 !!    unit_check_good: myroutine        PASSED:checks on \"myroutine\" all passed !! !! !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check ( name , logical_expression , msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 ) ! ident_4=\"@(#) M_verify unit_check(3f) if .not.expression call 'goodbad NAME bad' & stop program\" character ( len =* ), intent ( in ) :: name logical , intent ( in ) :: logical_expression class ( * ), intent ( in ), optional :: msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 character ( len = :), allocatable :: msg_local !----------------------------------------------------------------------------------------------------------------------------------- msg_local = str ( msg , msg1 , msg2 , msg3 , msg4 , msg5 , msg6 , msg7 , msg8 , msg9 ) !----------------------------------------------------------------------------------------------------------------------------------- if (. not . logical_expression ) then call stderr ( trim ( unit_check_prefix ) // 'check:       ' // atleast ( name , 20 ) // ' FAILURE : ' // trim ( msg_local )) if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' bad' ) endif if (. not . unit_check_keep_going ) then call stderr ( trim ( unit_check_prefix ) // 'check:         STOPPING PROGRAM ON FAILED TEST OF ' // trim ( name )) call fstop ( 1 ) endif IFAILED_G = IFAILED_G + 1 IFAILED_ALL_G = IFAILED_ALL_G + 1 else if (. not . no_news_is_good_news ) then call stderr ( trim ( unit_check_prefix ) // 'check:       ' // atleast ( name , 20 ) // ' SUCCESS : ' // trim ( msg_local )) endif IPASSED_G = IPASSED_G + 1 IPASSED_ALL_G = IPASSED_ALL_G + 1 endif !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    unit_check_start(3f) - [M_verify] call command \"goodbad NAME start\" and optionally set options !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check_start(name,options,msg) !! !!     character(len=*),intent(in)          :: name !!     character(len=*),intent(in),optional :: options !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !!    unit_check_start(3f) is an initialization command that by default !!    calls the shell command !! !!       goodbad NAME start [options] !! !!    The command can be changed by setting the environment variable !!    UNIT_CHECK_COMMAND or the global module variable UNIT_CHECK_COMMAND. !!    The environment variable overrides the global module variable. !! !!    By default if a unit_check(3f) logical expression is false or the !!    unit_check_bad(3f) procedure is called the program will be stopped. !! !!    This has the same effect as setting the environment variable !!    M_verify_STOP to \"FALSE\" or the global module variable !!    UNIT_CHECK_KEEP_GOING to .FALSE. . Set the value to .true. and the !!    program will continue even when tests fail. !! !!##OPTIONS !!       NAME  name of the shell command to execute. If blank, no command !!             is executed. !!    OPTIONS  pass additional options to the shell command !! !!    MSG      print message !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_check_start !!     use M_verify, only: unit_check_start !!     use M_verify, only: unit_check !!     use M_verify, only: unit_check_done !! !!     implicit none !!     integer :: ival !!     call unit_check_start('myroutine') !!     ! the goodbad(1) command called here takes many options !!     ! used to build an SQLite3 entry !!     call unit_check_start('myroutine_long',' & !!       & -section        3                    & !!       & -library        libGPF               & !!       & -filename       `pwd`/M_verify.FF     & !!       & -documentation  y                    & !!       & -prep           y                    & !!       & -ccall          n                    & !!       & -archive        GPF.a                & !!       & ') !! !!     ival=10 !!     call unit_check('myroutine', ival > 3 ,   msg='test if big enough') !!     call unit_check('myroutine', ival < 100 , msg='test if small enough') !! !!     call unit_check_done('myroutine',msg='completed checks of \"myroutine\"') !! !!     end program demo_unit_check_start !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check_start ( name , options , msg ) ! ident_5=\"@(#) M_verify unit_check_start(3f) call 'goodbad NAME start'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: options character ( len =* ), intent ( in ), optional :: msg character ( len = 4096 ) :: var logical , save :: called = . false . !----------------------------------------------------------------------------------------------------------------------------------- call get_environment_variable ( 'UNIT_CHECK_COMMAND' , var ) if ( var /= '' ) unit_check_command = var !----------------------------------------------------------------------------------------------------------------------------------- if ( present ( options )) then if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' start ' // trim ( options )) endif else if ( unit_check_command /= '' ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' start' ) endif endif !----------------------------------------------------------------------------------------------------------------------------------- call system_clock ( clicks ) duration = julian () if (. not . called ) then call system_clock ( clicks_all ) duration_all = julian () called = . true . endif if ( present ( msg )) then if ( msg /= '' ) then call stderr ( trim ( unit_check_prefix ) // 'check_start: ' // atleast ( name , 20 ) // ' START   : ' // trim ( msg )) endif endif call get_environment_variable ( 'M_verify_STOP' , var ) select case ( var ) case ( 'FALSE' , 'false' , '1' , 'no' , 'NO' ) unit_check_keep_going = . false . end select !----------------------------------------------------------------------------------------------------------------------------------- IPASSED_G = 0 IFAILED_G = 0 IUNTESTED = 0 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_start !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_check_stop(3f) - [M_verify] call command \"goodbad NAME good\" or !!    goodbad NAME bad\" depending on whether failures were found !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check_stop(name,opts,msg) !! !!     character(len=*),intent(in) :: name !!     character(len=*),intent(in),optional :: opts !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !! !!     give a tally of all calls to unit_check(3f) !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_check_stop !!     use M_verify, only: unit_check_start, unit_check_done !!     use M_verify, only: unit_check !!     use M_verify, only: unit_check_good, unit_check_stop, unit_check_bad !!     use M_verify, only: unit_check_command, unit_check_keep_going, unit_check_level !! !!     implicit none !!     integer :: x !! !!     unit_check_command='' !!     unit_check_keep_going=.true. !!     unit_check_level=0 !! !!     x=10 !!     call unit_check_start('myroutine') !! !!     call unit_check('myroutine', x > 3 ,'test if big enough') !!     call unit_check('myroutine', x < 100 ,'test if small enough') !! !!     if(x /= 0)then !!        call unit_check_bad  ('myroutine',msg='x /= 0' ) !!     endif !!     call unit_check_done  ('myroutine',msg='checks on \"myroutine\"' ) !! !!     call unit_check_stop() !!     end program demo_unit_check_stop !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check_stop ( msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_6=\"@(#) M_verify unit_check_stop(3f) stop program with report on calls to unit_check(3f)\" character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = 4096 ) :: out character ( len = :), allocatable :: PF integer ( kind = int64 ) :: milliseconds integer :: clicks_now if ( present ( msg )) then msg_local = msg else msg_local = '' endif call system_clock ( clicks_now ) milliseconds = ( julian () - duration_all ) * 1000 milliseconds = clicks_now - clicks_all PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_all_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_all_G == 0 ) then PF = 'UNTESTED:' endif write ( out , '(a,                               & & \"check_stop:  TALLY                \",a,& & \" GOOD:\",i9,                           & & \" BAD:\",i9,                            & & \" DURATION:\",i14.14                    & & )' ) & & trim ( unit_check_prefix ), & & PF , & & IPASSED_ALL_G , & & IFAILED_ALL_G , & & milliseconds if ( present ( msg )) then call stderr ( trim ( out ) // ': ' // trim ( msg )) else call stderr ( out ) endif if ( IFAILED_ALL_G == 0 ) then stop EXIT_SUCCESS else stop EXIT_FAILURE endif end subroutine unit_check_stop !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_check_done(3f) - [M_verify] call command \"goodbad NAME good\" or \"goodbad NAME bad\" depending on whether failures were found !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check_done(name,opts,msg) !! !!     character(len=*),intent(in) :: name !!     character(len=*),intent(in),optional :: opts !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !! !!    If there have been no failures the shell command !! !!         goodbad NAME good [opts] !! !!    is executed, else the command !! !!         goodbad NAME bad [opts] !! !!    is executed and by default stops the program if their have been !!    any failures. !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_check_done !!     use M_verify, only: unit_check_start !!     use M_verify, only: unit_check !!     use M_verify, only: unit_check_good, unit_check_done, unit_check_bad !! !!     implicit none !!     integer :: x !!     x=10 !!     call unit_check_start('myroutine') !! !!     call unit_check('myroutine', x > 3 ,'test if big enough') !!     call unit_check('myroutine', x < 100 ,'test if small enough') !! !!     if(x /= 0)then !!        call unit_check_done ('myroutine',msg='checks on \"myroutine\"' ) ! program execution stopped !!     endif !! !!     end program demo_unit_check_done !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check_done ( name , opts , msg ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 ! ident_7=\"@(#) M_verify unit_check_done(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local character ( len = 4096 ) :: out character ( len = 9 ) :: pf integer ( kind = int64 ) :: milliseconds integer :: clicks_now if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif !----------------------------------------------------------------------------------------------------------------------------------- if ( unit_check_command /= '' ) then ! if system command name is not blank call system command if ( ifailed_g == 0 ) then call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' bad ' // trim ( opts )) if (. not . unit_check_keep_going ) call fstop ( 1 ) ! stop program depending on mode else call execute_command_line ( unit_check_command // ' ' // trim ( name ) // ' good ' // trim ( opts )) endif endif !----------------------------------------------------------------------------------------------------------------------------------- PF = merge ( 'PASSED  :' , 'FAILED  :' , ifailed_G == 0 ) if ( PF == 'PASSED  :' . and . ipassed_G == 0 ) then PF = 'UNTESTED:' endif if ( duration /= 0.0d0 ) then call system_clock ( clicks_now ) milliseconds = ( julian () - duration ) * 1000 milliseconds = clicks_now - clicks write ( out , '(a,\"check_done:  \",a,    & & 1x,a,                            & & \" GOOD:\",i9,                     & & \" BAD:\",i9,                      & & \" DURATION:\",i14.14              & & )' ) & & trim ( unit_check_prefix ), & & atleast ( name , 20 ), & & PF , & & IPASSED_G , & & IFAILED_G , & & milliseconds else write ( out , '(a,\"check_done:  \",a,1x,a,\" GOOD:\",i0,1x,\" BAD:\",i0)' ) & & trim ( unit_check_prefix ), atleast ( name , 20 ), PF , IPASSED_G , IFAILED_G endif if ( present ( msg )) then call stderr ( trim ( out ) // ': ' // trim ( msg )) else call stderr ( out ) endif !----------------------------------------------------------------------------------------------------------------------------------- IPASSED_G = 0 IFAILED_G = 0 IUNTESTED = 0 duration = 0.0d0 !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_done !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_check_bad(3f) - [M_verify] call command \"goodbad NAME bad\" and stop program !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check_bad(name,opts,msg) !! !!     character(len=*),intent(in) :: name !!     character(len=*),intent(in),optional :: opts !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !! !!    unit_check_bad(3f) calls the shell command !! !!         goodbad NAME bad [opts] !! !!    and stops the program. It is just a shortcut for calling !!         call unit_check(name,.false.) !!         call unit_check_done(name,opts,msg) !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_check_bad !!     use M_verify, only: unit_check_start !!     use M_verify, only: unit_check !!     use M_verify, only: unit_check_good, unit_check_bad !! !!     implicit none !!     integer :: x !!     x=10 !!     call unit_check_start('myroutine') !! !!     call unit_check('myroutine', x > 3 ,'test if big enough') !!     call unit_check('myroutine', x < 100 ,'test if small enough') !! !!     if(x /= 0)then !!        call unit_check_bad ('myroutine',msg='checks on \"myroutine\" failed') ! program execution stopped !!     endif !! !!     end program demo_unit_check_bad !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine unit_check_bad ( name , opts , msg ) ! ident_8=\"@(#) M_verify unit_check_bad(3f) call 'goodbad NAME bad'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_check ( name ,. false .) call unit_check_done ( name , opts_local , msg_local ) end subroutine unit_check_bad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!    unit_check_good(3f) - [M_verify] call command \"goodbad NAME good\" !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    subroutine unit_check_good(name,opts,msg) !! !!     character(len=*),intent(in)          :: name !!     character(len=*),intent(in),optional :: opts !!     character(len=*),intent(in),optional :: msg !! !!##DESCRIPTION !!    A shortcut for !! !!       call unit_check(name,.true.) !!       call unit_check_done(name,opts,msg) !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_unit_check_good !!     use M_verify, only: unit_check_start, unit_check_done !!     use M_verify, only: unit_check !!     use M_verify, only: unit_check_good, unit_check_bad !! !!     implicit none !!     integer :: x !!     x=10 !!     call unit_check_start('myroutine') !! !!     call unit_check('myroutine', x > 3 ,'test if big enough') !!     call unit_check('myroutine', x < 100 ,'test if small enough') !! !!     call unit_check_good('myroutine',msg='checks on \"myroutine\" ') !! !!     end program demo_unit_check_good !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine unit_check_good ( name , opts , msg ) ! ident_9=\"@(#) M_verify unit_check_good(3f) call 'goodbad NAME good'\" character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: opts character ( len =* ), intent ( in ), optional :: msg character ( len = :), allocatable :: msg_local character ( len = :), allocatable :: opts_local if ( present ( msg )) then msg_local = msg else msg_local = '' endif if ( present ( opts )) then opts_local = opts else opts_local = '' endif call unit_check ( name ,. true ., msg = msg_local ) call unit_check_done ( name , opts_local ) !----------------------------------------------------------------------------------------------------------------------------------- end subroutine unit_check_good !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!      pdec(3f) - [M_verify] write out string with ASCII decimal equivalent vertically under it !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!    Usage: !! !!     subroutine pdec(string) !!     character(len=*),intent(in) :: string !! !!##DESCRIPTION !! !!    Given a string to print, PDEC() writes out the ASCII Decimal equivalent !!    of the string directly underneath it. This can help you to locate !!    unprintable characters or non-standard white-space such as a backspace !!    character or tab character in input strings that your program could !!    not interpret. On output, non-printable characters are replaced with !!    a space, and trailing spaces are ignored. !! !!    You read the numbers vertically. !! !!    1. ignore trailing spaces !!    2. print the character if it has an ADE of 32 on up !!    3. print a space if it has an ADE of less than 32 !!    4. underneath each character print the ADE value vertically !!    5. strings are assumed under 32767 characters in length. !!       Format integer constants > 32767 are not supported on HP-UX !!       when newer compilers are available use unlimited !! !!##EXAMPLES !! !! !!    Sample program: !! !!       program demo_pdec !!       use M_verify, only : pdec !!       call pdec(' ABCDEFG abcdefg    ') !!       end program demo_pdec !! !!    would produce (notice trailing space is trimmed): !! !!      > ABCDEFG abcdefg !!      >0000000000001111 !!      >3666667739990000 !!      >2567890127890123 !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine pdec ( string ) ! ident_10=\"@(#) M_verify pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string\" character ( len =* ), intent ( in ) :: string ! the string to print integer :: ilen ! number of characters in string to print integer :: i ! counter used to step thru string !----------------------------------------------------------------------------------------------------------------------------------- ilen = len_trim ( string (: len ( string ))) ! get trimmed length of input string write ( * , 101 )( char ( max ( 32 , ichar ( string ( i : i )))), i = 1 , ilen ) ! replace lower unprintable characters with spaces ! print ADE value of character underneath it write ( * , 202 ) ( ichar ( string ( i : i )) / 100 , i = 1 , ilen ) write ( * , 202 )( mod ( ichar ( string ( i : i )), 100 ) / 10 , i = 1 , ilen ) write ( * , 202 )( mod (( ichar ( string ( i : i ))), 10 ), i = 1 , ilen ) 101 format ( 32767 a1 :) ! format for printing string characters 202 format ( 32767 i1 :) ! format for printing ADE values end subroutine pdec !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function atleast ( line , length ) result ( strout ) ! ident_11=\"@(#) M_verify atleast(3fp) return string padded to at least specified length\" character ( len =* ), intent ( in ) :: line integer , intent ( in ) :: length character ( len = max ( length , len ( trim ( line )))) :: strout strout = line end function atleast !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    assert(3f) - [M_verify] print filename, linenumber, and message to stderr and stop program !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function assert(file,linenum,expr,g1,g2g3,g4,g5,g6,g7,g8,g9) !! !!     character(len=*),intent(in)  :: file !!     character(len=*),intent(in)  :: linenum !!     logical,intent(in)           :: expr !!     class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9 !!##DESCRIPTION !!    assert(3f) prints strings to stderr and then stops program with exit !!    code 1 It labels the first string as the filename, the next integer !!    parameter as the linenumber, and then up to nine scalar values. !! !!    It is primarily intended for use by the prep(1) preprocessor $ASSERT !!    directive !! !!##OPTIONS !! !!    filename   a string assumed to be the current filename when compiling !!    linenum    assumed to be the line number of the source code the ASSERT(3f) !!               procedure was called at. !!    expr       logical value !!    g[1-9]  optional value(s) to print as a message before stopping. May !!            be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!            or CHARACTER. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_assert !!    use M_verify, only : assert !!    implicit none !!    real :: a, toobig=1024 !!    a=2000 !!    call assert('myroutine', 101, a > toobig, 'The value is too large', a, ' > ', toobig) !!    end program demo_assert !! !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain subroutine assert ( filename , linen , expr , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 ) implicit none ! ident_12=\"@(#) M_verify assert(3f) writes a message to a string composed of any standard scalar types\" character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: linen logical , intent ( in ) :: expr class ( * ), intent ( in ), optional :: g1 , g2 , g3 , g4 , g5 class ( * ), intent ( in ), optional :: g6 , g7 , g8 , g9 ! write message to standard error if (. not . expr ) then call stderr ( 'ERROR:filename:' , filename , ':line number:' , linen , ':' , str ( g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 )) stop 1 endif end subroutine assert !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function julian () ! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19 ! ident_13=\"@(#) M_verify julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date\" real ( kind = realtime ) :: julian ! Julian Date (non-negative, but may be non-integer) integer :: dat ( 8 ) ! array like returned by DATE_AND_TIME(3f) integer :: year , month , day , utc , hour , minute real ( kind = realtime ) :: second integer :: A , Y , M , JDN call date_and_time ( values = dat ) year = dat ( 1 ) ! Year month = dat ( 2 ) ! Month day = dat ( 3 ) ! Day utc = dat ( 4 ) * 60 ! Delta from UTC, convert from minutes to seconds hour = dat ( 5 ) ! Hour minute = dat ( 6 ) ! Minute second = dat ( 7 ) - utc + dat ( 8 ) / 100 0.0d0 ! Second   ! correction for time zone and milliseconds !  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC) A = ( 14 - month ) / 12 ! A will be 1 for January or February, and 0 for other months, with integer truncation Y = year + 4800 - A M = month + 12 * A - 3 ! M will be 0 for March and 11 for February !  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year \"-1\", etc. !  Convert to a negative number, then increment towards zero !  Staring from a Gregorian calendar date JDN = day + ( 153 * M + 2 ) / 5 + 365 * Y + Y / 4 - Y / 100 + Y / 400 - 32045 !  with integer truncation !  Finding the Julian Calendar date given the JDN (Julian day number) and time of day julian = JDN + dble ( hour - 12 ) / 2 4.0d0 + dble ( minute ) / 144 0.0d0 + second / 8640 0.0d0 end function julian !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    almost(3f) - [M_verify] return true or false if two numbers agree up to specified number of digits !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function almost(x,y,digits) !! !!     class(*),intent(in)         :: x,y !!     class(*),intent(in)         :: rdigits !!     logical,intent(in),optional :: verbose !!     logical                     :: almost !! !!##DESCRIPTION !!    Returns true or false depending on whether the two numbers given agree !!    to within the specified number of digits as calculated by ACCDIG(3f). !!##OPTIONS !!    x,y      expected and calculated values to be compared. May be of !!             type REAL, INTEGER, or DOUBLEPRECISION. !!    rdigits  real number representing number of digits of precision !!             to compare !!    verbose  optional value that specifies to print the results of the !!             comparison when set to .TRUE.. !!##RETURNS !!    almost   TRUE if the input values compare up to the specified number !!             of values !!##EXAMPLE !! !!   sample: !! !!    program demo_almost !!    use M_verify, only : almost !!    implicit none !!    real    :: x, y !!    logical :: z !!    integer :: i !!    x=1.2345678 !!    y=1.2300000 !!    do i=1,8 !!       z=almost(x,y,real(i),verbose=.true.) !!       write(*,*)i,z !!    enddo !!    end program demo_almost !! !!   output: !! !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 1.0 !!            1   T !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 2.0 !!            2   T !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 3.0 !!            3   F !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 4.0 !!            4   F !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 5.0 !!            5   F !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 6.0 !!            6   F !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 7.0 !!            7   F !!     *accdig* significant digit request too high= 8.00000000 !!     *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 digits out of requested 8.0 !!            8   F !!##AUTHOR !!    John S. Urban !!##LICENSE !!    Public Domain function almost ( x , y , digits , verbose ) use M_journal , only : journal ! ident_14=\"@(#) M_verify almost(3f) function to compare two real numbers only up to a specified number of digits by calling DP_ACCDIG(3f)\" class ( * ), intent ( in ) :: x , y class ( * ), intent ( in ) :: digits logical , intent ( in ), optional :: verbose logical :: almost logical :: verbose_local real :: acurcy real :: digits_local integer :: ind if ( present ( verbose )) then verbose_local = verbose else verbose_local = . false . endif digits_local = anyscalar_to_realbig ( digits ) acurcy = 0.0 select type ( x ) type is ( real ) select type ( y ) type is ( real ) call accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif class default call dp_accdig ( x , y , digits_local , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select class default call dp_accdig ( x , y , digits , acurcy , ind ) if ( verbose_local ) then call journal ( 'sc' , '*almost*' , 'for values' , x , y , 'agreement of' , acurcy , 'digits out of requested' , digits_local ) endif end select if ( ind == 0 ) then almost = . true . else almost = . false . endif end function almost !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!      accdig(3f) - [M_verify] compare two real numbers only up to a specified number of digits !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       subroutine accdig(x,y,digio,acurcy,ind) !! !!        real,intent(in)     :: X !!        real,intent(in)     :: Y !!        real,intent(in)     :: DIGI0 !!        real,intent(out)    :: acurcy !!        integer,intent(out) :: ind !! !!##DESCRIPTION !!    This procedure is used to check how closely two numbers agree. !! !!       call accdig(X,Y,DIGI0,ACURCY,IND) !! !!    The values X and Y are the numbers to compare, and DIGI0 is the !!    threshold number of digits to consider significant in returning IND. !! !!    If X and Y are considered equal within DIGI0 relative tolerance, !! !!        IND    = 0, if tolerance is     satisfied. !!               = 1, if tolerance is not satisfied. !! !!    The result ACURCY gives a measure of the number of leading digits in X !!    which are the same as the number of leading digits in Y. !! !!            ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0 !!            ACURCY=-log10(X-Y)       if X != Y and Y = 0 !!            ACURCY=8                 if X=Y !! !!            ACURCY is never less than -8 or greater than 8 !! !!    TOLERANCE ... !!         X and Y are considered equal within DIGI0 relative tolerance, !!         if ACURCY is greater than DIGI0. !! !!    For example, Take some numbers and compare then  to 1.2345678 ... !! !!       ================================================ !!       A number     |    ACURCY       |   ACURCY !!                    |    1.2345678=Y  |   1.2345678=X !!       ================================================ !!        1.234680    |    3.7900571    |   3.7901275 !!        1.2345378   |    4.6144510    |   4.6144404 !!        2.2234568   |    0.096367393  |   0.35188114 !!        1.2345678   |    8.0000000    |   8.0000000 !!        1.2345679   |    7.0732967    |   7.0731968 !!       -1.2345678   |   -0.30103000   |  -0.30103000 !!       76.234567    |   -1.7835463    |   0.0070906729 !!        2.4691356   |    0.0          |   0.3010300 !!        0.0         |    0.0          |  -0.91514942. !! !!    Due to the typical limits of the log function, the number of !!    significant digits in the result is best considered to be three. !! !!    Notice that 1.2345678=Y produces different values than 1.2345678=X !! !!    A negative result indicates the two values being compared either do !!    not agree in the first digit or they differ with respect to sign. An !!    example of two numbers which do not agree in their leading digit (and !!    actually differ in order of magnitude) is given above by X=76.234567 !!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of !!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678; !!    here the accuracy reported is -0.30103000. !! !!##EXAMPLE !! !! !!   Example program: !! !!    program demo_accdig ! fortran 90 example !!    use M_verify, only : accdig !!    implicit none !!    integer :: digi !!    integer :: i10, i20, i30 !!    integer :: ind, ind1, ind2 !!    real    :: acurcy, acurcy1, acurcy2 !!    real    :: a, b !!    real    :: vals(9) !!    data vals/ & !!      &1.234680,   1.2345378,  2.2234568, 1.2345678, & !!      &1.2345679, -1.2345678, 76.234567,  2.4691356, & !!      &0.0/ !!       write(*,*)'=========================' !!       do i10=0,16 !!          a=1.0 !!          b=a+1.0/(10**i10) !!          call accdig(a,b,8.0,acurcy,ind) !!          write(*,*)i10,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       digi=16 !!       do i20=0,digi !!          a=1.0 !!          b=a+1.0/(10**i20) !!          call accdig(a,b,real(digi),acurcy,ind) !!          write(*,*)i20,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       do i30=1,9 !!          call accdig(1.2345678,vals(i30),8.0,acurcy1,ind1) !!          call accdig(vals(i30),1.2345678,8.0,acurcy2,ind2) !!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2 !!       enddo !!    end program demo_accdig !! !!##REFERENCES !! !!   based on ... !! !!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. accdig V 7.00  2/14/90. ** !!       David Hogben, !!       Statistical Engineering Division, !!       Center for Computing and Applied Mathematics, !!       A337 Administration Building, !!       National Institute of Standards and Technology, !!       Gaithersburg, MD 20899 !!                      TELEPHONE 301-975-2845 !!           ORIGINAL VERSION -  October, 1969. !!            CURRENT VERSION - February, 1990. !!            JSU     VERSION - February, 1991. !! !!##DEPENDENCIES !!    o M_journal(),log10(), abs(1) !! !!##AUTHOR !!    David Hogben, John S. Urban !! !!##LICENSE !!    Public Domain !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- SUBROUTINE accdig ( X , Y , digi0 , ACURCY , IND ) use M_journal , only : journal implicit none ! ident_15=\"@(#) M_verify accdig(3f) compare two real numbers only up to a specified number of digits\" !     INPUT ... real , intent ( in ) :: x ! First  of two real numbers to be compared. real , intent ( in ) :: y ! Second of two real numbers to be compared. real , intent ( in ) :: digi0 ! Number of digits to be satisfied in relative tolerance. !     OUTPUT ... integer , intent ( out ) :: ind ! = 0, If tolerance is     satisfied. ! = 1, If tolerance is not satisfied. real , intent ( out ) :: acurcy ! = - LOG10(ABS((X-Y)/Y))) real :: diff real :: digi integer :: ireal_significant_digits !----------------------------------------------------------------------------------------------------------------------------------- ireal_significant_digits = int ( log10 ( 2. ** digits ( 0.0 ))) ! maximum number of significant digits in a real number. digi = digi0 if ( digi <= 0 ) then call journal ( 'sc' , '*accdig* bad number of significant digits=' , digi ) digi = ireal_significant_digits elseif ( digi > ireal_significant_digits ) then call journal ( 'sc' , '*accdig* significant digit request too high=' , digi ) digi = min ( digi , real ( ireal_significant_digits )) endif !----------------------------------------------------------------------------------------------------------------------------------- diff = x - y if ( diff == 0.0 ) then acurcy = digi elseif ( y == 0.0 ) then acurcy = - log10 ( abs ( x )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y )) endif !----------------------------------------------------------------------------------------------------------------------------------- if ( acurcy < digi ) then ind = 1 else ind = 0 endif !----------------------------------------------------------------------------------------------------------------------------------- END SUBROUTINE accdig !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!      dp_accdig(3f) - [M_verify] compare two numbers only up to a specified number of digits !!      (LICENSE:PD) !! !!##SYNOPSIS !! !!       subroutine dp_accdig(x,y,digio,acurcy,ind) !! !!        class(*),intent(in)  :: X !!        class(*),intent(in)  :: Y !!        class(*),intent(in)  :: DIGI0 !!        real,intent(out)     :: acurcy !!        integer,intent(out)  :: ind !! !!##DESCRIPTION !! !!    This procedure is used to check how closely two numbers agree. !! !!       call dp_accdig(X,Y,DIGI0,ACURCY,IND) !! !!    The values X and Y are the numbers to compare, and DIGI0 is the !!    threshold number of digits to consider significant in returning IND. !! !!    If X and Y are considered equal within DIGI0 relative tolerance, !! !!        IND    = 0, if tolerance is     satisfied. !!               = 1, if tolerance is not satisfied. !! !!    The result ACURCY gives a measure of the number of leading digits in X !!    which are the same as the number of leading digits in Y. !! !!         ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0 !!         ACURCY=-log10(X-Y)       if X != Y and Y = 0 !!         ACURCY=8                 if X=Y !! !!         ACURCY is never less than -8 or greater than 8 for REAL values !! !!    TOLERANCE ... !!         X and Y are considered equal within DIGI0 relative tolerance, !!         if ACURCY is greater than DIGI0. !! !!    For example, Take some numbers and compare then  to 1.2345678 ... !! !!       ================================================ !!       A number     |    ACURCY       |   ACURCY !!                    |    1.2345678=Y  |   1.2345678=X !!       ================================================ !!        1.234680    |    3.7900571    |   3.7901275 !!        1.2345378   |    4.6144510    |   4.6144404 !!        2.2234568   |    0.096367393  |   0.35188114 !!        1.2345678   |    8.0000000    |   8.0000000 !!        1.2345679   |    7.0732967    |   7.0731968 !!       -1.2345678   |   -0.30103000   |  -0.30103000 !!       76.234567    |   -1.7835463    |   0.0070906729 !!        2.4691356   |    0.0          |   0.3010300 !!        0.0         |    0.0          |  -0.91514942. !! !!    Due to the typical limits of the log function, the number of !!    significant digits in the result is best considered to be three. !! !!    Notice that 1.2345678=Y produces different values than 1.2345678=X !! !!    A negative result indicates the two values being compared either do !!    not agree in the first digit or they differ with respect to sign. An !!    example of two numbers which do not agree in their leading digit (and !!    actually differ in order of magnitude) is given above by X=76.234567 !!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of !!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678; !!    here the accuracy reported is -0.30103000. !! !!##EXAMPLE !! !! !!   Example program: !! !!    program demo_dp_accdig ! fortran 90 example !!    use M_verify, only : dp_accdig !!    implicit none !!    integer         :: digi !!    doubleprecision :: a, b !!    integer         :: i10, i20, i30 !!    integer         :: ind, ind1, ind2 !!    real            :: acurcy, acurcy1, acurcy2 !!    doubleprecision :: vals(9) !!    data vals/ & !!      &1.234680d0,   1.2345378d0,  2.2234568d0, 1.2345678d0, & !!      &1.2345679d0, -1.2345678d0, 76.234567d0,  2.4691356d0, & !!      &0.0d0/ !!       write(*,*)'=========================' !!       do i10=0,16 !!          a=1.0d0 !!          b=a+1.0d0/(10**i10) !!          call dp_accdig(a,b,8.0,acurcy,ind) !!          write(*,*)i10,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       digi=16 !!       do i20=0,digi !!          a=1.0d0 !!          b=a+1.0d0/(10**i20) !!          call dp_accdig(a,b,dble(digi),acurcy,ind) !!          write(*,*)i20,a,b,acurcy,ind !!       enddo !!       write(*,*)'=========================' !!       do i30=1,9 !!          call dp_accdig(1.2345678d0,vals(i30),8.0,acurcy1,ind1) !!          call dp_accdig(vals(i30),1.2345678d0,8.0,acurcy2,ind2) !!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2 !!       enddo !!    end program demo_dp_accdig !! !!##NOTES !!##REFERENCES !! !!   based on ... !! !!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. ** !!       David Hogben, !!       Statistical Engineering Division, !!       Center for Computing and Applied Mathematics, !!       A337 Administration Building, !!       National Institute of Standards and Technology, !!       Gaithersburg, MD 20899 !!                      TELEPHONE 301-975-2845 !!           ORIGINAL VERSION -  October, 1969. !!            CURRENT VERSION - February, 1990. !!            JSU     VERSION - February, 1991. !! !!##DEPENDENCIES !!         o M_journal(), log10(), abs(1) !! !!##AUTHORS !!      David Hogben, John S. Urban !! !!##LICENSE !!      Public Domain !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- SUBROUTINE dp_accdig ( x , y , digi0 , ACURCY , IND ) #ifdef __NVCOMPILER use , intrinsic :: iso_fortran_env , only : wp => real64 #else use , intrinsic :: iso_fortran_env , only : wp => real128 #endif use M_journal , only : journal implicit none ! ident_16=\"@(#) M_verify dp_accdig(3f) compare two values only up to a specified number of digits\" !  INPUT ... class ( * ), intent ( in ) :: x ! FIRST  OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: y ! SECOND OF TWO NUMBERS TO BE COMPARED. class ( * ), intent ( in ) :: digi0 ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE. real ( kind = wp ) :: x_local real ( kind = wp ) :: y_local !  OUTPUT ... integer , intent ( out ) :: ind ! = 0, IF TOLERANCE IS     SATISFIED. ! = 1, IF TOLERANCE IS NOT SATISFIED. real , intent ( out ) :: acurcy ! = - LOG10(ABS((x_local-y_local)/y_local))) real ( kind = wp ) :: diff real ( kind = wp ) :: digi integer :: idble_significant_digits !----------------------------------------------------------------------------------------------------------------------------------- x_local = anyscalar_to_realbig ( x ) y_local = anyscalar_to_realbig ( y ) digi = anyscalar_to_realbig ( digi0 ) !----------------------------------------------------------------------------------------------------------------------------------- idble_significant_digits = int ( log10 ( 2.0_wp ** digits ( 0.0_wp ))) ! MAXIMUM NUMBER OF SIGNIFICANT DIGITS IN A REAL128 NUMBER. if ( digi <= 0 ) then call journal ( 'sc' , '*dp_accdig* bad number of significant digits=' , real ( digi , kind = wp )) digi = idble_significant_digits elseif ( digi > idble_significant_digits ) then call journal ( 'sc' , '*dp_accdig* significant digit request too high=' , real ( digi , kind = wp )) digi = min ( digi , real ( idble_significant_digits , kind = wp )) endif diff = x_local - y_local if ( diff == 0.0_wp ) then acurcy = digi elseif ( y_local == 0.0_wp ) then acurcy = - log10 ( abs ( x_local )) else acurcy = - log10 ( abs ( diff )) + log10 ( abs ( y_local )) endif if ( acurcy < digi ) then ind = 1 else ind = 0 endif end subroutine dp_accdig !----------------------------------------------------------------------------------------------------------------------------------- !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !----------------------------------------------------------------------------------------------------------------------------------- !> !!##NAME !!   in_margin(3f) - [M_verify] check if two reals are approximately equal using a relative margin !! !!##SYNOPSIS !! !!     elemental pure function in_margin( expected_value, measured_value, allowed_margin ) !! !!      real, intent(in)    :: expected_value !!      real, intent(in)    :: measured_value !!      real, intent(in)    :: allowed_margin !!      class(*),intent(in) :: invalue !! !!##DESCRIPTION !!   Compare two values to see if they are relatively equal using the !!   specified allowed margin. That is, see if VALUE_MEASURED is in !!   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error !!   varies with the magnitude of the values, such that the allowed error !!   is margin * average magnitude of measured and expected). !! !!   So the allowed error is smaller when the magnitudes are smaller. !! !!##OPTIONS !!   expected_value   First value !!   measured_value   Second value !!   allowed_margin   Allowed relative margin !! !!##EXAMPLE !! !!   Sample program: !! !!    program demo_in_margin !!    use :: M_verify, only : in_margin !!    implicit none !!    write(*,*) in_margin(4.00000,3.99999,0.000000001) !!    write(*,*) in_margin(4.00000,3.99999,0.00000001) !!    write(*,*) in_margin(4.00000,3.99999,0.0000001) !!    write(*,*) in_margin(4.00000,3.99999,0.000001) !! !!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], [3.9,39.9,399.9,3999.9,39999.9] ,0.000001) !!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], [3.9,39.9,399.9,3999.9,39999.9] ,0.00001) !! !!    write(*,*) in_margin(4.00000,3.99999,0.00001) !!    write(*,*) in_margin(4.00000,3.99999,0.0001) !!    write(*,*) in_margin(4.00000,3.99999,0.001) !!    write(*,*) in_margin(4.00000,3.99999,0.01) !! !!    end program demo_in_margin !! !!   Results: !! !!     F !!     F !!     F !!     F !!     F F F F F !!     F F F F T !!     T !!     T !!     T !!     T !=================================================================================================================================== elemental impure function in_margin ( expected_value , measured_value , allowed_margin ) implicit none ! ident_17=\"@(#) M_verify in_margin(3f) check if two reals are approximately equal using a relative margin\" class ( * ), intent ( in ) :: expected_value , measured_value , allowed_margin logical :: in_margin doubleprecision :: expected , measured , margin expected = anyscalar_to_double ( expected_value ) measured = anyscalar_to_double ( measured_value ) margin = anyscalar_to_double ( allowed_margin ) if ( abs ( expected - measured ) > 0.50d0 * margin * ( abs ( expected ) + abs ( measured )) ) then in_margin = . false . ! values not comparable else in_margin = . true . ! values comparable endif end function in_margin !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function round_to_power ( val , n ) ! ident_18=\"@(#) M_verify round_to_power(3f) round val to specified given decimal (power) position\" real , intent ( in ) :: val integer , intent ( in ) :: n real :: round_to_power round_to_power = anint ( val * 1 0.0 ** n ) / 1 0.0 ** n end function round_to_power !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function round ( val , idigits0 ) implicit none ! ident_19=\"@(#) M_verify round(3f) round val to specified number of significant digits\" integer , parameter :: dp = kind ( 0.0d0 ) real ( kind = dp ), intent ( in ) :: val integer , intent ( in ) :: idigits0 integer :: idigits , ipow real ( kind = dp ) :: aval , rnormal real ( kind = dp ) :: round !  this does not work very well because of round-off errors. !  Make a better one, probably have to use machine-dependent bit shifting ! make sure a reasonable number of digits has been requested idigits = max ( 1 , idigits0 ) aval = abs ( val ) !  select a power that will normalize the number !  (put it in the range 1 > abs(val) <= 0) if ( aval >= 1 ) then ipow = int ( log10 ( aval ) + 1 ) else ipow = int ( log10 ( aval )) endif rnormal = val / ( 1 0.0d0 ** ipow ) if ( rnormal == 1 ) then ipow = ipow + 1 endif !normalize, multiply by 10*idigits to an integer, and so on round = real ( anint ( val * 1 0.d0 ** ( idigits - ipow ))) * 1 0.d0 ** ( ipow - idigits ) end function round !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   significant(3f) - [M_verify] round val to specified number of significant digits !! !!##SYNOPSIS !! !!     pure elemental function significant(val,digits,round) !! !!      real,intent(in)                      :: val !!      integer,intent(in)                   :: digits !!      character(len=*),intent(in),optional :: round !!      real                                 :: significant !! !!##DESCRIPTION !! !! Round real value to specified number of significant digits !! !! val     value to round !! digits  number of significant digits to produce !! round   Use the round edit descriptor !! !!           RU  UP : the value resulting from conversion shall be the !!                    smallest representable value that is greater than or !!                    equal to the original value !!           RD  DOWN : the value resulting from conversion shall be the !!                    largest representable value that is less than or !!                    equal to the original value !!           RZ  ZERO : the value resulting from conversion shall be the value !!                    closest to the original value and no greater in !!                    magnitude than the original value. !!           RN  NEAREST : modeis NEAREST,thevalueresulting from conversion !!                        shall be the closer of the two nearest !!                        representable values if one is closer than the !!                        other. If the two nearest representable values !!                        are equidistant from the original value, it is !!                        processor dependent which one of them is chosen. !!           RC  COMPATIBLE : the value resulting from conversion shall be !!                          the closer of the two nearest representable !!                          values or the value away from zero if halfway !!                          between them. !!           RP  PROCESSOR_DEFINED : rounding during conversion shall be !!                                   a processor-dependent default mode, !!                                   which may correspond to one of the !!                                   other modes. !! !!##EXAMPLE !! !!  Sample program !! !!    program demo_significant !!    use M_verify, only : significant !!    implicit none !!    integer :: i !!    real :: r, v !!    character(len=*),parameter :: g='(*(g0.7,1x))' !! !!       write(*,g)significant([8765.43210,0.1234567890],5) !! !!       write(*,*)'default:',1.23456789012345 !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9]) !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RU'),'RU' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RD'),'RD' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RZ'),'RZ' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RN'),'RN' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RC'),'RC' !!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RP'),'RP' !!    end program demo_significant !! !!   Results: !! !!    8765.400 .1234600 !!     default:   1.234568 !!    1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 !!    2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RU !!    1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 1.234567 1.234568 1.234568 RD !!    1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 1.234567 1.234568 1.234568 RZ !!    1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RN !!    1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RC !!    1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 1.234568 1.234568 1.234568 RP pure elemental function significant ( val , digits , round ) ! ident_20=\"@(#) M_verify significant(3f) round val to specified number of significant digits\" real , intent ( in ) :: val integer , intent ( in ) :: digits character ( len =* ), intent ( in ), optional :: round real :: significant character ( len = 80 ) :: line , fmt if ( present ( round )) then write ( fmt , '(\"(\",a,\",e0.\",i0,\")\")' ) trim ( round ), digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE else write ( fmt , '(\"(e0.\",i0,\")\")' ) digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE endif write ( line , fmt ) val ! write with specified number of significant diguts read ( line , '(e50.20)' ) significant ! read back into a value end function significant !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function anyscalar_to_realbig ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit #ifdef __NVCOMPILER use , intrinsic :: iso_fortran_env , only : wp => real64 #else use , intrinsic :: iso_fortran_env , only : wp => real128 #endif implicit none ! ident_21=\"@(#) M_verify anyscalar_to_realbig(3f) convert integer or real parameter of any kind to real128 or biggest available\" class ( * ), intent ( in ) :: valuein real ( kind = wp ) :: d_out character ( len = 3 ) :: readable select type ( valuein ) type is ( integer ( kind = int8 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int16 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int32 )); d_out = real ( valuein , kind = wp ) type is ( integer ( kind = int64 )); d_out = real ( valuein , kind = wp ) type is ( real ( kind = real32 )); d_out = real ( valuein , kind = wp ) type is ( real ( kind = real64 )); d_out = real ( valuein , kind = wp ) #ifdef __NVCOMPILER #else Type is ( real ( kind = real128 )); d_out = valuein #endif type is ( logical ); d_out = merge ( 0.0_wp , 1.0_wp , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out class default !!d_out=huge(0.0_wp) readable = 'NaN' read ( readable , * ) d_out !!stop '*M_verify::anyscalar_to_realbig: unknown type' end select end function anyscalar_to_realbig !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure elemental function anyscalar_to_double ( valuein ) result ( d_out ) use , intrinsic :: iso_fortran_env , only : error_unit !! ,input_unit,output_unit implicit none ! ident_22=\"@(#) M_verify anyscalar_to_double(3f) convert integer or real parameter of any kind to doubleprecision\" class ( * ), intent ( in ) :: valuein doubleprecision :: d_out doubleprecision , parameter :: big = huge ( 0.0d0 ) select type ( valuein ) type is ( integer ( kind = int8 )); d_out = dble ( valuein ) type is ( integer ( kind = int16 )); d_out = dble ( valuein ) type is ( integer ( kind = int32 )); d_out = dble ( valuein ) type is ( integer ( kind = int64 )); d_out = dble ( valuein ) type is ( real ( kind = real32 )); d_out = dble ( valuein ) type is ( real ( kind = real64 )); d_out = dble ( valuein ) #ifdef __NVCOMPILER #else Type is ( real ( kind = real128 )) #endif !!if(valuein > big)then !!   write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !!endif d_out = dble ( valuein ) type is ( logical ); d_out = merge ( 0.0d0 , 1.0d0 , valuein ) type is ( character ( len =* )); read ( valuein , * ) d_out !type is (real(kind=real128)) !   if(valuein > big)then !      write(error_unit,*)'*anyscalar_to_double* value too large ',valuein !   endif !   d_out=dble(valuein) class default d_out = 0.0d0 !!stop '*M_verify::anyscalar_to_double: unknown type' end select end function anyscalar_to_double !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_verify !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_verify.f90.html"},{"title":"demo_almost.f90 – M_msg","text":"Source Code program demo_almost use M_verify , only : almost implicit none real :: x , y logical :: z integer :: i x = 1.2345678 y = 1.2300000 do i = 1 , 8 z = almost ( x , y , real ( i ), verbose = . true .) write ( * , * ) i , z enddo end program demo_almost","tags":"","loc":"sourcefile/demo_almost.f90.html"},{"title":"demo_in_margin.f90 – M_msg","text":"Source Code program demo_in_margin use :: M_verify , only : in_margin implicit none write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0000001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.000001 ) write ( * , * ) in_margin ([ 4.0 , 4 0.0 , 40 0.0 , 400 0.0 , 4000 0.0 ], [ 3.9 , 3 9.9 , 39 9.9 , 399 9.9 , 3999 9.9 ] , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.00001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.0001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.001 ) write ( * , * ) in_margin ( 4.00000 , 3.99999 , 0.01 ) end program demo_in_margin","tags":"","loc":"sourcefile/demo_in_margin.f90.html"},{"title":"demo_pdec.f90 – M_msg","text":"Source Code program demo_pdec use M_verify , only : pdec call pdec ( ' ABCDEFG abcdefg    ' ) end program demo_pdec","tags":"","loc":"sourcefile/demo_pdec.f90.html"},{"title":"demo_significant.f90 – M_msg","text":"Source Code program demo_significant use M_verify , only : significant implicit none integer :: i real :: r , v character ( len =* ), parameter :: g = '(*(g0.7,1x))' write ( * , g ) significant ([ 876 5.43210 , 0.1234567890 ], 5 ) write ( * , * ) 'default:' , 1.23456789012345 write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ]) write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RU' ), 'RU' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RD' ), 'RD' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RZ' ), 'RZ' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RN' ), 'RN' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RC' ), 'RC' write ( * , g ) significant ( 1.23456789012345 ,[ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ], 'RP' ), 'RP' end program demo_significant","tags":"","loc":"sourcefile/demo_significant.f90.html"},{"title":"M_msg.F90 – M_msg","text":"Source Code module M_msg use , intrinsic :: iso_fortran_env , only : ERROR_UNIT , OUTPUT_UNIT ! access computing environment use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 implicit none private !----------------------------------------------------------------------------------------------------------------------------------- ! USED SO FREQUENTLY IN OTHER MODULES PUT IN THIS ONE WITH NO DEPENDENCIES TO PREVENT CIRCULAR DEPENDENCY !----------------------------------------------------------------------------------------------------------------------------------- ! ident_1=\"@(#) M_msg str(3f) {msg_scalar msg_one}\" public str public stderr public wrt public fmt public set !!public :: a,i,f,g interface str module procedure msg_scalar , msg_one end interface str interface set module procedure set_scalar module procedure set_single end interface set contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    str(3f) - [M_msg] converts up to twenty standard scalar type values to a string !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep) !!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9 !!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj !!      character(len=*),intent(in),optional :: sep !!      character,len=(:),allocatable :: str !! !!##DESCRIPTION !!    str(3f) builds a space-separated string from up to twenty scalar values. !! !!##OPTIONS !!    g[0-9a-j]   optional value to print the value of after the message. May !!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, !!                COMPLEX, or CHARACTER. !! !!                Optionally, all the generic values can be !!                single-dimensioned arrays. Currently, mixing scalar !!                arguments and array arguments is not supported. !! !!    sep         separator string used between values. Defaults to a space. !! !!##RETURNS !!    str     description to print !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_msg !!    use M_msg, only : str !!    implicit none !!    character(len=:),allocatable :: pr !!    character(len=:),allocatable :: frmt !!    integer                      :: biggest !! !!    pr=str('HUGE(3f) integers',huge(0),& !!    &'and real',huge(0.0),'and double',huge(0.0d0)) !!    write(*,'(a)')pr !!    pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) ) !!    write(*,'(a)')pr !!    pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) ) !!    write(*,'(a)')pr !!    pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) ) !!    write(*,'(a)')pr !! !!    ! create a format on the fly !!    biggest=huge(0) !!    frmt=str('(*(i',int(log10(real(biggest))),':,1x))',sep='') !!    write(*,*)'format=',frmt !! !!    ! although it will often work, using str(3f) !!    ! in an I/O statement is not recommended !!    ! because if an error occurs str(3f) will try !!    ! to write while part of an I/O statement !!    ! which not all compilers can handle and is currently non-standard !!    write(*,*)str('program will now stop') !! !!    end program demo_msg !! !!  Output !! !!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 and double 1.7976931348623157E+308 !!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38 !!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 12345.678900000001 2.2250738585072014E-308 !!    complex         : (3.40282347E+38,1.17549435E-38) !!     format=(*(i9:,1x)) !!     program will now stop !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain pure function msg_scalar ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , & & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj , & & sep ) implicit none ! ident_2=\"@(#) M_msg msg_scalar(3fp) writes a message to a string composed of any standard scalar types\" class ( * ), intent ( in ), optional :: generic0 , generic1 , generic2 , generic3 , generic4 class ( * ), intent ( in ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 class ( * ), intent ( in ), optional :: generica , genericb , genericc , genericd , generice class ( * ), intent ( in ), optional :: genericf , genericg , generich , generici , genericj character ( len = :), allocatable :: msg_scalar character ( len = 4096 ) :: line integer :: istart integer :: increment character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local if ( present ( sep )) then increment = len ( sep ) + 1 sep_local = sep else increment = 2 sep_local = ' ' endif istart = 1 line = '' if ( present ( generic0 )) call print_generic ( generic0 , line , istart , increment , sep_local ) if ( present ( generic1 )) call print_generic ( generic1 , line , istart , increment , sep_local ) if ( present ( generic2 )) call print_generic ( generic2 , line , istart , increment , sep_local ) if ( present ( generic3 )) call print_generic ( generic3 , line , istart , increment , sep_local ) if ( present ( generic4 )) call print_generic ( generic4 , line , istart , increment , sep_local ) if ( present ( generic5 )) call print_generic ( generic5 , line , istart , increment , sep_local ) if ( present ( generic6 )) call print_generic ( generic6 , line , istart , increment , sep_local ) if ( present ( generic7 )) call print_generic ( generic7 , line , istart , increment , sep_local ) if ( present ( generic8 )) call print_generic ( generic8 , line , istart , increment , sep_local ) if ( present ( generic9 )) call print_generic ( generic9 , line , istart , increment , sep_local ) if ( present ( generica )) call print_generic ( generica , line , istart , increment , sep_local ) if ( present ( genericb )) call print_generic ( genericb , line , istart , increment , sep_local ) if ( present ( genericc )) call print_generic ( genericc , line , istart , increment , sep_local ) if ( present ( genericd )) call print_generic ( genericd , line , istart , increment , sep_local ) if ( present ( generice )) call print_generic ( generice , line , istart , increment , sep_local ) if ( present ( genericf )) call print_generic ( genericf , line , istart , increment , sep_local ) if ( present ( genericg )) call print_generic ( genericg , line , istart , increment , sep_local ) if ( present ( generich )) call print_generic ( generich , line , istart , increment , sep_local ) if ( present ( generici )) call print_generic ( generici , line , istart , increment , sep_local ) if ( present ( genericj )) call print_generic ( genericj , line , istart , increment , sep_local ) msg_scalar = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 class ( * ), intent ( in ) :: generic character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(i0)' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(i0)' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(1pg0)' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(1pg0)' ) generic #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); write ( line ( istart :), '(1pg0)' ) generic #endif type is ( logical ); write ( line ( istart :), '(l1)' ) generic type is ( character ( len =* )); write ( line ( istart :), '(a)' ) trim ( generic ) type is ( complex ); write ( line ( istart :), '(\"(\",1pg0,\",\",1pg0,\")\")' ) generic end select istart = len_trim ( line ) + increment line = trim ( line ) // sep end subroutine print_generic !=================================================================================================================================== end function msg_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function msg_one ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 ,& & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj ,& & sep ) implicit none ! ident_3=\"@(#) M_msg msg_one(3fp) writes a message to a string composed of any standard one dimensional types\" class ( * ), intent ( in ) :: generic0 (:) class ( * ), intent ( in ), optional :: generic1 (:), generic2 (:), generic3 (:), generic4 (:), generic5 (:) class ( * ), intent ( in ), optional :: generic6 (:), generic7 (:), generic8 (:), generic9 (:) class ( * ), intent ( in ), optional :: generica (:), genericb (:), genericc (:), genericd (:), generice (:) class ( * ), intent ( in ), optional :: genericf (:), genericg (:), generich (:), generici (:), genericj (:) character ( len =* ), intent ( in ), optional :: sep character ( len = :), allocatable :: sep_local character ( len = :), allocatable :: msg_one character ( len = 4096 ) :: line integer :: istart integer :: increment if ( present ( sep )) then increment = 1 + len ( sep ) sep_local = sep else sep_local = ' ' increment = 2 endif istart = 1 line = ' ' call print_generic ( generic0 , line , istart , increment , sep_local ) if ( present ( generic1 )) call print_generic ( generic1 , line , istart , increment , sep_local ) if ( present ( generic2 )) call print_generic ( generic2 , line , istart , increment , sep_local ) if ( present ( generic3 )) call print_generic ( generic3 , line , istart , increment , sep_local ) if ( present ( generic4 )) call print_generic ( generic4 , line , istart , increment , sep_local ) if ( present ( generic5 )) call print_generic ( generic5 , line , istart , increment , sep_local ) if ( present ( generic6 )) call print_generic ( generic6 , line , istart , increment , sep_local ) if ( present ( generic7 )) call print_generic ( generic7 , line , istart , increment , sep_local ) if ( present ( generic8 )) call print_generic ( generic8 , line , istart , increment , sep_local ) if ( present ( generic9 )) call print_generic ( generic9 , line , istart , increment , sep_local ) if ( present ( generica )) call print_generic ( generica , line , istart , increment , sep_local ) if ( present ( genericb )) call print_generic ( genericb , line , istart , increment , sep_local ) if ( present ( genericc )) call print_generic ( genericc , line , istart , increment , sep_local ) if ( present ( genericd )) call print_generic ( genericd , line , istart , increment , sep_local ) if ( present ( generice )) call print_generic ( generice , line , istart , increment , sep_local ) if ( present ( genericf )) call print_generic ( genericf , line , istart , increment , sep_local ) if ( present ( genericg )) call print_generic ( genericg , line , istart , increment , sep_local ) if ( present ( generich )) call print_generic ( generich , line , istart , increment , sep_local ) if ( present ( generici )) call print_generic ( generici , line , istart , increment , sep_local ) if ( present ( genericj )) call print_generic ( genericj , line , istart , increment , sep_local ) msg_one = trim ( line ) contains !=================================================================================================================================== pure subroutine print_generic ( generic , line , istart , increment , sep ) !use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128 use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 class ( * ), intent ( in ), optional :: generic (:) character ( len = 4096 ), intent ( inout ) :: line integer , intent ( inout ) :: istart integer , intent ( in ) :: increment character ( len =* ), intent ( in ) :: sep integer :: i select type ( generic ) type is ( integer ( kind = int8 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int16 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int32 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( integer ( kind = int64 )); write ( line ( istart :), '(\"[\",*(i0,1x))' ) generic type is ( real ( kind = real32 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic type is ( real ( kind = real64 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); write ( line ( istart :), '(\"[\",*(1pg0,1x))' ) generic !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic #endif type is ( logical ); write ( line ( istart :), '(\"[\",*(l1,1x))' ) generic type is ( character ( len =* )); write ( line ( istart :), '(\"[\",:*(\"\"\"\",a,\"\"\"\",1x))' ) ( trim ( generic ( i )), i = 1 , size ( generic )) type is ( complex ); write ( line ( istart :), '(\"[\",*(\"(\",1pg0,\",\",1pg0,\")\",1x))' ) generic class default !error_stop 'unknown type in *print_generic*' end select istart = len_trim ( line ) + increment + 1 line = trim ( line ) // ']' // sep_local end subroutine print_generic !=================================================================================================================================== end function msg_one !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    fmt(3f) - [M_msg] convert any intrinsic to a string using specified format !!    (LICENSE:PD) !!##SYNOPSIS !! !!    function fmt(value,format) result(string) !! !!     class(*),intent(in),optional :: value !!     character(len=*),intent(in),optional  :: format !!     character(len=:),allocatable :: string !!##DESCRIPTION !!    FMT(3f) converts any standard intrinsic value to a string using the specified !!    format. !!##OPTIONS !!    value    value to print the value of. May be of type INTEGER, LOGICAL, !!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER. !!    format   format to use to print value. It is up to the user to use an !!             appropriate format. The format does not require being !!             surrounded by parenthesis. If not present a default is selected !!             similar to what would be produced with free format. !!##RETURNS !!    string   A string value !!##EXAMPLES !! !!   Sample program: !! !!     program demo_fmt !!     use :: M_msg, only : fmt !!     implicit none !!     character(len=:),allocatable :: output !! !!        output=fmt(10,\"'[',i0,']'\") !!        write(*,*)'result is ',output !! !!        output=fmt(10.0/3.0,\"'[',g0.5,']'\") !!        write(*,*)'result is ',output !! !!        output=fmt(.true.,\"'The final answer is [',g0,']'\") !!        write(*,*)'result is ',output !! !!     end program demo_fmt !! !!   Results: !! !!     result is [10] !!     result is [3.3333] !!     result is The final answer is [T] !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain recursive function fmt ( generic , format ) result ( line ) use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 , real32 , real64 , real128 ! ident_4=\"@(#) M_msg fmt(3f) convert any intrinsic to a string using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local integer :: ios character ( len = 255 ) :: msg character ( len = 1 ), parameter :: null = char ( 0 ) integer :: ilen if ( present ( format )) then fmt_local = format else fmt_local = '' endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable ios = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null #endif type is ( logical ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( character ( len =* )); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null type is ( complex ); write ( line , fmt_local , iostat = ios , iomsg = msg ) generic , null end select if ( ios /= 0 ) then line = '<ERROR>' // trim ( msg ) else ilen = index ( line , null , back = . true .) if ( ilen == 0 ) ilen = len ( line ) line = line (: ilen - 1 ) endif end function fmt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    stderr(3f) - [M_msg] write message to stderr !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine stderr(msg,[generic]) !! !!     class(*),intent(in),optional :: msg !!     class(*),intent(in),optional :: generic0,generic1,generic2,generic3,generic4 !!     class(*),intent(in),optional :: generic5,generic6,generic7,generic8,generic9 !!##DESCRIPTION !!    STDERR(3f) writes a message to standard error using a standard f2003 method. !!    Up to ten generic options are available. !!##OPTIONS !!    msg           - description to print !!    generic[0-9]  - optional value to print the value of after the message. May !!                    be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!                    or CHARACTER. !!##EXAMPLES !! !!   Sample program: !! !!    program demo_stderr !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32 !!    use M_msg, only: stderr !!    implicit none !! !!    call stderr('A simple message') !!    call stderr('error: RVALUE=',3.0/4.0) !!    call stderr('error: IVALUE=',123456789) !!    call stderr('error: LVALUE=',.true.) !! !!    SEVERAL: block !!    integer :: least=10, most=999, ival=-10 !!    call stderr('error: value',ival,'should be between',least,'and',most) !!    endblock SEVERAL !! !!    call stderr('real32  :',huge(0.0_real32),0.0_real32,12345.6789_real32,tiny(0.0_real32)) !!    call stderr('real64  :',huge(0.0_real64),0.0_real64,12345.6789_real64,tiny(0.0_real64)) !!    !#ifdef __NVCOMPILER !!    !#else !!    call stderr('real128 :',huge(0.0_real128),0.0_real128,12345.6789_real128,tiny(0.0_real128)) !!    !#endif !!    call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real))) !! !!    call stderr('error: program will now stop') !!    stop 1 !! !!    end program demo_stderr !! !!   Results: !!     A simple message !!     error: RVALUE= 0.750000000 !!     error: IVALUE= 123456789 !!     error: LVALUE= T !!     error: value -10 should be between 10 and 999 !!     real32  : 3.40282347E+38 ... !!               0.00000000 ... !!               12345.6787 ... !!               1.17549435E-38 !!     real64  : 1.7976931348623157E+308 ... !!               0.0000000000000000 ... !!               12345.678900000001 ... !!               2.2250738585072014E-308 !!     real128 : 1.18973149535723176508575932662800702E+4932 ... !!               0.00000000000000000000000000000000000  ... !!               12345.6789000000000000000000000000002 ... !!               3.36210314311209350626267781732175260E-4932 !!     complex : (3.40282347E+38,1.17549435E-38) !!     error: program will now stop !!     STOP 1 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine stderr ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) implicit none ! ident_5=\"@(#) M_msg stderr(3f) writes a message to standard error using a standard f2003 method\" class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer :: ios write ( error_unit , '(a)' , iostat = ios ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) flush ( unit = output_unit , iostat = ios ) flush ( unit = error_unit , iostat = ios ) end subroutine stderr !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    wrt(3f) - [M_msg] write multiple scalar values to any number of files !!    (LICENSE:PD) !!##SYNOPSIS !! !!    subroutine wrt(luns,generic(s),iostat) !! !!     integer,intent(in)           :: luns(:) !!     class(*),intent(in),optional :: generic0,generic1,generic2,generic3,generic4 !!     class(*),intent(in),optional :: generic5,generic6,generic7,generic8,generic9 !!     class(*),intent(in),optional :: generica,genericb,genericc,genericd,generice !!     class(*),intent(in),optional :: genericf,genericg,generich,generici,genericj !!     integer,intent(out),optional :: ios !!##DESCRIPTION !!    WRT(3f) writes a list of scalar values  to the list of unit numbers in LUNS(:). !!##OPTIONS !!    LUNS            Unit numbers to write to. If of size zero no output is generated !!    generic[1-20]   optional value to print the value of after the message. May !!                    be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX, !!                    or CHARACTER. !!##RETURNS !!    IOSTAT          The value of the last non-zero IOSTAT value. Returns zero if !!                    no errors occurred. !!##EXAMPLES !! !!   Sample program: !! !!    program demo_wrt !!    use, intrinsic :: iso_fortran_env, only : & !!     & stdin=>input_unit, & !!     & stdout=>output_unit, & !!     & stderr=>error_unit !!    use M_msg, only: wrt, fmt !!    implicit none !!    integer,allocatable :: luns(:) !!    integer :: iostat=0 !!    integer,parameter :: ints(3)=[1,2,3] !! !!    ! a null list allows for turning off verbose or debug mode output !!    luns=[integer ::] !!    call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat) !!    write(*,*)'IOSTAT=',iostat !! !!    ! multiple files can be used to create a log file, for example !!    luns=[stderr,stdout] !!    call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat) !!    write(*,*)'IOSTAT=',iostat !! !!    ! using fmt !!    call wrt([stdout,stdout,stdout],'USING FMT :', & !!     & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat) !! !! !!    end program demo_wrt !! !!##TWO FILES: 2147483647 PI= 3.1415926535897931 !!##TWO FILES: 2147483647 PI= 3.1415926535897931 !!  IOSTAT=           0 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!##USING FMT : 2147483647 PI= 3.1415926535897931 0002 !!  IOSTAT=           0 !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine wrt ( luns , g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj , iostat ) implicit none ! ident_6=\"@(#) M_msg write(3f) writes a message to any number of open files with any scalar values\" integer , intent ( in ) :: luns (:) class ( * ), intent ( in ), optional :: g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 class ( * ), intent ( in ), optional :: ga , gb , gc , gd , ge , gf , gg , gh , gi , gj integer , intent ( out ), optional :: iostat integer :: i character ( len = 256 ) :: msg do i = 1 , size ( luns ) write ( luns ( i ), '(a)' , iostat = iostat , iomsg = msg ) str ( g0 , g1 , g2 , g3 , g4 , g5 , g6 , g7 , g8 , g9 , ga , gb , gc , gd , ge , gf , gg , gh , gi , gj ) if ( iostat /= 0 ) then call stderr ( '<ERROR>*write*:' , msg ) endif enddo end subroutine wrt !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    set(3f) - [M_set] set scalars from an array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,& !!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk) !!      class(*),intent(in)           :: g0 !!      class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga !!      class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk !! !!##DESCRIPTION !!    set(3f) sets up to twenty scalars to elements from an array. !!    Sort of like an equivalence. !! !!##OPTIONS !!    g0(:)       array to read values from. Can be of type INTEGER or REAL !!    g[1-9a-k]   optional values to set to an array element. Can !!                be of type INTEGER or REAL !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_set !!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64 !!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128 !!    use M_msg, only : set !!    implicit none !!    real(kind=real32)    :: a; namelist /all/a !!    real(kind=real64)    :: b; namelist /all/b !!    real(kind=real128)   :: c; namelist /all/c !!    integer(kind=int8)   :: i; namelist /all/i !!    integer(kind=int16)  :: j; namelist /all/j !!    integer(kind=int32)  :: k; namelist /all/k !!    integer(kind=int64)  :: l; namelist /all/l !!    integer              :: iarr(7)=[1,2,3,4,5,6,7] !!       call set(iarr,a,b,c,i,j,k,l) !!       write(*,nml=all) !!       call set(10,a) !!       call set(100,l) !!       write(*,nml=all) !!    end program demo_set !! !!   Results: !! !!     &ALL !!     A       =   1.000000    , !!     B       =   2.00000000000000     , !!     C       =   3.00000000000000000000000000000000      , !!     I       =    4, !!     J       =      5, !!     K       =           6, !!     L       =                     7 !!     / !!     &ALL !!     A       =   10.00000    , !!     B       =   2.00000000000000     , !!     C       =   3.00000000000000000000000000000000      , !!     I       =    4, !!     J       =      5, !!     K       =           6, !!     L       =                   100 !!     / !! !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!    Public Domain subroutine set_single ( generic0 , generic1 ) implicit none class ( * ), intent ( in ) :: generic0 class ( * ), intent ( out ) :: generic1 call set_generic ( generic1 ) contains subroutine set_generic ( gen ) class ( * ), intent ( out ) :: gen select type ( generic0 ) type is ( integer ( kind = int8 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int16 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( integer ( kind = int64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( real ( kind = real32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select type is ( real ( kind = real64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 type is ( integer ( kind = int16 )); gen = generic0 type is ( integer ( kind = int32 )); gen = generic0 type is ( integer ( kind = int64 )); gen = generic0 type is ( real ( kind = real32 )); gen = generic0 type is ( real ( kind = real64 )); gen = generic0 #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 #endif end select #endif end select end subroutine set_generic end subroutine set_single subroutine set_scalar ( generic0 , generic1 , generic2 , generic3 , generic4 , generic5 , generic6 , generic7 , generic8 , generic9 , & & generica , genericb , genericc , genericd , generice , genericf , genericg , generich , generici , genericj , generick ) implicit none ! ident_7=\"@(#)M_msg::set_scalar(3fp): set scalars from array elements\" class ( * ), intent ( in ) :: generic0 (:) class ( * ), intent ( out ), optional :: generic1 , generic2 , generic3 , generic4 class ( * ), intent ( out ), optional :: generic5 , generic6 , generic7 , generic8 , generic9 class ( * ), intent ( out ), optional :: generica , genericb , genericc , genericd , generice class ( * ), intent ( out ), optional :: genericf , genericg , generich , generici , genericj class ( * ), intent ( out ), optional :: generick if ( present ( generic1 )) call set_generic ( generic1 , 1 ) if ( present ( generic2 )) call set_generic ( generic2 , 2 ) if ( present ( generic3 )) call set_generic ( generic3 , 3 ) if ( present ( generic4 )) call set_generic ( generic4 , 4 ) if ( present ( generic5 )) call set_generic ( generic5 , 5 ) if ( present ( generic6 )) call set_generic ( generic6 , 6 ) if ( present ( generic7 )) call set_generic ( generic7 , 7 ) if ( present ( generic8 )) call set_generic ( generic8 , 8 ) if ( present ( generic9 )) call set_generic ( generic9 , 9 ) if ( present ( generica )) call set_generic ( generica , 10 ) if ( present ( genericb )) call set_generic ( genericb , 11 ) if ( present ( genericc )) call set_generic ( genericc , 12 ) if ( present ( genericd )) call set_generic ( genericd , 13 ) if ( present ( generice )) call set_generic ( generice , 14 ) if ( present ( genericf )) call set_generic ( genericf , 15 ) if ( present ( genericg )) call set_generic ( genericg , 16 ) if ( present ( generich )) call set_generic ( generich , 17 ) if ( present ( generici )) call set_generic ( generici , 18 ) if ( present ( genericj )) call set_generic ( genericj , 19 ) if ( present ( generick )) call set_generic ( generick , 20 ) contains !=================================================================================================================================== subroutine set_generic ( gen , i ) class ( * ), intent ( out ) :: gen integer , intent ( in ) :: i if ( size ( generic0 ) < i ) then write ( ERROR_UNIT , '()' ) '<ERROR> i=' , i , ' is out of bounds (<' , size ( generic0 ), ')' stop 1 endif select type ( generic0 ) type is ( integer ( kind = int8 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int16 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( integer ( kind = int64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( real ( kind = real32 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select type is ( real ( kind = real64 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )) select type ( gen ) type is ( integer ( kind = int8 )); gen = generic0 ( i ) type is ( integer ( kind = int16 )); gen = generic0 ( i ) type is ( integer ( kind = int32 )); gen = generic0 ( i ) type is ( integer ( kind = int64 )); gen = generic0 ( i ) type is ( real ( kind = real32 )); gen = generic0 ( i ) type is ( real ( kind = real64 )); gen = generic0 ( i ) #ifdef __NVCOMPILER #else type is ( real ( kind = real128 )); gen = generic0 ( i ) #endif end select #endif end select end subroutine set_generic !=================================================================================================================================== end subroutine set_scalar !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_msg !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !===================================================================================================================================","tags":"","loc":"sourcefile/m_msg.f90.html"},{"title":"demo_wrt.f90 – M_msg","text":"Source Code program demo_wrt use , intrinsic :: iso_fortran_env , only : & & stdin => input_unit , & & stdout => output_unit , & & stderr => error_unit use M_msg , only : wrt , fmt implicit none integer , allocatable :: luns (:) integer :: iostat = 0 integer , parameter :: ints ( 3 ) = [ 1 , 2 , 3 ] ! a null list allows for turning off verbose or debug mode output luns = [ integer :: ] call wrt ( luns , 'NULL LIST:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! multiple files can be used to create a log file, for example luns = [ stderr , stdout ] call wrt ( luns , 'TWO FILES:' , huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , iostat = iostat ) write ( * , * ) 'IOSTAT=' , iostat ! using fmt call wrt ([ stdout , stdout , stdout ], 'USING FMT :' , & & huge ( 0 ), 'PI=' , asin ( 1.0d0 ) * 2.0d0 , fmt ( ints ( 2 ), 'i0.4' ), iostat = iostat ) end program demo_wrt","tags":"","loc":"sourcefile/demo_wrt.f90.html"},{"title":"demo_stderr.f90 – M_msg","text":"Source Code program demo_stderr use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 use , intrinsic :: iso_fortran_env , only : real => real32 , integer => int32 use M_verify , only : stderr implicit none call stderr ( 'A simple message' ) call stderr ( 'error: RVALUE=' , 3.0 / 4.0 ) call stderr ( 'error: IVALUE=' , 123456789 ) call stderr ( 'error: LVALUE=' ,. true .) SEVERAL : block integer :: least = 10 , most = 999 , ival =- 10 call stderr ( 'error: value' , ival , 'should be between' , least , 'and' , most ) endblock SEVERAL call stderr ( 'real32  :' , huge ( 0.0_real32 ), 0.0_real32 , 1234 5.6789_real32 , tiny ( 0.0_real32 )) call stderr ( 'real64  :' , huge ( 0.0_real64 ), 0.0_real64 , 1234 5.6789_real64 , tiny ( 0.0_real64 )) call stderr ( 'real128 :' , huge ( 0.0_real128 ), 0.0_real128 , 1234 5.6789_real128 , tiny ( 0.0_real128 )) call stderr ( 'complex :' , cmplx ( huge ( 0.0_real ), tiny ( 0.0_real ))) call stderr ( 'error: program will now stop' ) stop 1 end program demo_stderr","tags":"","loc":"sourcefile/demo_stderr.f90.html"},{"title":"demo_assert.f90 – M_msg","text":"Source Code program demo_assert use M_verify , only : assert implicit none real :: a , toobig = 1024 a = 2000 call assert ( 'myroutine' , 101 , a > toobig , 'The value is too large' , a , ' > ' , toobig ) end program demo_assert","tags":"","loc":"sourcefile/demo_assert.f90.html"},{"title":"M_help.f90 – M_msg","text":"Source Code module M_help use , intrinsic :: iso_fortran_env , only : stderr => error_unit , stdin => input_unit , stdout => output_unit use M_journal , only : journal implicit none private public help_command contains !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! !> !!##NAME !!    help_command(3f) - [M_help] uses a specially formatted text array to !!    provide a HELP interface !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    Syntax: !! !!      function help_command(text_array,topic,position) !! !!##DESCRIPTION !!    This routine, when given a CHARACTER array displays the text !!    interactively. The special topics \"manual\",\"topics\", and \"search\" !!    are reserved. \"manual\" causes the entire array to be displayed. !!    \"topics\" displays all lines not beginning with a space or three or !!    more equal signs, and \"search\" must be followed by a string to search !!    for in the manual. !! !!    A line beginning with a non-blank character in column one is a topic !! !!    A topic with the preceding line beginning with \"===\" is a special !!    topic that will be displayed up to the next line beginning with \"===\" !! !!    The special topic \"manual\" displays the entire help text !! !!    The help text is paged based on the values in the position() array. The !!    first value is the current line count on the current page, and the !!    second value is how many lines should be displayed as a page before !!    a paging prompt is produced. POSITION(2) is typically set to 23. !!    POSITION(1) can be set to zero, especially if the calling page is !!    not tracking paging itself. !! !!    Entering a \"q\" at the prompt exits the help text. To see other options !!    enter an \"h\" at the prompt. !! !!       h !!       #----------------------------------------------------# PAGING !!       | f|SPACE b  forward or backward one page            | !!       | u d        redraw up or down one-half page         | !!       | r          refresh page                            | !!       | e y | j k  refresh page moving up or down one line | !!       #----------------------------------------------------# JUMPING !!       | g          go to top of manual                     | !!       | NNN        go to line number NNN. Use a sign (+-)  | !!       |            for a relative move.                    | !!       | .          toggle line numbering                   | !!       #----------------------------------------------------# SEARCHING !!       | /STRING    advance to next line containing string  | !!       | ?STRING    search for string above current line    | !!       | n N        find next occurrence up or down in file | !!       | \\STRING    show all lines with specified string.   | !!       | t          displays topic lines.                   | !!       #----------------------------------------------------# !!       | w FILENAME write entire user guide to local file   | !!       | h          display this help                       | !!       | q          quit                                    | !!       #----------------------------------------------------# !!       Anything else is ignored. !!       Line count is 25 out of 54 . Page size is 23 (see \"lines\") !!       continue .. !! !! !!    A normal topic is displayed until another topic line (line beginning !!    with a non-blank) is encountered !! !!    The help text must begin with a line starting with \"===\" !! !!    If a line is preceded by an \"===\" line it is considered a section !!    instead of a topic, and all lines between that line and the next line !!    beginning with \"===\" are displayed. !!##OPTIONS !!    help_text  The block of text to treat as the input document !! !!    topic      What topic or section to search for (case sensitive). A blank !!               is equivalent to \"SUMMARY\". There are several reserved names. !!               \"manual\" means the entire help text, and \"topics\" shows only !!               lines not beginning with a blank, and \"search\" does a !!               case-insensitive search for a string. !! !!    position   A small array with two values. The second value is the size !!               of the page to be used between pauses. The first one indicates !!               how many lines on the current page have been displayed. !!##EXAMPLE !! !!   Sample program: !! !!    program demo_help_command !!    use M_help, only : help_command !!    character(len=:),allocatable :: help_text(:) !!    integer                      :: position(2) !!    position=[0,23] !!    help_text=[character(len=80) :: & !!    '==============================================',& !!    '   A sample help text file.                   ',& !!    '   Note the first line MUST start with \"===\"  ',& !!    '==============================================',& !!    'SUMMARY                                       ',& !!    '  This is usually a crib sheet                ',& !!    '==============================================',& !!    'SECTION1                                      ',& !!    'topic1                                        ',& !!    '   A description of topic 1                   ',& !!    '                                              ',& !!    '   and any general text you want              ',& !!    '                                              ',& !!    'topic2  A description of topic 2              ',& !!    'topic3                                        ',& !!    '   A description of topic 3                   ',& !!    '   more  description of topic 3               ',& !!    '   and more description of topic 3 a          ',& !!    '   and more description of topic 3 b          ',& !!    '   and more description of topic 3 c          ',& !!    '   and more description of topic 3 d          ',& !!    '   and more description of topic 3 e          ',& !!    '   and more description of topic 3 f          ',& !!    '   and more description of topic 3 g          ',& !!    '   and more description of topic 3 h          ',& !!    '   and more description of topic 3 i          ',& !!    '   and more description of topic 3 j          ',& !!    '   and more description of topic 3 k          ',& !!    '   and more description of topic 3 l          ',& !!    '   and more description of topic 3 m          ',& !!    '   and more description of topic 3 n          ',& !!    '   and more description of topic 3 o          ',& !!    '   and more description of topic 3 p          ',& !!    '   and more description of topic 3 q          ',& !!    '   and more description of topic 3 r          ',& !!    '   and more description of topic 3 s          ',& !!    '   and more description of topic 3 t          ',& !!    '   and more description of topic 3 u          ',& !!    '   and more description of topic 3 v          ',& !!    '   and more description of topic 3 w          ',& !!    '   and more description of topic 3 x          ',& !!    '   and more description of topic 3 y          ',& !!    '   and more description of topic 3 z          ',& !!    '==============================================',& !!    'SECTION2                                      ',& !!    'topic4  A description of topic 4              ',& !!    '   this is the last part of SECTION1          ',& !!    'topic5                                        ',& !!    '  This is all about the fifth topic and is    ',& !!    '  just displayed as-is. The text cannot start ',& !!    '  in column one or it will be seen as the     ',& !!    '  beginning of a topic.                       ',& !!    '==============================================',& !!    '                                              ' ] !! !!    write(*,*)'>>>>>' !!    call help_command(help_text,'',position) !!    write(*,*)'>>>>>topic1' !!    call help_command(help_text,'topic1',position) !!    write(*,*)'>>>>>topics' !!    call help_command(help_text,'topics',position) !!    write(*,*)'>>>>>manual' !!    call help_command(help_text,'manual',position) !!    end program demo_help_command subroutine help_command ( help_text , topic_name , position ) ! ident_1=\"@(#) M_help help_command(3f) interactively display help text\" character ( len =* ), intent ( in ) :: help_text (:) character ( len =* ), intent ( in ) :: topic_name integer :: position ( 2 ) integer :: end_of_first_word integer :: start_of_topic integer :: ios character ( len = :), allocatable :: topic , old_topic , string logical :: block_topic integer :: i , j , k , jj , ii logical :: numbered character ( len = len ( help_text )) :: last_response integer :: toomany integer , parameter :: max_toomany = 2000 integer :: howbig integer :: old_position howbig = size ( help_text ) toomany = 1 last_response = ' ' numbered = . false . topic = trim ( topic_name ) old_topic = '' old_position = 0 if ( index ( topic , 'search ' ) == 1 ) then topic = 'search' endif INFINITE : do if ( topic == ' ' ) then ! if no topic call journal ( 'Type \"help\" followed by a case-sensitive topic name ...' ) topic = 'SUMMARY' endif select case ( topic ) case ( 'manual' ) ! show all the help text i = 0 do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 3 ) == '===' ) then if ( numbered ) then call journal ( 'sc' , i , ' ' ) else call journal ( ' ' ) endif else if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , help_text ( i )) endif endif if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE if ( i >= howbig ) then do j = 1 , max_toomany call journal ( 'sc' , '[end-of-file] (line' , i , ')' ) position ( 1 ) = position ( 2 ) + 1 if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE if ( i < howbig ) exit enddo if ( i >= howbig ) exit endif enddo exit INFINITE case ( 'topics' ) ! go through all the text showing lines not starting with a a space or equal i = 1 ! display topic starting at start_of_topic do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 1 ) == '   ' ) cycle if ( help_text ( i )( 1 : 3 ) == '===' ) cycle jj = merge ( 0 , 3 , help_text ( i - 1 )( 1 : 3 ) == '===' ) if ( numbered ) then call journal ( 'sc' , i , '>' , repeat ( ' ' , jj ) // help_text ( i )) else call journal ( 'sc' , '>' , repeat ( ' ' , jj ) // help_text ( i )) endif if ( want_to_stop ()) then if ( old_topic /= '' ) then topic = old_topic old_topic = '' i = old_position call pageback ( 1 ) i = max ( 1 , i ) position ( 1 ) = position ( 2 ) + 1 cycle INFINITE endif exit INFINITE endif enddo if ( old_topic /= '' ) then topic = old_topic old_topic = '' i = old_position call pageback ( 1 ) i = max ( 1 , i ) position ( 1 ) = position ( 2 ) + 1 cycle INFINITE endif exit INFINITE case ( 'search' ) ! go through all the text showing lines matching string position ( 1 ) = 0 string = topic_name // '        ' string = trim ( lower ( adjustl ( string ( 8 :)))) i = 0 do i = i + 1 if ( i > howbig ) exit if ( help_text ( i )( 1 : 1 ) /= ' ' . and . help_text ( i )( 1 : 3 ) /= '===' ) then old_topic = help_text ( i ) // ' ' ii = index ( old_topic , ' ' ) old_topic = old_topic (: ii ) endif if ( index ( lower ( help_text ( i )), string ) /= 0 ) then if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , old_topic , '>' , help_text ( i )) endif if ( want_to_stop ()) exit INFINITE if ( i >= howbig ) then do j = 1 , max_toomany call journal ( 'sc' , '[end-of-file] (line' , i , ')' ) position ( 1 ) = position ( 2 ) + 1 if ( want_to_stop ()) exit INFINITE if ( i < howbig ) exit enddo if ( i >= howbig ) exit endif endif enddo exit INFINITE case default ! find the line that starts with the topic start_of_topic = 0 ! find the line to start with by finding a line that starts with the given topic ( ASSUMING FIRST LINE is ===) FINDIT : do j = 1 , len ( help_text ) do i = 2 , howbig ! get first word of lines not starting with a blank if ( help_text ( i )( 1 : 1 ) /= ' ' ) then ! only topic lines start in column one so skip these end_of_first_word = index ( help_text ( i ), ' ' ) - 1 if ( end_of_first_word == 0 ) end_of_first_word = len ( help_text ) ! if line is filled and does not have a blank end_of_first_word = end_of_first_word - j + 1 if ( end_of_first_word <= 0 ) cycle !x!write(*,*)'['//topic(:end_of_first_word)//']['//help_text(i)(:end_of_first_word)//']' if ( topic == help_text ( i )(: end_of_first_word )) then ! find a line that matches topic exit FINDIT endif endif enddo enddo FINDIT start_of_topic = i if ( i == 0 ) then call journal ( '<ERROR> internal error. First line of text must start with \"===\"' ) !!help_text=[character(len=len(help_text)) :: repeat(\"=\",80),help_text] start_of_topic = start_of_topic + 1 endif if ( help_text ( i - 1 )( 1 : 3 ) == '===' ) then ! if the line above the start started with \"===\" it is a block comment block_topic = . true . else block_topic = . false . endif if ( start_of_topic > howbig . or . start_of_topic == 0 ) then call journal ( 'sc' , 'SORRY, No help on ' , topic ) else position ( 1 ) = 0 if ( numbered ) then call journal ( 'sc' , i , help_text ( start_of_topic )) ! show the start line else call journal ( 'sc' , help_text ( start_of_topic )) ! show the start line endif i = start_of_topic + 1 ! display topic starting at start_of_topic do if ( help_text ( i )( 1 : 1 ) /= ' ' . and . . not . block_topic ) then ! stop at next topic if not a block of help exit elseif ( block_topic . and . help_text ( i )( 1 : 3 ) == '===' ) then exit endif if ( numbered ) then call journal ( 'sc' , i , help_text ( i )) else call journal ( 'sc' , help_text ( i )) endif if ( want_to_stop ()) exit INFINITE if ( old_topic /= '' ) cycle INFINITE toomany = toomany + 1 if ( toomany >= max_toomany ) exit INFINITE ! to prevent infinite loops in batch mode i = max ( start_of_topic - 1 , i ) i = i + 1 if ( i > howbig ) exit enddo endif exit INFINITE end select if ( want_to_stop ()) exit INFINITE enddo INFINITE contains function want_to_stop () character ( len = len ( help_text )) :: response character ( len = 1 ) :: letter logical :: want_to_stop integer :: j integer :: jj doubleprecision :: val integer :: ierr position ( 1 ) = position ( 1 ) + 1 want_to_stop = . false . PROMPT : do if ( position ( 1 ) > position ( 2 )) then call journal ( 'sc' , 'continue ..' ) read ( stdin , '(a)' , iostat = ios ) response ! read letter to pause from standard input response = adjustl ( response ) letter = response ( 1 : 1 ) select case ( letter ) case ( ' ' , 'f' ) ! next page position ( 1 ) = 0 ! start new page case ( 'b' ) ! back one page call pageback ( 2 ) position ( 1 ) = 0 case ( '0' : '9' ) ! assumed to be a number call a2d ( response , val , ierr ) i = nint ( val ) - 1 i = max ( i , 1 ) i = min ( i , howbig - 1 ) position ( 1 ) = 0 case ( '-' , '+' ) ! assumed to be a number call pageback ( 1 ) call a2d ( response , val , ierr ) i = i + nint ( val ) i = max ( i , 1 ) i = min ( i , howbig - 1 ) position ( 1 ) = 0 case ( 't' ) ! topics old_topic = topic old_position = i topic = 'topics' position ( 1 ) = 0 exit PROMPT !do j=2,howbig !   if(help_text(j)(1:1) == '   ')cycle !   if(help_text(j)(1:3) == '===')cycle !   jj=merge(0,3,help_text(j-1)(1:3) == '===') !   if(numbered)then !      call journal('sc',j,'>',repeat(' ',jj)//help_text(j)) !   else !      call journal('sc','>',repeat(' ',jj)//help_text(j)) !   endif !enddo !call pageback(1) !i=max(1,i) !position(1)=position(2)+1 !cycle PROMPT case ( 'u' ) ! back one-half page call pageback ( 1 ) i = max ( 1 , i - position ( 2 ) / 2 - 1 ) position ( 1 ) = 0 case ( 'e' , 'k' ) ! back one line page call pageback ( 1 ) i = max ( 1 , i - 1 ) position ( 1 ) = 0 case ( 'y' , 'j' ) ! down one line page call pageback ( 1 ) i = max ( 1 , i + 1 ) position ( 1 ) = 0 case ( 'w' ) WRITEFILE : block character ( len = 1000 ) :: errmsg integer :: temp_lun response = adjustl ( response ( 2 :)) if ( response == '' ) response = 'userguide.txt' open ( newunit = temp_lun , file = response , status = 'new' , iostat = ios , iomsg = errmsg ) ! open help file if ( ios == 0 ) then write ( temp_lun , '(a)' , iostat = ios )( trim ( help_text ( k )), k = 1 , howbig ) call journal ( 'sc' , '<INFO> user guide is on file' , response ) close ( unit = temp_lun , iostat = ios ) else call journal ( errmsg ) endif endblock WRITEFILE i = max ( 1 , i - 1 ) case ( 'd' ) ! down one-half page i = min ( howbig - 1 , i - position ( 2 ) / 2 - 1 ) position ( 1 ) = 0 case ( 'r' ) ! repaint page call pageback ( 1 ) position ( 1 ) = 0 case ( '/' , 'n' ) ! find string below j = i ! hold if ( letter == 'n' ) response = last_response if ( response ( 2 :) == '' ) response = last_response i = i + 1 do if ( index ( lower ( help_text ( i )), trim ( response ( 2 :))) /= 0 ) then i = max ( 1 , i - 1 ) exit else i = i + 1 endif if ( i > howbig ) exit enddo if ( i > howbig ) i = j position ( 1 ) = 0 last_response = response case ( '\\') ! find string response=lower(adjustl(response(2:))) if(response == ' ')response=last_response jj=len_trim(response) do j=1,howbig if(index(lower(help_text(j)),response(:jj)) /= 0)then call journal(' sc ',j,help_text(j)) endif enddo i=i-1 call pageback(1) last_response=' / '//response case(' ? ',' N ',' p ')                                            ! find string above j=i ! hold if(letter == ' N '.or.letter == ' ')response=last_response if(response(2:) == '')response=last_response i=i-1 do if(index(lower(help_text(i)),trim(response(2:))) /= 0)then exit else i=i-1 endif if(i <= 1) then i=j exit endif enddo call pageback(1) position(1) = 0 last_response=response case(' g ')                                            ! repaint page i=1 position(1) = 0 case(' . ')                                            ! help position(1) = 0 numbered=.not.numbered case(' h ')                                            ! help call journal(' sc ',' # ---------------------------------------------------- # PAGING ') call journal(' sc ',' | f | SPACE b forward or backward one page | ') call journal(' sc ',' | u d redraw up or down one - half page | ') call journal(' sc ',' | r refresh page | ') call journal(' sc ',' | e y | j k refresh page moving up or down one line | ') call journal(' sc ',' # ---------------------------------------------------- # JUMPING ') call journal(' sc ',' | g go to top of manual | ') call journal(' sc ',' | NNN go to line number NNN . Use a sign ( +- ) | ') call journal(' sc ',' | for a relative move . | ') call journal(' sc ',' | . toggle line numbering | ') call journal(' sc ',' # ---------------------------------------------------- # SEARCHING ') call journal(' sc ',' | / STRING advance to next line containing string | ') call journal(' sc ',' | ? STRING search for string above current line | ') call journal(' sc ',' | n N find next occurrence up or down in file | ') call journal(' sc ',' | \\ STRING show all lines with specified string . | ') call journal(' sc ',' | t displays topic lines . | ') call journal(' sc ',' # ---------------------------------------------------- # ') call journal(' sc ',' | w FILENAME write entire user guide to local file | ') call journal(' sc ',' | h display this help | ') call journal(' sc ',' | q quit | ') call journal(' sc ',' # ---------------------------------------------------- # ') call journal(' sc ',' Anything else is ignored . ') call journal(' sc ',' Line count is ',i,' out of ',howbig,' . Page size is ',position(2),' ( see \"lines\" ) ') cycle case(' q ') position(1) = -1 want_to_stop=.true. case default call pageback(2) call journal(' sc ',' unknown option -- enter \"h\" for assistance or \"q\" to quit ') end select endif exit enddo PROMPT end function want_to_stop subroutine pageback(loops) integer,intent(in) :: loops integer            :: j do j=1,loops i=max(1,i-position(2)-1) enddo end subroutine pageback end subroutine help_command subroutine a2d(chars,valu,ierr) ! ident_2=\"@(#) M_strings a2d(3fp) subroutine returns double value from string\" !     1989,2016 John S. Urban. ! !  o works with any g-format input, including integer, real, and exponential. !  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0. !  o if the string happens to be ' eod ' no error message is produced so this string may be used to act as an end-of-data. !    IERR will still be non-zero in this case. character(len=*),intent(in)  :: chars                        ! input string character(len=:),allocatable :: local_chars doubleprecision,intent(out)  :: valu                         ! value read from input string integer,intent(out)          :: ierr                         ! error flag (0 == no error) character(len=*),parameter   :: fmt=\"(' ( bn , g ',i5,' . 0 ) ')\"     ! format used to build frmt character(len=15)            :: frmt                         ! holds format built to read input string character(len=256)           :: msg                          ! hold message from I/O errors character(len=3),save        :: nan_string=' NaN ' ierr=0                                                    ! initialize error flag to zero local_chars=chars msg='' if(len(local_chars) == 0)local_chars=' ' write(frmt,fmt)len(local_chars)                        ! build format of form ' ( BN , Gn . 0 ) ' read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string if(ierr /= 0)then                                         ! if an error occurred ierr will be non-zero. read(nan_string,' ( g3 . 3 ) ')valu call journal(' sc ',' * a2d * - cannot produce number from string [ ',chars,' ] ') if(msg /= '')then call journal(' sc ',' * a2d * - [ ',msg,' ] ') endif endif end subroutine a2d elemental pure function lower(str,begin,end) result (string) ! ident_3=\"@(#) M_strings lower(3f) Changes a string to lowercase over specified range\" character(*), intent(in)     :: str character(len(str))          :: string integer,intent(in),optional  :: begin, end integer                      :: i integer                      :: ibegin, iend integer,parameter             :: diff = iachar(' A ')-iachar(' a ') string = str ibegin=1 iend=len_trim(str) if (present(begin))then ibegin = min(max(1,begin),iend) endif if (present(end))then iend= max(1,min(iend,end)) endif do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range select case (str(i:i)) case (' A ':' Z ' ) string ( i : i ) = char ( iachar ( str ( i : i )) - diff ) ! change letter to miniscule case default end select enddo end function lower end module M_help","tags":"","loc":"sourcefile/m_help.f90.html"},{"title":"demo_unit_check_good.f90 – M_msg","text":"Source Code program demo_unit_check_good use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_bad implicit none integer :: x x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) call unit_check_good ( 'myroutine' , msg = 'checks on \"myroutine\" ' ) end program demo_unit_check_good","tags":"","loc":"sourcefile/demo_unit_check_good.f90.html"},{"title":"demo_help_command.f90 – M_msg","text":"Source Code program demo_help_command use M_help , only : help_command character ( len = :), allocatable :: help_text (:) integer :: position ( 2 ) position = [ 0 , 23 ] help_text = [ character ( len = 80 ) :: & '==============================================' ,& '   A sample help text file.                   ' ,& '   Note the first line MUST start with \"===\"  ' ,& '==============================================' ,& 'SUMMARY                                       ' ,& '  This is usually a crib sheet                ' ,& '==============================================' ,& 'SECTION1                                      ' ,& 'topic1                                        ' ,& '   A description of topic 1                   ' ,& '                                              ' ,& '   and any general text you want              ' ,& '                                              ' ,& 'topic2  A description of topic 2              ' ,& 'topic3                                        ' ,& '   A description of topic 3                   ' ,& '   more  description of topic 3               ' ,& '   and more description of topic 3 a          ' ,& '   and more description of topic 3 b          ' ,& '   and more description of topic 3 c          ' ,& '   and more description of topic 3 d          ' ,& '   and more description of topic 3 e          ' ,& '   and more description of topic 3 f          ' ,& '   and more description of topic 3 g          ' ,& '   and more description of topic 3 h          ' ,& '   and more description of topic 3 i          ' ,& '   and more description of topic 3 j          ' ,& '   and more description of topic 3 k          ' ,& '   and more description of topic 3 l          ' ,& '   and more description of topic 3 m          ' ,& '   and more description of topic 3 n          ' ,& '   and more description of topic 3 o          ' ,& '   and more description of topic 3 p          ' ,& '   and more description of topic 3 q          ' ,& '   and more description of topic 3 r          ' ,& '   and more description of topic 3 s          ' ,& '   and more description of topic 3 t          ' ,& '   and more description of topic 3 u          ' ,& '   and more description of topic 3 v          ' ,& '   and more description of topic 3 w          ' ,& '   and more description of topic 3 x          ' ,& '   and more description of topic 3 y          ' ,& '   and more description of topic 3 z          ' ,& '==============================================' ,& 'SECTION2                                      ' ,& 'topic4  A description of topic 4              ' ,& '   this is the last part of SECTION1          ' ,& 'topic5                                        ' ,& '  This is all about the fifth topic and is    ' ,& '  just displayed as-is. The text cannot start ' ,& '  in column one or it will be seen as the     ' ,& '  beginning of a topic.                       ' ,& '==============================================' ,& '                                              ' ] write ( * , * ) '>>>>>' call help_command ( help_text , '' , position ) write ( * , * ) '>>>>>topic1' call help_command ( help_text , 'topic1' , position ) write ( * , * ) '>>>>>topics' call help_command ( help_text , 'topics' , position ) write ( * , * ) '>>>>>manual' call help_command ( help_text , 'manual' , position ) end program demo_help_command","tags":"","loc":"sourcefile/demo_help_command.f90.html"},{"title":"demo_journal.f90 – M_msg","text":"Source Code program demo_journal use M_journal , only : journal !! BASIC USAGE call journal ( 'write to standard output as-is, and trail file as a comment if open' ) ! since we have not opened a trail file yet, only stdout will display output call journal ( 'c' , 'ignored, as trail file is not open' ) ! now open trail file \"trail\" call journal ( 'o' , 'trail' ) call journal ( 'sc' , 'same thing except now trail file is open' ) ! only write to trail file if open call journal ( 'c' , 'not ignored, as trail file is open. Written with # suffix' ) call journal ( 't' , 'not ignored, as trail file is open. Written as-is' ) ! turn off trail file call journal ( 'o' , '' ) end program demo_journal","tags":"","loc":"sourcefile/demo_journal.f90.html"},{"title":"demo_dp_accdig.f90 – M_msg","text":"Source Code program demo_dp_accdig ! fortran 90 example use M_verify , only : dp_accdig implicit none integer :: digi doubleprecision :: a , b integer :: i10 , i20 , i30 integer :: ind , ind1 , ind2 real :: acurcy , acurcy1 , acurcy2 doubleprecision :: vals ( 9 ) data vals / & & 1.234680d0 , 1.2345378d0 , 2.2234568d0 , 1.2345678d0 , & & 1.2345679d0 , - 1.2345678d0 , 7 6.234567d0 , 2.4691356d0 , & & 0.0d0 / write ( * , * ) '=========================' do i10 = 0 , 16 a = 1.0d0 b = a + 1.0d0 / ( 10 ** i10 ) call dp_accdig ( a , b , 8.0 , acurcy , ind ) write ( * , * ) i10 , a , b , acurcy , ind enddo write ( * , * ) '=========================' digi = 16 do i20 = 0 , digi a = 1.0d0 b = a + 1.0d0 / ( 10 ** i20 ) call dp_accdig ( a , b , dble ( digi ), acurcy , ind ) write ( * , * ) i20 , a , b , acurcy , ind enddo write ( * , * ) '=========================' do i30 = 1 , 9 call dp_accdig ( 1.2345678d0 , vals ( i30 ), 8.0 , acurcy1 , ind1 ) call dp_accdig ( vals ( i30 ), 1.2345678d0 , 8.0 , acurcy2 , ind2 ) write ( * , * ) i30 , vals ( i30 ), acurcy1 , acurcy2 , ind1 , ind2 enddo end program demo_dp_accdig","tags":"","loc":"sourcefile/demo_dp_accdig.f90.html"},{"title":"demo_unit_check_stop.f90 – M_msg","text":"Source Code program demo_unit_check_stop use M_verify , only : unit_check_start , unit_check_done use M_verify , only : unit_check use M_verify , only : unit_check_good , unit_check_stop , unit_check_bad use M_verify , only : unit_check_command , unit_check_keep_going , unit_check_level implicit none integer :: x unit_check_command = '' unit_check_keep_going = . true . unit_check_level = 0 x = 10 call unit_check_start ( 'myroutine' ) call unit_check ( 'myroutine' , x > 3 , 'test if big enough' ) call unit_check ( 'myroutine' , x < 100 , 'test if small enough' ) if ( x /= 0 ) then call unit_check_bad ( 'myroutine' , msg = 'x /= 0' ) endif call unit_check_done ( 'myroutine' , msg = 'checks on \"myroutine\"' ) call unit_check_stop () end program demo_unit_check_stop","tags":"","loc":"sourcefile/demo_unit_check_stop.f90.html"}]}